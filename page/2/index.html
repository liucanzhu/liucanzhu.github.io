<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>canzhu&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="canzhu&#39;s blog">
<meta property="og:url" content="https://liucanzhu.github.io/page/2/index.html">
<meta property="og:site_name" content="canzhu&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liu Canzhu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="canzhu's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">canzhu&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://liucanzhu.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-rust15" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/10/rust15/" class="article-date">
  <time class="dt-published" datetime="2024-10-09T16:17:15.815Z" itemprop="datePublished">2024-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/10/rust15/">rust 学习笔记十五 Rust 的模块化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）概念"><a href="#（一）概念" class="headerlink" title="（一）	概念"></a>（一）	概念</h3><h4 id="1-packages"><a href="#1-packages" class="headerlink" title="1. packages"></a>1. packages</h4><p>一项cargo特性，可让您<strong>构建、测试和共享crates</strong>, 一个packages可以包含多个binary crates和可选的lib crates。至少包含一个crate</p>
<p>Packages的基础结构如图所示：</p>
<p><img src="/../assets/img/15-1.jpg" alt="图15-1" title="15-1"></p>
<p>其中bin目录下存放的就是多个binary crates，通过<code>cargo new</code>创建的项目就是一个标准的package结构，如果在创建时使用<code>cargo new –lib name</code>, 创建出的src目录下的主文件就是lib.rs(正常情况下是main.rs)像这样创建出的package就是只有单个crate，这两种crate分别叫<strong>binary crate和lib crate</strong>，区别在于binary crate是可以直接通过cargo run 执行的，而lib则不能</p>
<h4 id="2-crates"><a href="#2-crates" class="headerlink" title="2. crates"></a>2. crates</h4><p>生成库或可执行文件的module tree, 刚才有提到，crates分为binary crate 和 library crate，一般情况下有一个lib crate,项目的bin目录下包含多个binary crate</p>
<h4 id="3-modules-and-use"><a href="#3-modules-and-use" class="headerlink" title="3. modules and use"></a>3. modules and use</h4><p>控制路径的组织、范围和隐私</p>
<p>在一个crate中可以包含多个module</p>
<p>首先是module的声明</p>
<h5 id="a-使用mod关键字："><a href="#a-使用mod关键字：" class="headerlink" title="a. 使用mod关键字："></a>a. 使用mod关键字：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mod a &#123;</span><br><span class="line">    const num:usize = 1;</span><br><span class="line">    fn echo() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模块中可以定义方法, 同时模块也支持嵌套：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mod a &#123;</span><br><span class="line">    const num:usize = 1;</span><br><span class="line">    fn echo() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    mod b &#123;</span><br><span class="line">        fn log() &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当需要在同crate中的main函数访问mod中的方法时, 需要通过双冒号调用：</p>
<p><img src="/../assets/img/15-2.jpg" alt="图15-2" title="15-2"></p>
<p>发现报错：方法是<strong>默认私有</strong>的，现在我们需要用到pub关键字</p>
<h5 id="b-pub关键字："><a href="#b-pub关键字：" class="headerlink" title="b. pub关键字："></a>b. pub关键字：</h5><p>将mod中的对应法修改为共有的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub fn echo() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是此时如果需要在子模块b中调用父级模块a的echo方法，是可以不用声明为pub的，只不过需要在子模块中声明<code>use super::echo;</code>表示继承父模块的方法</p>
<p>如果mod中嵌套的层级较深，需要调用很底层的方法的话，除了需要将路径上的子模块和方法都设置为pub外，每次调用都写出全部路径似乎显得不够简洁，影响可读性，在这里可以用到use关键字</p>
<h5 id="c-use关键字"><a href="#c-use关键字" class="headerlink" title="c. use关键字:"></a>c. use关键字:</h5><p><img src="/../assets/img/15-3.jpg" alt="图15-3" title="15-3"></p>
<p>之后就可以在外层直接通过方法名调用了, 当不同路径的两个同名的方法都被use声明时，为了区分，需要将其中一个方法用as关键字声明为另外的别名</p>
<h5 id="d-as关键字"><a href="#d-as关键字" class="headerlink" title="d. as关键字:"></a>d. as关键字:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">use a::&#123;b::log, log as other_log&#125;;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    //a::b::log();</span><br><span class="line"></span><br><span class="line">    log();</span><br><span class="line">    other_log();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mod a &#123;</span><br><span class="line">    const num:usize = 1;</span><br><span class="line">    pub fn log() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    pub mod b &#123;</span><br><span class="line">        pub fn log() &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时as在rust中也可以用于基础类型的类型转换</p>
<h5 id="从刚才的pub中可以扩展说一下Rust中的可见性控制"><a href="#从刚才的pub中可以扩展说一下Rust中的可见性控制" class="headerlink" title="从刚才的pub中可以扩展说一下Rust中的可见性控制"></a>从刚才的pub中可以扩展说一下Rust中的可见性控制</h5><p><strong>private(default)</strong> 默认情况下都是私有的</p>
<p><strong>pub(crate)</strong> 仅限于在同一个crate内为公开，其余crate不能调用</p>
<p><strong>pub(in path)</strong> 范围更加精细，控制只能在具体的模块中能访问</p>
<p><strong>pub use</strong></p>
<p>假设有以下结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 在 lib.rs 或 main.rs</span><br><span class="line">mod outer &#123;</span><br><span class="line">    pub mod inner &#123;</span><br><span class="line">        pub fn public_function() &#123;</span><br><span class="line">            println!(&quot;Called public_function()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub use outer::inner::public_function;</span><br></pre></td></tr></table></figure>

<p>通过 pub use，我们将 publicfunction 重新导出到了 crate 的根作用域。现在，其他模块可以使用 use 语句直接访问 public_function，而不需要指定完整的模块路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use crate::public_function;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    public_function(); // 直接调用，无需通过模块路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Paths"><a href="#4-Paths" class="headerlink" title="4.Paths"></a>4.Paths</h4><p>一种命名项目的方式，例如struct、function或modules, 分为<strong>absolute path crate  绝对路径，relative path super self 相对路径</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    crate::a::log();</span><br><span class="line">    a::b::log();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mod a &#123;</span><br><span class="line">    const num:usize = 1;</span><br><span class="line">    pub fn log() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    pub mod b &#123;</span><br><span class="line">        pub fn log() &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>crate::a::log();</code>是绝对路径, <code>a::b::log();</code>是相对路径, 同时上文中还提到了用super关键字来调用父级mod的方法，self表示模块本身,用于调用同一个mod中的其他方法</p>
<h4 id="5-workspace"><a href="#5-workspace" class="headerlink" title="5.workspace:"></a>5.workspace:</h4><p>Workspace是一个由多个crates组成的项目结构，主要用于</p>
<p>代码共享：</p>
<p>在 workspace 中，你可以有一个或多个crate（library crates）和二进制 crate（binary crates）。crate 可以被其他 crate 作为依赖项使用，从而实现代码的共享。</p>
<p>以及统一依赖管理：</p>
<p>workspace 允许你在一个中央位置管理所有 crate 的依赖，这有助于避免重复的依赖项和版本冲突。</p>
<p>使用方法是：使用 cargo new 创建子目录，并在每个子目录中创建一个新的 Cargo.toml 文件，然后配置依赖关系：在根 Cargo.toml 文件中使用 [workspace] 部分配置依赖关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[workspace]</span><br><span class="line">menbers=[&quot;xx&quot;,&quot;xx&quot;,&quot;xx&quot;]</span><br></pre></td></tr></table></figure>

<p>workspace中可以有一个主package，也可以没有</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/10/10/rust15/" data-id="cm222ty5b0000pguyhx2sh1hc" data-title="rust 学习笔记十五 Rust 的模块化" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust14" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/28/rust14/" class="article-date">
  <time class="dt-published" datetime="2024-09-27T19:35:47.737Z" itemprop="datePublished">2024-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/28/rust14/">rust 学习笔记十四 Rust 的返回值与错误处理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）Option返回值"><a href="#（一）Option返回值" class="headerlink" title="（一）	Option返回值"></a>（一）	Option返回值</h3><h4 id="1-解构Option"><a href="#1-解构Option" class="headerlink" title="1. 解构Option"></a>1. 解构Option</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Option&lt;T&gt;&#123;</span><br><span class="line">    Some(T)</span><br><span class="line">    None,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单解释就是:一个变量要么有值:Some(T),要么为空:None</p>
<p>在之前的文章中出现过这样的例子：</p>
<p><img src="/../assets/img/14-1.jpg" alt="图14-1" title="14-1"></p>
<h4 id="2-辅助函数"><a href="#2-辅助函数" class="headerlink" title="2. 辅助函数"></a>2. 辅助函数</h4><p>但是match也有弊端，代码**较为冗杂，当嵌套较深时，不够优雅，因此，option提供了一系列辅助函数</p>
<p>下面举例几个常用的进行说明：</p>
<p>a. unwrap</p>
<p><img src="/../assets/img/14-2.jpg" alt="图14-2" title="14-2"></p>
<p>可见，unwrap可以直接跳过match，得到Some包裹的实际值，但是<strong>如果此时待解构的值是None,直接调用unwrap会发生panic</strong></p>
<p>b. is_some is_none</p>
<p>可以使用is_some和is_none方法来判断Option中是否存在值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">let</span> v=[10,40,30];</span><br><span class="line">    ifv.get(1).<span class="function"><span class="title">is_some</span></span>()&#123;</span><br><span class="line">        println!(<span class="string">&quot;&#123;&#125;&quot;</span>,v[1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用is_none 和 is_some好处是<strong>可以在none值时不panic</strong></p>
<p>c. unwrap_or</p>
<p>如果既需要在报错时候不panic, 也希望能直接拿到值，可以使用unwrap_or方法：</p>
<p><img src="/../assets/img/14-3.jpg" alt="图14-3" title="14-3"></p>
<p>由此可见，<strong>不仅可以取值，还可以在值无效时设置默认值</strong></p>
<h3 id="（二）错误处理"><a href="#（二）错误处理" class="headerlink" title="（二）	错误处理"></a>（二）	错误处理</h3><p>Rust中的错误主要分为两类:</p>
<p><strong>可恢复错误</strong>: 通常用于从系统全局角度来看可以接受的错误,例如:处理用户的访问、操作等错误,这些错误只会影响某个用户自身的操作进程,而不会对系统的全局稳定性产生影响</p>
<p><strong>不可恢复错误</strong>: 刚好相反,该错误通常是全局性或者系统性的错误,例如数组越界访问,系统启动时发生了影响启动流程的错误等等,这些错误的影响往往对于系统来说是致命的</p>
<h4 id="1-Result用于可恢复错误"><a href="#1-Result用于可恢复错误" class="headerlink" title="1. Result&lt;T,E&gt;用于可恢复错误"></a>1. Result&lt;T,E&gt;用于可恢复错误</h4><p>大部分错误并没有严重到需要程序完全停止执行。有时候,一个函数失败,仅仅就是因为一个容易理解和响应的原因, 例如,如果因为打开一个并不存在的文件而失败,此时我们可能想要创建这个文件,而不是终止进程。</p>
<p>泛型参数T代表成功时存入的正确值的类型,存放方式是OK(T)</p>
<p>E代表错误时存入的错误值,存放方式是Err(E)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">enum Result&lt;T,E&gt; &#123;</span><br><span class="line">Ok(T),</span><br><span class="line">Err(E),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum MathError&#123;</span><br><span class="line">    DivisionByZero,</span><br><span class="line">    NegativeSquareRoot,</span><br><span class="line">&#125;</span><br><span class="line">fn div(a:i32, b: i32) -&gt; Result&lt;f64,MathError&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> b!=0&#123;</span><br><span class="line">    Ok(a as f64 / b as f64)</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    Err(MathError::DivisionByZero)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn sqrt(a:f64) -&gt;Result&lt;f64,MathError&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt;0.0&#123;</span><br><span class="line">        Err(MathError::NegativeSquareRoot)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Ok(a.sqrt())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理result：</p>
<p>基础示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> f=File::open(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> f=match f&#123;</span><br><span class="line">    Ok(file)=&gt;file,</span><br><span class="line">    Err(error)=&gt;&#123;</span><br><span class="line">        panic!(<span class="string">&quot;Problem opening the file:&#123;:?&#125;&quot;</span>,error)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对返回的错误进行处理, 我们希望对不同的错误原因采取不同的行为:</p>
<p>如果File::open因为文件不存在而失败,我们希望创建这个文件并返回新文件的句柄</p>
<p>如果File::open因为任何其他原因失败,例如没有打开文件的权限,我们仍然panic!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line">use std::io::ErrorKind;</span><br><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">let</span> greeting_file_result=File::open(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">let</span> greeting_file=match greeting_file_result &#123;</span><br><span class="line">        Ok(file)=&gt;file,</span><br><span class="line">        Err(error)=&gt;match error.<span class="function"><span class="title">kind</span></span>()&#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; match File::create(<span class="string">&quot;hello.txt&quot;</span>)&#123;</span><br><span class="line">                Ok(<span class="built_in">fc</span>)=&gt;<span class="built_in">fc</span>,</span><br><span class="line">                Err(e)=&gt;panic!(<span class="string">&quot;Problem creating the file:&#123;e:?&#125;&quot;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error=&gt;&#123;</span><br><span class="line">                panic!(<span class="string">&quot;Problem opening the file:&#123;other_error:?&#125;&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Result的辅助方法"><a href="#2-Result的辅助方法" class="headerlink" title="2.Result&lt;T,E&gt;的辅助方法"></a>2.Result&lt;T,E&gt;的辅助方法</h4><p>match能够胜任它的工作,不过它可能有点冗长并且不总是能很好的的表明其意图。Result&lt;T,E&gt;类型定义了很多辅助方法来处理各种情况</p>
<p>a. unwrap</p>
<p>其中之一叫做 unwrap,它的实现就类似于示例9-4中的match语问,如果 Result值是成员0k,unwrap会返回 0k 中的值,如果Result是成员Err,unwrap会为我们调用 panic!</p>
<p><img src="/../assets/img/14-5.jpg" alt="图14-5" title="14-5"></p>
<p>b. unwrap_or</p>
<p>同时也支持使用unwrap_or设置失败之后的默认值</p>
<p>c. expect</p>
<p>expect跟unwrap 很像,也是遇到错误直接 panic,但是会带上自定义的错误提示信息,相当于重载了错误打印的函数:</p>
<p><img src="/../assets/img/14-6.jpg" alt="图14-6" title="14-6"></p>
<p>d. map</p>
<p><code>Result&lt;T, E&gt; -&gt; Result&lt;U, E&gt;</code></p>
<p><img src="/../assets/img/14-7.jpg" alt="图14-7" title="14-7"></p>
<p>e. map_err</p>
<p><code>Result&lt;T,E&gt; -&gt; Result&lt;T,F&gt;</code>, 对错误类型进行转换</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line"></span><br><span class="line">fn x() -&gt;Result&lt;(),String&gt;&#123;</span><br><span class="line">    <span class="built_in">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>).map_err(|e: std:: io::Error| -&gt;String&#123;format!(<span class="string">&quot;&#123;e&#125;&quot;</span>)&#125;);</span><br><span class="line">    match f&#123;</span><br><span class="line">        Err(e)=&gt;Err(e),</span><br><span class="line">        Ok(_)=&gt;&#123;</span><br><span class="line">            Ok(())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实上述的代码在Err(e)的时候再将e的类型转换为String也可以，但是当遇到下面这种情况的时候：</p>
<p>传播错误</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fn read_username_from_file() -&gt;Result&lt;String, io::Error&gt;&#123;</span><br><span class="line">    //打开文件,f是`Result&lt;文件句柄,io::Error&gt;</span><br><span class="line">    <span class="built_in">let</span> f=File::open(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">let</span> mut f=match f&#123;</span><br><span class="line">    //打开文件成功,将file句柄赋值给f</span><br><span class="line">    Ok(file)=&gt;file,</span><br><span class="line">    //打开文件失败,将错误返回(向上传播)</span><br><span class="line">    Err(e)=&gt;<span class="built_in">return</span> Err(e),</span><br><span class="line">    &#125;;</span><br><span class="line">    //创建动态字符串s</span><br><span class="line">    <span class="built_in">let</span> mut s=String::new();</span><br><span class="line">    //从f文件句柄读取数据并写入s中</span><br><span class="line">    match f.read_to_string(&amp;mut s)&#123;</span><br><span class="line">    //读取成功,返回0k封装的字符串</span><br><span class="line">    Ok(_)=&gt;Ok(s),</span><br><span class="line">    //将错误向上传播</span><br><span class="line">    Err(e)=&gt;Err(e),</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>整个打开文件再进行读取的过程需要非常多的match，因此可以<strong>使用传播错误的简写?运算符</strong></p>
<p>对于Result, 如果结果是<strong>Ok(T),则把T赋值给f, 如果结果是Err(E),则返回该错误</strong></p>
<p>对于Option, 如果值是Some,<strong>Some中的值作为表达式的返回值同时函数继续, 如果值是None,此时None会从函数中提前返回</strong></p>
<p>所以?特别适合用来传播错误</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn c() -&gt; Result&lt;String, io::Error&gt; &#123;</span><br><span class="line">    <span class="built_in">let</span> mut f: File=File::open(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="built_in">let</span> mut s=String::new();</span><br><span class="line">    f.read_to_string(&amp;mut s)?;</span><br><span class="line">    Ok(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法会使得代码简洁很多,但是当返回值改为Result&lt;String, String&gt;的时候，将不再适用，此时需要用到map_err,来对error进行类型转换</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File::open(<span class="string">&quot;hello.txt&quot;</span>).map_err(|e| format!(<span class="string">&quot;&#123;e&#125;&quot;</span>))?</span><br><span class="line">read_to_string(&amp;mut s).map_err(|e| format!(<span class="string">&quot;&#123;e&#125;&quot;</span>))?</span><br><span class="line">Ok(s)</span><br></pre></td></tr></table></figure>

<h4 id="3-Option与-result的相互转化"><a href="#3-Option与-result的相互转化" class="headerlink" title="3. Option与 result的相互转化"></a>3. Option与 result的相互转化</h4><p>a. Option-&gt;Result: ok_or<br>Some(v) 转为 Ok(v)<br>None 转为 Err(err)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn first(arr: &amp;[i32]) -&gt; Result&lt;&amp;i32, &amp;str&gt; &#123;</span><br><span class="line">    arr.get(0).ok_or(<span class="string">&quot;out of index&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b. Result-&gt;Option: err<br>Err(e) 转为 Some(e)<br>Ok(v) 转为 None</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">let</span> f=File::open(<span class="string">&quot;hello.txt&quot;</span>).err();</span><br><span class="line">    <span class="keyword">if</span> f.<span class="function"><span class="title">is_some</span></span>()&#123;</span><br><span class="line">        println!(<span class="string">&quot;no file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-panic-用于不可恢复错误"><a href="#4-panic-用于不可恢复错误" class="headerlink" title="4. panic!用于不可恢复错误"></a>4. panic!用于不可恢复错误</h4><p>a. 被动触发：</p>
<p>C语言中,尝试读取数据结构之后的值是未定义行为(undefined behavior)。你会得到任何对应数据结构中这个元素的内存位置的值,甚至是这些内存并不属于这个数据结构的情况。这被称为缓冲区溢出(buffer overread),并可能会导致安全漏洞,比如攻击者<br>可以像这样操作索引来读取储存在数据结构之后不被允许的数据。为了保护程序远离这类漏洞,如果尝试读取一个索引不存在的元素,Rust会停止执行并拒绝继续。尝试运行上面的程序会出现如下</p>
<p><img src="/../assets/img/14-4.jpg" alt="图14-4" title="14-4"></p>
<p>b. 主动调用：</p>
<p>对此,Rust为我们提供了panic!宏,当调用执行该宏时,程序会打印印出一个错误信息,展开报错点往前的函数调用堆栈,最后退出程序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    panic!(<span class="string">&quot;crash and burn&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>panic时的两种终止方式</p>
<p>栈展开(unwinding)(默认):Rust会回溯栈上数据和函数调用,因此也意味着更多的善后工作,好处是可以给出充分的报错信息和栈调用信息,便于事后的问题复盘, 直接终止(abort):不清理数据就直接退出程序,善后工作交与操作系统来负责</p>
<p>对于绝大多数用户,使用默认选择是最好的,但是当你关心最终编译出的二进制可执行文件大小时,那么可以尝试夫使用直接终止的防式,例如下面的配置修改Cargo.toml文件,实现在 release模式下遇到panic直接终止</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[profile.release]</span><br><span class="line">panic=<span class="string">&#x27;abort&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后在控制台执行 <code>RUST_BACKTRACE=1 cargo run –release</code></p>
<p><strong>Windows用户需要先在控制台执行 $Env:RUST_BACKTRACE&#x3D;1，再执行cargo run</strong></p>
<h3 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let a = 4;</span><br><span class="line">    let b = Some(1); // 假设 b 是 None</span><br><span class="line">    match call(a, b.unwrap_or(1)) &#123;</span><br><span class="line">        Ok(result) =&gt; println!(&quot;Result: &#123;&#125;&quot;, result),</span><br><span class="line">        Err(e) =&gt; println!(&quot;Error: &#123;&#125;&quot;, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn call(a: i32,b:i32) -&gt; Result&lt;f64,String&gt;&#123;</span><br><span class="line">    let r = divide(a, b);</span><br><span class="line">    let s = match r &#123;</span><br><span class="line">        Some(value) =&gt; sqrt(value),</span><br><span class="line">        None =&gt; return Err(&quot;Division by zero&quot;.to_string()),</span><br><span class="line">    &#125;;</span><br><span class="line">    s.map_err(|e| match e &#123;</span><br><span class="line">        MathError::DivisionByZero =&gt; &quot;Division by zero&quot;.to_string(),</span><br><span class="line">        MathError::NegativeSquareRoot =&gt; &quot;Negative square root&quot;.to_string(),</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fn divide(a:i32,b:i32)-&gt;Option&lt;f64&gt;&#123;</span><br><span class="line">    if b!=0&#123;</span><br><span class="line">        Some(a as f64/b as f64)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        None</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub enum MathError&#123;</span><br><span class="line">    DivisionByZero,</span><br><span class="line">    NegativeSquareRoot,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn sqrt(x:f64) -&gt;Result&lt;f64,MathError&gt;&#123;</span><br><span class="line">    if x&lt;0.0 &#123;</span><br><span class="line">        Err(MathError::NegativeSquareRoot)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        Ok(x.sqrt())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/28/rust14/" data-id="cm1l4o57u0000k4uy82xz2co1" data-title="rust 学习笔记十四 Rust 的返回值与错误处理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust13" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/24/rust13/" class="article-date">
  <time class="dt-published" datetime="2024-09-23T17:27:48.596Z" itemprop="datePublished">2024-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/24/rust13/">rust 学习笔记十三 Rust 中的集合</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Rust中的集合主要分为两类， Vector和HashMap</p>
<h3 id="（一）Vector"><a href="#（一）Vector" class="headerlink" title="（一）Vector"></a>（一）Vector</h3><h4 id="1-什么是Vec"><a href="#1-什么是Vec" class="headerlink" title="1.什么是Vec"></a>1.什么是Vec</h4><p>Vec是一个<strong>动态数组,可以根据需要动态增长和缩小</strong>。适用于需要按顺序存储数据的场景</p>
<h4 id="2-Vec的基本操作"><a href="#2-Vec的基本操作" class="headerlink" title="2.Vec的基本操作"></a>2.Vec的基本操作</h4><p>a.创建和初始化</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    //创建空vec</span><br><span class="line">    <span class="built_in">let</span> v : Vec&lt;i32&gt; = Vec::new();</span><br><span class="line"></span><br><span class="line">    //使用宏来创建vec</span><br><span class="line">    <span class="built_in">let</span> v = vec![1,2,3,4,5];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>b.添加元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">let</span> mut v : Vec&lt;i32&gt; = Vec::new();</span><br><span class="line">v.push(1);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先将其改为mut，然后向其中push即可</p>
<p>c.访问元素</p>
<p>可以使用<strong>直接引用</strong>访问：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> first: &amp;i32 = &amp;v[0];</span><br></pre></td></tr></table></figure>

<p>也可以使用<strong>get方法</strong>进行获取</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">match v.get(0) &#123;</span><br><span class="line">    Some(i) =&gt; &#123;&#125;,</span><br><span class="line">    _=&gt;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为get 获取到的元素是option类型的，所以需要match进行解构</p>
<p>但是第一种方法当访问的元素下标超出了数组长度时会panic</p>
<p>d.修改元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v[0] = 10;</span><br></pre></td></tr></table></figure>

<p>首先也需要声明数组为mut，然后直接对对应元素赋值就行</p>
<p>e.遍历元素</p>
<p>引用遍历：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">        println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不使用引用直接遍历会<strong>导致所有权发生转移</strong></p>
<h4 id="3-Vec的进阶用法"><a href="#3-Vec的进阶用法" class="headerlink" title="3.Vec的进阶用法"></a>3.Vec的进阶用法</h4><p>a. 使用枚举存储多种类型</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum SpreadheetCell &#123;</span><br><span class="line">    Int(i32),</span><br><span class="line">    Float(f64),</span><br><span class="line">    Test(String)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b. 容量与重新分配</p>
<p><img src="/../assets/img/13-1.jpg" alt="图13-1" title="13-1"></p>
<p>可以发现，在向数组中push 元素前后，数组的容量<strong>并没有发生变化</strong>，都等于初始化时设定的容量，因为当向数组中添加的元素长度小于此值时，数组并不会扩容，<strong>如果我们设置初始容量为0，就会发现每次push元素都会导致容量的扩张</strong></p>
<h4 id="4-Vec的常见陷阱"><a href="#4-Vec的常见陷阱" class="headerlink" title="4.Vec的常见陷阱"></a>4.Vec的常见陷阱</h4><p>a. 不安全的索引访问</p>
<p>指索引下标不能超过数组长度-1</p>
<p>b. 可变引用与不可变引用的混用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> mut v = vec![1,2,3,4,5];</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> first = &amp;v[0];</span><br><span class="line"></span><br><span class="line">v.push(4);</span><br><span class="line"></span><br><span class="line">println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,first);</span><br></pre></td></tr></table></figure>

<p>在这种情况下，会报错所有权发生了转移，不再属于first.无法打印，因为<strong>first是动态数组的非可变引用，而v是动态数组的可变引用， 理论上可变引用和非可变引用不能同时存在</strong></p>
<p>要解决这个问题，可以将</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> mut v = vec![1,2,3,4,5];</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">let</span> first = &amp;v[0];</span><br><span class="line">    println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v.push(4);</span><br></pre></td></tr></table></figure>

<p>不可变引用部分的代码单独放到一个作用域中</p>
<h3 id="（二）HashMap"><a href="#（二）HashMap" class="headerlink" title="（二）	HashMap"></a>（二）	HashMap</h3><h4 id="1-什么是HashMap"><a href="#1-什么是HashMap" class="headerlink" title="1.什么是HashMap"></a>1.什么是HashMap</h4><p>HashMap是一个键值对(key-value)存储的数据结构, 适用于<strong>需要快速查找数据的场景</strong>,（时间复杂度O(1)）</p>
<h4 id="2-HashMap的基本操作"><a href="#2-HashMap的基本操作" class="headerlink" title="2. HashMap的基本操作"></a>2. HashMap的基本操作</h4><p>a.创建和初始化</p>
<p><img src="/../assets/img/13-2.jpg" alt="图13-2" title="13-2"></p>
<p>b.访问元素</p>
<p><img src="/../assets/img/13-3.jpg" alt="图13-3" title="13-3"></p>
<p>可以看出HashMap的get函数需要传入key的引用，而且<strong>得到的元素是Option类型，需要通过match解析</strong></p>
<p>c.遍历元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (team, score) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>,team,score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hashmap的引用自身实现了一个<strong>迭代器</strong></p>
<h4 id="3-HashMap的进阶用法"><a href="#3-HashMap的进阶用法" class="headerlink" title="3. HashMap的进阶用法"></a>3. HashMap的进阶用法</h4><p>a.更新哈希表</p>
<p><img src="/../assets/img/13-4.jpg" alt="图13-4" title="13-4"></p>
<p>由此可以看出更新HashMap也可以用insert</p>
<p><img src="/../assets/img/13-5.jpg" alt="图13-5" title="13-5"></p>
<p>由此可以看出更新HashMap也可以用entry（key）.or_insert(value)的格式进行更改，只不过当key存在时，值不会发生变化，当key不存在时，会进行添加，如果需要用这个函数对已知值进行修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> _entry = scores.entry(String::from(<span class="string">&quot;Red&quot;</span>)).or_insert(99);</span><br><span class="line"> *_entry *= 10;</span><br></pre></td></tr></table></figure>

<p>则需要先拿到对应值的引用（该函数的返回值就是对应值的引用），然后解构修改</p>
<p>b.合并哈希表</p>
<p><img src="/../assets/img/13-6.jpg" alt="图13-6" title="13-6"></p>
<h4 id="4-HashMap的常见陷阱"><a href="#4-HashMap的常见陷阱" class="headerlink" title="4. HashMap的常见陷阱"></a>4. HashMap的常见陷阱</h4><p>a. 哈希冲突</p>
<p><img src="/../assets/img/13-7.jpg" alt="图13-7" title="13-7"></p>
<p>由此可见，不同的两个值的hash是不一样的</p>
<p>b值的所有权问题</p>
<p><img src="/../assets/img/13-8.jpg" alt="图13-8" title="13-8"></p>
<p>由此可见，当参数被传入函数insert中之后，发生了所有权的转移，之前的参数将不再有效，此时如果需要继续使用参数，需要在传入函数时使用clone():</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.insert(field_name.clone(), field_value.clone());</span><br></pre></td></tr></table></figure>

<h3 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h3><ol>
<li>使用Vec实现一个简单的栈，实现一个简单的栈(后进先出,LIFO)数据结构,支持push、pop和peek操作。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[derive(Debug)]</span></span><br><span class="line">struct VecA&#123;</span><br><span class="line">    vec:Vec&lt;i32&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl VecA &#123;</span><br><span class="line">    fn new(vec:Vec&lt;i32&gt;) -&gt; VecA&#123;</span><br><span class="line">        VecA &#123; vec: vec &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn add(&amp;mut self, num: i32) &#123;</span><br><span class="line">        self.vec.push(num)</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    fn delete(&amp;mut self) -&gt; Option&lt;i32&gt;&#123;</span><br><span class="line">        self.vec.pop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn peek(&amp; self, index:usize) -&gt; Option&lt;&amp;i32&gt; &#123;</span><br><span class="line">        self.vec.get(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> mut rect1=VecA::new(vec![1,2,3]);</span><br><span class="line">    println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,rect1);</span><br><span class="line">    rect1.add(1);</span><br><span class="line">    println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,rect1);</span><br><span class="line">    <span class="built_in">let</span> s = rect1.delete();</span><br><span class="line">    match s &#123;</span><br><span class="line">        Some(value) =&gt; &#123;</span><br><span class="line">            println!(<span class="string">&quot;删除的最后一个元素是：&#123;&#125;&quot;</span>,value);</span><br><span class="line">        &#125;</span><br><span class="line">        None =&gt; &#123;println!(<span class="string">&quot;已经没有元素&quot;</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">let</span> num = rect1.peek(0);</span><br><span class="line">    match num &#123;</span><br><span class="line">        Some(value) =&gt; &#123;</span><br><span class="line">            println!(<span class="string">&quot;&#123;&#125;&quot;</span>,value);</span><br><span class="line">        &#125;</span><br><span class="line">        None =&gt; &#123;println!(<span class="string">&quot;不存在该元素&quot;</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2:使用HashMap实现一个字频统计器,编写一个程序,统计一个字符串中每个单词出现的频率。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> text = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">let</span> mut frequency_counter = HashMap::new();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> character <span class="keyword">in</span> text.<span class="function"><span class="title">chars</span></span>() &#123;</span><br><span class="line">            *frequency_counter.entry(character).or_insert(0) += 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (character, frequency) <span class="keyword">in</span> &amp;frequency_counter &#123;</span><br><span class="line">        println!(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, character, frequency);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>综合练习:使用Vec和HashMap实现一个简单的书籍库存管理系统</li>
</ol>
<p>实现一个书籍库存管理系统,可以添加书籍、查询库存、更新库存以及删除书籍</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">struct BookInventory &#123;</span><br><span class="line">    inventory: HashMap&lt;String, i32&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl BookInventory &#123;</span><br><span class="line">    fn new() -&gt; BookInventory &#123;</span><br><span class="line">        BookInventory &#123;</span><br><span class="line">            inventory: HashMap::new(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn add_book(&amp;mut self, title: String, quantity: i32) &#123;</span><br><span class="line">        *self.inventory.entry(title).or_insert(0) += quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn get_count(&amp;self, title: &amp;str) -&gt; i32 &#123;</span><br><span class="line">        *self.inventory.get(title).unwrap_or(&amp;0)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn update_count(&amp;mut self, title: String, quantity: i32) &#123;</span><br><span class="line">        self.inventory.insert(title, quantity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn delete_book(&amp;mut self, title: &amp;str) &#123;</span><br><span class="line">        self.inventory.remove(title);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn list_books(&amp;self) &#123;</span><br><span class="line">        <span class="keyword">for</span> (title, &amp;quantity) <span class="keyword">in</span> &amp;self.inventory &#123;</span><br><span class="line">            println!(<span class="string">&quot;Title: &#123;&#125;, Quantity: &#123;&#125;&quot;</span>, title, quantity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> mut inventory = BookInventory::new();</span><br><span class="line"></span><br><span class="line">    inventory.add_book(<span class="string">&quot;The Rust Programming Language&quot;</span>.to_string(), 10);</span><br><span class="line">    inventory.add_book(<span class="string">&quot;Programming Rust&quot;</span>.to_string(), 5);</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;Initial inventory:&quot;</span>);</span><br><span class="line">    inventory.list_books();</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;\nStock count for &#x27;The Rust Programming Language&#x27;:&quot;</span>);</span><br><span class="line">    println!(<span class="string">&quot;Count: &#123;&#125;&quot;</span>, inventory.get_count(<span class="string">&quot;The Rust Programming Language&quot;</span>));</span><br><span class="line"></span><br><span class="line">    inventory.update_count(<span class="string">&quot;Programming Rust&quot;</span>.to_string(), 10);</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;\nUpdated inventory:&quot;</span>);</span><br><span class="line">    inventory.list_books();</span><br><span class="line"></span><br><span class="line">    inventory.delete_book(<span class="string">&quot;Programming Rust&quot;</span>);</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;\nFinal inventory:&quot;</span>);</span><br><span class="line">    inventory.list_books();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/24/rust13/" data-id="cm1gj9sqq0000x0uy0izleek2" data-title="rust 学习笔记十三 Rust 中的集合" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust12" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/21/rust12/" class="article-date">
  <time class="dt-published" datetime="2024-09-21T09:29:21.620Z" itemprop="datePublished">2024-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/21/rust12/">rust 学习笔记十三 Rust 中的集合</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Rust中的集合主要分为两类， Vector和HashMap</p>
<h3 id="（一）Vector"><a href="#（一）Vector" class="headerlink" title="（一）Vector"></a>（一）Vector</h3><p>什么是模式匹配:模式匹配是一种强大的功能,可以检查数据的结构并进行相应操作。</p>
<p>为什么使用模式匹配:提高代码的可读性和简洁性,减少错误,尤其是在处理复杂数据结构时。</p>
<p>举例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> number = 13;</span><br><span class="line">    match number &#123;</span><br><span class="line">    1=&gt;println!(<span class="string">&quot;One!&quot;</span>),</span><br><span class="line">    2=&gt;println!(<span class="string">&quot;Two!&quot;</span>),</span><br><span class="line">    3=&gt;println! (<span class="string">&quot;Three!&quot;</span>),</span><br><span class="line">    _=&gt;println!(<span class="string">&quot;Something else!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（二）模式匹配的各种模式"><a href="#（二）模式匹配的各种模式" class="headerlink" title="（二）模式匹配的各种模式"></a>（二）模式匹配的各种模式</h3><p>1.字面量模式</p>
<p>最为常见，上面举的基础例子就是字面量模式，<strong>必须穷举</strong>,列出所有可能性,通常与通配符模式搭配使用</p>
<p>2.变量模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> x= 42;</span><br><span class="line">match x&#123;</span><br><span class="line">    var =&gt; println!(<span class="string">&quot;The value is:&#123;&#125;&quot;</span>,var),</span><br><span class="line">&#125;</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,x);</span><br></pre></td></tr></table></figure>

<p>当变量为i32类型时，可以正常工作，当变量为没实现Copy trait的String类型时,存在报错：</p>
<p><img src="/../assets/img/12-1.jpg" alt="图12-1" title="12-1"></p>
<p>因为发生了所有权的转移</p>
<p>3.通配符模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">match x&#123;</span><br><span class="line">_=&gt; println!(<span class="string">&quot;Any value&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.结构模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    struct Point&#123;x:i32,y:i32&#125;</span><br><span class="line">    <span class="built_in">let</span> p = Point&#123;x:0,y:7&#125;;</span><br><span class="line">    match p &#123;</span><br><span class="line">        Point&#123;x,y:0&#125; =&gt; println!(<span class="string">&quot;On the x axis at &#123;&#125;&quot;</span>,x),</span><br><span class="line">        Point&#123;x:0,y&#125; =&gt; println!(<span class="string">&quot;On the y axis at &#123;&#125;&quot;</span>,y),</span><br><span class="line">        Point&#123;x,y&#125;=&gt;println!(<span class="string">&quot;On neither axis:(&#123;&#125;,&#123;&#125;)&quot;</span>,x,y),</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将会在第一个匹配到的项中输出,其余的元组模式、枚举模式、解构模式都与之类似,需要在匹配项中解构</p>
<p>5.守卫与绑定</p>
<p>a.守卫:在模式匹配中,可以使用守卫来添加额外的条件判断</p>
<p><img src="/../assets/img/12-3.jpg" alt="图12-3" title="12-3"></p>
<p>b.绑定:在模式匹配中,可以使用绑定来将模式中的值绑定到变量上</p>
<p><img src="/../assets/img/12-2.jpg" alt="图12-2" title="12-2"></p>
<p>使用一个@可以规定范围,再举例一个比较复杂的枚举绑定模式：</p>
<p><img src="/../assets/img/12-4.jpg" alt="图12-4" title="12-4"></p>
<h3 id="（三）应用场景"><a href="#（三）应用场景" class="headerlink" title="（三）应用场景"></a>（三）应用场景</h3><p>1.处理错误</p>
<p>原本返回Result的函数写法是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn divide(a:i32,b:i32)-&gt;Result&lt;i32,String&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span> b==0&#123;</span><br><span class="line">        Err(String::from(<span class="string">&quot;Cannotdivide by zero&quot;</span>))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Ok(a/b)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以改为match,更易读：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">match divide(4,2)&#123;</span><br><span class="line">    Ok(result)=&gt; println!(<span class="string">&quot;Result is &#123;&#125;&quot;</span>, result),</span><br><span class="line">    Err(e) =&gt; println!(<span class="string">&quot;Error:&#123;&#125;&quot;</span>,e),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>解析命令行参数</li>
<li>解析配置文件</li>
<li>解析数据包</li>
<li>解析XML或JSON等数据格式</li>
</ol>
<h3 id="（四）高级模式匹配技巧"><a href="#（四）高级模式匹配技巧" class="headerlink" title="（四）高级模式匹配技巧"></a>（四）高级模式匹配技巧</h3><p>1.嵌套模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum Message &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move&#123;x:i32,y:i32&#125;,</span><br><span class="line">    Write(String),</span><br><span class="line">    ChangeColor(i32,i32,i32),</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> msg = Message::ChangeColor(0,160,255);</span><br><span class="line">match msg &#123;</span><br><span class="line">    Message::ChangeColor(r,g,b)=&gt;println!(<span class="string">&quot;Change the color to red &#123;&#125;, green &#123;&#125;,and blue&#123;&#125;&quot;</span>,r,g,b),</span><br><span class="line">    _=&gt;&#123;&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>2.模式匹配与迭代器:结合iter和match使用</p>
<p><img src="/../assets/img/12-5.jpg" alt="图12-5" title="12-5"></p>
<p>可见将vec1和 vec2的对应元素进行了匹配</p>
<p>3.if let 和 while let:</p>
<p>简化单个模式匹配</p>
<p><img src="/../assets/img/12-7.jpg" alt="图12-7" title="12-7"></p>
<p>4.ref 和 mut ref</p>
<p>使用场景：</p>
<p>借用数据而不转移所有权:在某些情况下,你只需要借用数据而不是转移其所有权。例如在递归数据结构中,借用数据可以避免所有权转移带来的复杂性。</p>
<p>对数据进行修改:使用ref mut可以在模式匹配时对数据进行修改,而无需转移所有权。</p>
<p><img src="/../assets/img/12-6.jpg" alt="图12-6" title="12-6"></p>
<p>附加：假设你有一个包含用户信息的JSON字符串:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;nane&quot;</span>:<span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: 30,</span><br><span class="line">    <span class="string">&quot;email&quot;</span>: <span class="string">&quot;alicefexanple.con&quot;</span>,</span><br><span class="line">    <span class="string">&quot;address&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;street&quot;</span>: <span class="string">&quot;123 Main St&quot;</span>,</span><br><span class="line">        <span class="string">&quot;city&quot;</span>:<span class="string">&quot;Wonderland&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;phone_numbers&quot;</span>: [<span class="string">&quot;123-456-7890&quot;</span>, <span class="string">&quot;987-654-3210&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 serde_json库解析JSON字符串, 使用模式匹配提取JSON对象中的不同字段, 处理不同类型的数据(字符串、数字、数组、嵌套对象等):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">use serde_json::&#123;Value, Error&#125;;</span><br><span class="line"></span><br><span class="line">fn main() -&gt; Result&lt;(), Error&gt; &#123;</span><br><span class="line">    // JSON 字符串</span><br><span class="line">    <span class="built_in">let</span> json_str = r#<span class="string">&quot;</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;</span>name<span class="string">&quot;: &quot;</span>Alice<span class="string">&quot;,</span></span><br><span class="line"><span class="string">            &quot;</span>age<span class="string">&quot;: 30,</span></span><br><span class="line"><span class="string">            &quot;</span>email<span class="string">&quot;: &quot;</span>alice@example.com<span class="string">&quot;,</span></span><br><span class="line"><span class="string">            &quot;</span>address<span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">                &quot;</span>street<span class="string">&quot;: &quot;</span>123 Main St<span class="string">&quot;,</span></span><br><span class="line"><span class="string">                &quot;</span>city<span class="string">&quot;: &quot;</span>Wonderland<span class="string">&quot;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            &quot;</span>phone_numbers<span class="string">&quot;: [&quot;</span>123-456-7890<span class="string">&quot;, &quot;</span>987-654-3210<span class="string">&quot;]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &quot;</span>#;</span><br><span class="line"></span><br><span class="line">    // 解析 JSON 字符串</span><br><span class="line">    <span class="built_in">let</span> v: Value = serde_json::from_str(json_str)?;</span><br><span class="line">    println!(<span class="string">&quot;aaaa&#123;:?&#125;&quot;</span>,v);</span><br><span class="line">    // 使用模式匹配提取字段</span><br><span class="line">    match v &#123;</span><br><span class="line">        // 匹配嵌套对象</span><br><span class="line">        Value::Object(m) =&gt; &#123;</span><br><span class="line">            // 提取字符串字段</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">let</span> Some(name) = m.get(<span class="string">&quot;name&quot;</span>).and_then(Value::as_str) &#123;</span><br><span class="line">                println!(<span class="string">&quot;Name: &#123;&#125;&quot;</span>, name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">let</span> Some(email) = m.get(<span class="string">&quot;email&quot;</span>).and_then(Value::as_str) &#123;</span><br><span class="line">                println!(<span class="string">&quot;Email: &#123;&#125;&quot;</span>, email);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 提取数字字段</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">let</span> Some(age) = m.get(<span class="string">&quot;age&quot;</span>).and_then(Value::as_i64) &#123;</span><br><span class="line">                println!(<span class="string">&quot;Age: &#123;&#125;&quot;</span>, age);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 提取嵌套对象</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">let</span> Some(address) = m.get(<span class="string">&quot;address&quot;</span>) &#123;</span><br><span class="line">                match address &#123;</span><br><span class="line">                    Value::Object(addr) =&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">let</span> Some(street) = addr.get(<span class="string">&quot;street&quot;</span>).and_then(Value::as_str) &#123;</span><br><span class="line">                            println!(<span class="string">&quot;Street: &#123;&#125;&quot;</span>, street);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">let</span> Some(city) = addr.get(<span class="string">&quot;city&quot;</span>).and_then(Value::as_str) &#123;</span><br><span class="line">                            println!(<span class="string">&quot;City: &#123;&#125;&quot;</span>, city);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    _ =&gt; println!(<span class="string">&quot;Address is not an object&quot;</span>),</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 提取数组字段</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">let</span> Some(phone_numbers) = m.get(<span class="string">&quot;phone_numbers&quot;</span>) &#123;</span><br><span class="line">                match phone_numbers &#123;</span><br><span class="line">                    Value::Array(nums) =&gt; &#123;</span><br><span class="line">                        println!(<span class="string">&quot;Phone numbers:&quot;</span>);</span><br><span class="line">                        <span class="keyword">for</span> num <span class="keyword">in</span> nums &#123;</span><br><span class="line">                            <span class="keyword">if</span> <span class="built_in">let</span> Some(n) = num.<span class="function"><span class="title">as_str</span></span>() &#123;</span><br><span class="line">                                println!(<span class="string">&quot;  &#123;&#125;&quot;</span>, n);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    _ =&gt; println!(<span class="string">&quot;Phone numbers are not an array&quot;</span>),</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; println!(<span class="string">&quot;JSON is not an object&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
























      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/21/rust12/" data-id="cm1bybu85000020uy38i6b4c5" data-title="rust 学习笔记十三 Rust 中的集合" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust11" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/20/rust11/" class="article-date">
  <time class="dt-published" datetime="2024-09-19T16:20:24.066Z" itemprop="datePublished">2024-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/20/rust11/">rust 学习笔记十一 Rust 中的结构体</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）结构体的定义"><a href="#（一）结构体的定义" class="headerlink" title="（一）结构体的定义"></a>（一）结构体的定义</h3><p>使用struct关键字并为整个结构体提供一个名字，结构体的定义的位置没有要求,实例化的作用域在定义的范围内即可，大括号中,定义每一部分数据的名字和类型,称为字段(field)<br>使用逗号分隔每个字段</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width:u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有以下注意事项：</p>
<p>1、初始化结构体时<strong>每一个字段都必须初始化</strong></p>
<p>2、字段赋值顺序和定义顺序<strong>不需要一致</strong></p>
<p>3、字段名使用逗号分局</p>
<p>4、结构体中变量名和实际变量名一样的时候，可以只写一个</p>
<p>如果两个结构体实例的属性高度重合，也可以选择复用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">let</span> user2 = User&#123;</span><br><span class="line">    email:String::from(<span class="string">&quot;someone2@example.com&quot;</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种方法叫结构体更新语法</p>
<p>RUST的访问：通过实例. 属性名的方式，修改：需要将实例修改为<strong>mut</strong></p>
<h3 id="（二）结构体分类"><a href="#（二）结构体分类" class="headerlink" title="（二）结构体分类"></a>（二）结构体分类</h3><p>1.元组结构体(TupleStruct)</p>
<p>结构体必须要有名称,但是结构体的字段可以没有名称,这种结构体长得很像元组,因此被称为元组结构体，元组结构体<strong>希望有一个整体名称,但是又不关心里面字段的的名称</strong>时将非常有用.</p>
<p>例如Point元组结构体,众所周知3D点是(x,y,z)形式的坐标点,因此我们无需再为内部的字段逐一命名为:x,y,z</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Color(i32,i32,i32);</span><br><span class="line">struct Point(i32,i32,i32);</span><br><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">let</span> black=Color(0,0,0);</span><br><span class="line">    <span class="built_in">let</span> origin=Point(0,0,0);</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,black.0,origin.1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.单元结构体(Unit-like Struct)</p>
<p>如果你定义一个类型,但是<strong>不关心该类型的内容,只关心它的行为</strong>时,就可以使用单元结构体,定义AlwaysEqual,我们使用 struct关键字,接着是我们想要的名称,然后是一个分号<br>实例化不需要花括号或圆括号!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct AlwaysEqual;</span><br><span class="line"><span class="built_in">let</span> subject=AlwaysEqual;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（三）所有权"><a href="#（三）所有权" class="headerlink" title="（三）	所有权"></a>（三）	所有权</h3><p><img src="/../assets/img/11-1.jpg" alt="图11-1" title="11-1"></p>
<p><img src="/../assets/img/11-2.jpg" alt="图11-2" title="11-2"></p>
<p>从上面两个例子可以看出：对struct中的两个不同属性进行赋值有不同结果，active仍然可以正常打印但是email却会报错，这是因为active是bool类型，实现了copy trait，赋值过程并不会发生所有权的移动，但email 却是没有实现copy特性的类型，所以<strong>发生了所有权的转移</strong>.</p>
<p><img src="/../assets/img/11-3.jpg" alt="图11-3" title="11-3"></p>
<p>在这个例子中，当结构体中有一个元素发生了所有权的转移，之后将这个结构体作为参数进行传递时，也会报错，因此可以得出结论：<strong>一旦字结构体中一个字段发生了所有权移动,那么整个结构体就不能再被腻值了</strong>，同样，在前文中提到的结构体实例复用，如果发生了未实现copy trait类型的值的复用，也会发生所有权转移：</p>
<p><img src="/../assets/img/11-4.jpg" alt="图11-4" title="11-4"></p>
<p>如果我们将类型String 替换为 &amp;str,是不是就可以实现赋值了呢，发现有报错提示：需要生命周期参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct User&lt;<span class="string">&#x27;a&gt;&#123;</span></span><br><span class="line"><span class="string">    active:bool,</span></span><br><span class="line"><span class="string">    username: &amp;&#x27;</span>a str,</span><br><span class="line">    email:&amp;<span class="string">&#x27;a str,</span></span><br><span class="line"><span class="string">    sign_in_count: u64,</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>根据提示添加生命周期参数后,可以正常执行</p>
<h3 id="（四）方法"><a href="#（四）方法" class="headerlink" title="（四）	方法"></a>（四）	方法</h3><p>定义方法：使用<strong>fn关键字和名称声明</strong>,可以拥有参数和返回值,同时包含在某处调用该方法时会执行的代码。方法与函数是不同的,因为它们<strong>在结构体的上下文中被定义</strong>,并且它门<strong>第一个参数总是self,它代表调用该方法的结构体实例.</strong></p>
<p>定义方法和enum类似:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#[derive(Debug)]</span></span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line">impl Rectangle &#123;</span><br><span class="line">fn area(&amp;self) -&gt; u32 &#123;</span><br><span class="line">self.width * self.height</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line"><span class="built_in">let</span> rect1=Rectangle&#123;width:30,height:50&#125;;</span><br><span class="line">    println!(<span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">    rect1.area());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时要修改实例的值的话，也可以在方法中使用可变引用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#[derive(Debug)]</span></span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line">impl Rectangle &#123;</span><br><span class="line">    fn area(&amp;self) -&gt; u32 &#123;</span><br><span class="line">        self.width * self.height</span><br><span class="line">    &#125;</span><br><span class="line">    fn setWidth(&amp;mut self, newWidth:u32) &#123;</span><br><span class="line">        self.width = newWidth; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line"><span class="built_in">let</span> mut rect1=Rectangle&#123;width:30,height:50&#125;;</span><br><span class="line">    rect1.setWidth(20);</span><br><span class="line">    println!(<span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">    rect1.area());</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了这种自带实例引用的方法外，还有一种不带实例引用的方法，和enum中的静态方法一样，只能通过结构体名称::方法名的格式来调用：如下：</p>
<p><img src="/../assets/img/11-5.jpg" alt="图11-5" title="11-5"></p>
<h3 id="（五）实现trait"><a href="#（五）实现trait" class="headerlink" title="（五）	实现trait"></a>（五）	实现trait</h3><p>为类型实现特征</p>
<p>如果不同的类型具有相同的行为,那么我们就可以定义一个特征,然后为这些类型实现该特征,定义特征是把一些方法组合在一起,目的是定义一个实现某些目际所必需的行为的集合.</p>
<p>像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">trait Shape&#123;</span><br><span class="line">    fn area(&amp;self) -&gt; f64;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#[derive(Debug)]</span></span><br><span class="line"></span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width:u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct  Circle &#123;</span><br><span class="line">    r: f64</span><br><span class="line">&#125;</span><br><span class="line">impl Shape <span class="keyword">for</span> Rectangle &#123;</span><br><span class="line">    fn area(&amp;self) -&gt; f64 &#123;</span><br><span class="line">        (self.width * self.height) as f64</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Shape <span class="keyword">for</span>  Circle&#123;</span><br><span class="line">    fn area(&amp;self) -&gt; f64 &#123;</span><br><span class="line">        (self.r * self.r * 3.14) as f64</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn print_area(shape: &amp;impl Shape)&#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,shape.area());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> cir1 = Circle&#123;r:1.0&#125;;</span><br><span class="line">    print_area(&amp;cir1);</span><br><span class="line">    <span class="built_in">let</span> rec1 = Rectangle&#123;width:1, height:2&#125;;</span><br><span class="line">    print_area(&amp;rec1);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>类型Circle和 类型 Rectangle 都需要实现求面积的方法，于是写了一个名为Shape的trait，其中的方法area需要在Circle 和 Rectangle分别实现，最后在函数print_area中传入结构体实例的引用，会自动根据类型匹配到对用的方法执行</p>
<h3 id="（六）打印结构体"><a href="#（六）打印结构体" class="headerlink" title="（六）	打印结构体"></a>（六）	打印结构体</h3><p>直接使用如下方式进行打印：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> cir1 = Circle&#123;r:1.0&#125;;</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,cir1);</span><br></pre></td></tr></table></figure>

<p>依然是报错：该类型没有实现display这个trait</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,cir1);</span><br></pre></td></tr></table></figure>

<p>改为这样还是报错：该类型没有实现debug这个trait,解决办法是在相应的结构体定义上方加上<code>#[derive(Debug)]</code>派生</p>
<p>我们也可以不使用派生而是自己实现这些特征：</p>
<p>a.Display:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">impl Display <span class="keyword">for</span> Rectangle &#123;</span><br><span class="line">    fn <span class="built_in">fmt</span>(&amp;self, f: &amp;mut std::<span class="built_in">fmt</span>::Formatter&lt;<span class="string">&#x27;_&gt;) -&gt; std::fmt::Result &#123;</span></span><br><span class="line"><span class="string">        for _ in 0..self.height &#123;</span></span><br><span class="line"><span class="string">            let mut s =  String::new();</span></span><br><span class="line"><span class="string">            for _ in 0..self.width &#123;</span></span><br><span class="line"><span class="string">                s.push(&#x27;</span>#<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            write!(f, &quot;&#123;&#125;\n&quot;, s);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return  Ok(());</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>b.Debug:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">impl  Debug <span class="keyword">for</span> Circle &#123;</span><br><span class="line">    fn <span class="built_in">fmt</span>(&amp;self, f: &amp;mut std::<span class="built_in">fmt</span>::Formatter&lt;<span class="string">&#x27;_&gt;) -&gt; std::fmt::Result &#123;</span></span><br><span class="line"><span class="string">        let _ = f.debug_struct(&quot;Circle&quot;)</span></span><br><span class="line"><span class="string">        .field(&quot;r&quot;, &amp;self.r)</span></span><br><span class="line"><span class="string">        .finish();</span></span><br><span class="line"><span class="string">        return  Ok(());</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>










      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/20/rust11/" data-id="cm19i4pqj0000louya52f0m2m" data-title="rust 学习笔记十一 Rust 中的结构体" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust10" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/15/rust10/" class="article-date">
  <time class="dt-published" datetime="2024-09-15T14:24:06.288Z" itemprop="datePublished">2024-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/15/rust10/">rust 学习笔记十 Rust 中的ENUM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）概览"><a href="#（一）概览" class="headerlink" title="（一）概览"></a>（一）概览</h3><p>rust中创建字符串主要有以下两种方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    enum Pets&#123;</span><br><span class="line">        Bird,</span><br><span class="line">        Cat(String),</span><br><span class="line">        Dog&#123; name:String, age:usize&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">let</span> bird= Pets::Bird;</span><br><span class="line">    <span class="built_in">let</span> <span class="built_in">cat</span> = Pets::Cat(<span class="string">&quot;jack&quot;</span>.to_string());</span><br><span class="line">    <span class="built_in">let</span> dog = Pets::Dog &#123; name: <span class="string">&quot;tom&quot;</span>.to_string(), age: 18 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Enum中的元素可以没有任何参数，可以是带有一个参数的变体，也可以是有多个name声明的结构体</p>
<p>如果直接对初始化出来的元素进行打印：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println!(<span class="string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,bird, <span class="built_in">cat</span>, dog);</span><br></pre></td></tr></table></figure>

<p>会发现报错：没有实现debug trait，此时我们可以通过在代码上方直接添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[derive(Debug)]</span></span><br></pre></td></tr></table></figure>

<p>这样相当于在枚举中自动补全了debug trait.</p>
<p>可以为枚举实现一些方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">impl Pets &#123;</span><br><span class="line">    fn speak(&amp;self) &#123;</span><br><span class="line">        println!(<span class="string">&quot;speak&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的speak就叫做<strong>methods（方法）</strong>,其中第一个参数&amp;self是<strong>对当前这个枚举实例的引用</strong>, 然后枚举中的元素的实例可以调用这个方法：<code>dog.speak();</code></p>
<p>此外还有一种关联函数，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">impl Pets &#123;</span><br><span class="line">    fn <span class="function"><span class="title">log</span></span>() &#123;</span><br><span class="line">        println!(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这类函数参数中将不会再有枚举实例的引用，调用方法也和methods有区别，不再是通过枚举中元素的，而是直接通过<strong>枚举名称::静态方法</strong>名来调用：<code> Pets::log();</code></p>
<h3 id="二-用法"><a href="#二-用法" class="headerlink" title="(二) 用法"></a>(二) 用法</h3><p>1，比较</p>
<p>先看下面这个例子：</p>
<p><img src="/../assets/img/10-1.jpg" alt="图10-1" title="10-1"></p>
<p>bird 和 cat 是同一个枚举 Pets 的不同变体的实例，如果直接将这两个实例进行对比，会报错：<code>binary operation `==` cannot be applied to type `Pets</code>,在rust中，是不支持直接用等号来比较两个变体实例的，根据提示，<br><code>an implementation of `PartialEq` might be missing for `Pets`,consider annotating `Pets` with `#[derive(PartialEq)]`: </code>, 和刚才一样，在最前面添加一个<code>#[derive(PartialEq)]</code>进行补全，即可使用等号比较.</p>
<ol start="2">
<li>Match vs if let</li>
</ol>
<p>对于创建出来的变体实例，可以通过match判断其类型</p>
<p>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">match <span class="built_in">cat</span> &#123;</span><br><span class="line">    Pets::Cat(e) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Pets::Dog&#123;name, age&#125; =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Pets::Bird =&gt; todo!(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在匹配到对应类型时，可以直接访问其中的变量</p>
<p>同时match也适用于rust中的普通变量，比如可以用来匹配i32常数:</p>
<p><img src="/../assets/img/10-2.jpg" alt="图10-2" title="10-2"></p>
<p>但此时发现有报错：因为match要求列举完可能的所有情况，但我们无法将i32的所有可能值全部列举，所以可以在下面再加一种可能：</p>
<p>用<strong>下划线</strong>代替其余的所有可能</p>
<p><img src="/../assets/img/10-3.jpg" alt="图10-3" title="10-3"></p>
<p>而如果觉得每次都进行模糊匹配有点复杂，可以选择使用if let，便可以只关注需要匹配的类型：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">let</span> <span class="built_in">cat</span> = Pets::Cat &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是if let无法像match一样获取到匹配的参数.</p>
<h3 id="三-rust中的两大枚举"><a href="#三-rust中的两大枚举" class="headerlink" title="(三) rust中的两大枚举"></a>(三) rust中的两大枚举</h3><ol>
<li>Option</li>
</ol>
<p>示例如下：</p>
<p><img src="/../assets/img/10-4.jpg" alt="图10-4" title="10-4"></p>
<p>被分为<strong>some和none</strong>两种情况</p>
<p>如果存在一个map,如下:</p>
<p><img src="/../assets/img/10-5.jpg" alt="图10-5" title="10-5"></p>
<p>通过get获取其中的某个key,此时获得的是一个<strong>option</strong>类型的元素,我们将其进行match匹配:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">match a &#123;</span><br><span class="line">    Some(val)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    None =&gt;&#123; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，对于一个动态数组，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = vec![1,2,3,4];</span><br><span class="line"><span class="built_in">let</span> a = arr.iter().last();</span><br></pre></td></tr></table></figure>

<p>我们取出它的最后一个元素，根据提示，也是option类型，故也可以用match进行匹配</p>
<ol start="2">
<li>Result</li>
</ol>
<p>先看示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> num:Result&lt;usize, ()&gt; = Ok(1);</span><br><span class="line">match num &#123;</span><br><span class="line">    Ok(val)=&gt;&#123;&#125;,</span><br><span class="line">    Err(_)=&gt;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果同样使用match进行匹配，只不过其中的匹配项变成了<strong>Ok()和 Err()</strong></p>
<p>在Rust当中，可以声明函数的返回值为Result类型,比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() -&gt; Result&lt;(), ()&gt;&#123;</span><br><span class="line">    <span class="built_in">let</span> num: Result&lt;usize, ()&gt; = Ok(1);</span><br><span class="line">    match num &#123;</span><br><span class="line">        Ok(val)=&gt;&#123;&#125;</span><br><span class="line">        Err(_)=&gt;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而将&amp;str类型进行反序列化的parse函数返回值也是Result类型</p>
<ol start="3">
<li>Option  和  Result 的相互转换</li>
</ol>
<p>a.Option转result:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> opt = Some(42);</span><br><span class="line"><span class="built_in">let</span> result:Result&lt;i32, &amp;str&gt; = opt.ok_or(<span class="string">&quot;err&quot;</span>);</span><br><span class="line">assert_eq!(result, Ok(42));</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> none:Option&lt;i32&gt; = None;</span><br><span class="line"><span class="built_in">let</span> result:Result&lt;i32, &amp;str&gt; = none.ok_or(<span class="string">&quot;err&quot;</span>);</span><br><span class="line">assert_eq!(result, Err(<span class="string">&quot;err&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>其中第一个result走的是ok，所以得到的是Ok(42),第二个和or相匹配，得到的是Err(“err”)</p>
<p>b.Result转option</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> res:Result&lt;i32, &amp;str&gt; = Ok(1);</span><br><span class="line"><span class="built_in">let</span> option = res.ok();</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> res:Result&lt;i32, &amp;str&gt; = Err(<span class="string">&quot;err&quot;</span>);</span><br><span class="line"><span class="built_in">let</span> option = res.ok();</span><br></pre></td></tr></table></figure>

<p>如果是第二种情况，会转换成None,正常情况则是Some</p>
<p>4.常见api</p>
<p>a.可以通过map来遍历option:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> option = Some(1);</span><br><span class="line"><span class="built_in">let</span> b = option.map(|num| num + 1);</span><br></pre></td></tr></table></figure>

<p>b.如果需要多层match层层嵌套，会导致代码繁琐，易读性不高，所以有语法糖，可以直接取出值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> option = Some(1);</span><br><span class="line"><span class="built_in">let</span> a= option.unwrap();</span><br></pre></td></tr></table></figure>

<p>但如果值是None,会panic，也可以使用expect:<code>let a = option.expect(“msg”);</code>可以传入默认值</p>
<p>c.or_else</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> option = Some(1);</span><br><span class="line"><span class="built_in">let</span> a = option.or_else(|| Some((<span class="number">3</span>)));</span><br></pre></td></tr></table></figure>

<p>返回值也是一个Some，用于优雅的处理可能为None的值，给一个默认值</p>
<p>d.mem::size_of::<T>() </p>
<p>mem::size_of::<T>() 函数返回类型 T 在当前平台上的内存大小（以字节为单位）</p>
<p>示例如下：</p>
<p><img src="/../assets/img/10-6.jpg" alt="图10-6" title="10-6"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/15/rust10/" data-id="cm13ta5d30000xsuy91ri6psf" data-title="rust 学习笔记十 Rust 中的ENUM" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust9" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/13/rust9/" class="article-date">
  <time class="dt-published" datetime="2024-09-13T14:48:45.404Z" itemprop="datePublished">2024-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/13/rust9/">rust 学习笔记九 Rust 中的字符串</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）创建字符串的方式"><a href="#（一）创建字符串的方式" class="headerlink" title="（一）	创建字符串的方式"></a>（一）	创建字符串的方式</h3><p>rust中创建字符串主要有以下两种方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> s = String::from(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> s = <span class="string">&quot;hello world2&quot;</span>;</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br></pre></td></tr></table></figure>

<p>其中，第二种直接引号创建的方式，叫<strong>字符串字面值</strong>,我们在编译时就知道其内容,最终字面值文本被直接硬编码进可执行文件，字符串字面量”hello world”就是<strong>str类型</strong>,它被硬编码进可执行程序的数据部分</p>
<p>既然我们已经存储了这个字符串,就需要一种方法来访问它:这就是<strong>切片引用</strong>&amp;str的意义所在，&amp;str是一种<strong>不可变引用</strong>,所以它没有所有权，str类型是硬编码进可执行文件,也<strong>无法被修改</strong>.</p>
<p>但如果我们需要对这种数据进行修改的时候，就需要用到第一种创建方法，String在rust中是一个复合数据类型,存储在<strong>堆上</strong>,定义如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pub struct String&#123;</span><br><span class="line">vec: Vec&lt;u8&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>意味string可改变的、并且<strong>拥有所有权</strong>的</p>
<p>总结一下二者区别:</p>
<p><strong>&amp;str</strong>:这是一个字符串切片,它是固定大小的,并且不能改变</p>
<p><strong>&amp;string</strong>:这是一个可增长的、可改变的、拥有所有权的、UTF-8编码的字符串类型。它通常用于需要改变或者增长字符串的情况</p>
<h3 id="（二）类型转换"><a href="#（二）类型转换" class="headerlink" title="（二）	类型转换"></a>（二）	类型转换</h3><p><img src="/../assets/img/9-1.jpg" alt="图9-1" title="9-1"></p>
<p>这其中发生了从u8数组到str的转换，但将数组的定义改为vec定义也可以：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> b = vec!(104, 101, 108, 108, 111);</span><br></pre></td></tr></table></figure>

<p>这是因为vector对其进行了隐式的类型转换，同样，也可以进行从str到utf8数组的转换</p>
<p><img src="/../assets/img/9-2.jpg" alt="图9-2" title="9-2"></p>
<p>如果需要进行str 和 string的相互转换：</p>
<p>从String类型转变为&amp;str是非常便捷的,而且<strong>无损的</strong>(性能无损,不会造成重写malloc或者数据移动),另外,由于Rust实现了自动解引用,那么&amp;String在必要的时候可以自动转换为&amp;str,因此在很多函数中,如果接收参数是字符串的引用,通常会采用&amp;str作为入参,以获取更好的数据兼容性<br>,字符串是UTF-8编码,因此需要保证索引的字节刚好落在<strong>字符的边界</strong></p>
<p><img src="/../assets/img/9-3.jpg" alt="图9-3" title="9-3"></p>
<p>如果需要从&amp;str转为string则需要用 String::from进行包裹：</p>
<p><img src="/../assets/img/9-4.jpg" alt="图9-4" title="9-4"></p>
<p>但是这样做对内存消耗较大，因为&amp;str类型的数据是被硬编码在可执行文件中的，但是转换为string类型需要<strong>重新到堆上申请内存</strong></p>
<h3 id="（三）常见修改String的方法"><a href="#（三）常见修改String的方法" class="headerlink" title="（三）	常见修改String的方法"></a>（三）	常见修改String的方法</h3><ol>
<li>追加</li>
</ol>
<p>a.使用<strong>push()<strong>方法追加字符char<br>b.使用</strong>push_str()<strong>方法追加字符串字面量<br>两个方法都是在原有的字符串上追加,并</strong>不会返回新的字符串</strong><br>字符串追加操作要修改原来的字符串,则该字符串必须是可变的,即字符串变量必须由<strong>mut</strong>关键字修饰</p>
<p><img src="/../assets/img/9-5.jpg" alt="图9-5" title="9-5"></p>
<ol start="2">
<li>插入</li>
</ol>
<p>a.使用<strong>insert()<strong>方法插入单个字符char<br>b.使用</strong>insert_str()<strong>方法插入字符串字面量<br>这俩方法需要传入两个参数,第一个参数是字符(串)插入位置的索引,索引从0开始计数;第二个参数是要插入的字符<br>如果越界则会发生错误<br>如果参数所给的位置不是</strong>合法的字符边界</strong>,也会发生错误<br>由于字符串插入操作要修改原来的字符串,则该字符串必须是可变的,即字符串变量必须由<strong>mut</strong>关键字修饰</p>
<p><img src="/../assets/img/9-6.jpg" alt="图9-6" title="9-6"></p>
<ol start="3">
<li>替换</li>
</ol>
<p>a. <strong>replace()<strong>方法接收两个参数,第一个参数是要被替换的字符串,第二个参数是新的字符串<br>该方法会替换所有匹配到的字符串<br>该方法是返回一个新的字符串,而不是操作原来的字符串,故不会修改原字符串，</strong>不需要mut修饰</strong></p>
<p><img src="/../assets/img/9-7.jpg" alt="图9-7" title="9-7"></p>
<p>b. <strong>replace_range()<strong>接收两个参数,第一个参数是要替换字符串的范围(Range),第二个参数是新的字符串<br>该方法是直接操作原来的字符串,不会返回新的字符串。该方去需要使用</strong>mut</strong>关键字修饰<br>如果range的范围大于&#x2F;小于新字符串的长度会因为不在<strong>合法边界</strong>而报错</p>
<p><img src="/../assets/img/9-8.jpg" alt="图9-8" title="9-8"></p>
<p>4.删除</p>
<p>a.pop<br><strong>删除并返回</strong>字符串的最后一个字符<br>其返回值是一个<strong>Option类型</strong>,如果字符串为空,则返回<br>该方法是直接操作原来的字符串</p>
<p><img src="/../assets/img/9-9.jpg" alt="图9-9" title="9-9"></p>
<p>b.remove<br>该方法是直接操作原来的字符串<br>其返回值是<strong>删除位置的字符串</strong><br>只接收一个参数,表示该字符<strong>起始索引位置</strong><br>方法是按照字节来处理字符串的,如果参数所给的位置不是<strong>合法的的字符边界</strong>,则会发生错误</p>
<p><img src="/../assets/img/9-10.jpg" alt="图9-10" title="9-10"></p>
<p>c.truncat<br>删除字符串中<strong>从指定位置开始到结尾的全部字符</strong><br>方法是按照字节来处理字符串的,如果参数所给的位置不是<strong>合法的字符边界</strong>,则会发生错误<br>该方法是直接操作原来的字符串</p>
<p><img src="/../assets/img/9-11.jpg" alt="图9-11" title="9-11"></p>
<p>d.clear<br>清空字符串<br>该方法是直接操作原来的字符串</p>
<p><img src="/../assets/img/9-12.jpg" alt="图9-12" title="9-12"></p>
<p>5.连接</p>
<p>a.使用+或者+&#x3D;连接字符串<br>这里add()方法的第二个参数必须为字符串的<strong>切片引用类型</strong><br>是返回一个新的字符串,所以变量声明可以<strong>不需要mut关键字修饰</strong></p>
<p><img src="/../assets/img/9-13.jpg" alt="图9-13" title="9-13"></p>
<p>b.使用format!连接字符串<br>format!的用法与 print!的用法类似</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/13/rust9/" data-id="cm10u4a4g0000e4uy9nle6pel" data-title="rust 学习笔记九 Rust 中的字符串" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust8" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/12/rust8/" class="article-date">
  <time class="dt-published" datetime="2024-09-11T16:29:39.235Z" itemprop="datePublished">2024-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/12/rust8/">rust 学习笔记八 Rust 中的数组与切片</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>类型[T;N]表示N个值的数组,每个值的类型为T。数组的大小是<strong>在编译期就已确定的常量</strong>,并且是类型的一部分,不能追加新元素或缩小数组。类型&amp;[T]和&amp;mut[T]可称为T的<strong>共享切片</strong>和T的<strong>可变切片</strong>,它们是对一系列元素的引用,这些元素是某个其他值(比如数组或向量)的一部分。可以将切片视为<strong>指向其第一个元素的指针</strong>,以及从该点开始允许访问的元素数量的计数。可变切片&amp;mut[T]<strong>允许读取元素和修改元素,但不能共享</strong>;共享切片&amp;[T]允许<strong>在多个读取者之间共享访问权限,但不允许修改元素</strong>。</p>
<p>rust会检查类型中任意一种类型的值v,表达式v.len()都会给出v中的元素数,而v[i]引用的是V的第 i 个元素， 第一个元素是v[0],最后一个元素是v[v.len()-1]。Rust总是会检查i是否在这个范围内,如果没在,则此表达式会出现panic（），长度可能为0,在这种情况下,任何对其进行索引的尝试都会出现panic。i的类型必须是<strong>usize</strong>,不能使用任何其他整型作为索引。</p>
<h3 id="（一）数组"><a href="#（一）数组" class="headerlink" title="（一）	数组"></a>（一）	数组</h3><p>数组有以下特征：</p>
<p>1.数组的定义其实就是为分配一段<strong>连续的相同数据类型的内存块</strong></p>
<p>2.数组是<strong>静态</strong>的。这意味着一旦定义和初始化,则永远不可更改它的长度</p>
<p>3.数组的元素有着<strong>相同</strong>的数据类型,每一个元素都独占者数据类型大小的内存块。也就是说。数组的内存大小等于数组的长度乘以数组的数据类型</p>
<p>4.数组中的每一个元素都按照顺序依次存储,这个顺序号既代表着元素的存储位置,也是数组元素的唯一标识。我们把这个标识称之为数组下标</p>
<p>5.填充数组中的每一个元素的过程称为数组初始化。也就是说数组初始化就是为数组中的每一个元素赋值</p>
<p>6.可以更新或修改数组元素的值,但<strong>不能删除数组元素</strong>。如果要删除功能,你可以将它的值赋值为0或其它表示删除的值</p>
<p>介绍几种初始化数组的方法：</p>
<p>1.首先是最标准的格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr:[i32;4] = [10,11,12,13];</span><br></pre></td></tr></table></figure>
<p>在数组名称后面添加<code>[类型；个数]</code>的声明</p>
<p>2.或者也可以不声明，rust会自行推导</p>
<p>3.如果数组中每个元素的类型和值都一样的话，可以不用挨个列出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr= [10;4];</span><br></pre></td></tr></table></figure>

<p>如果需要获取数组的长度，通常通过调用函数len():<code>arr.len();</code></p>
<p>数组的遍历：</p>
<p>1.可通过之前说过的for循环结合序列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> 0..4&#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,arr[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2:可通过rust的迭代器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> arr.<span class="function"><span class="title">iter</span></span>()&#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  也可以这样写，更精简：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.iter().for_each(|value| println!(<span class="string">&quot;&#123;&#125;&quot;</span>,value));</span><br></pre></td></tr></table></figure>

<p>如果需要修改一个数组中的元素，直接像下面这样：<code>arr[0] = 1;</code>是会报错的，因为这是个<strong>不可变数组</strong>需要修改的话需要将数组声明为mut</p>
<p>在看下面这个例子：</p>
<p><img src="/../assets/img/8-1.jpg" alt="图8-1" title="8-1"></p>
<p>可以发现在函数内打印的数组已经被修改了，但是并没有在函数作用域外起作用，这样的操作叫<strong>值传递</strong>,如果需要在函数中修改数组中的值，需要使用<strong>引用传递</strong>：</p>
<p><img src="/../assets/img/8-2.jpg" alt="图8-2" title="8-2"></p>
<h3 id="（二）切片"><a href="#（二）切片" class="headerlink" title="（二）	切片"></a>（二）	切片</h3><p>Slice类型通常翻译为切片,它表示从某个包含多个元素的容器中取得局部数据,这个过程称为切片操作。不同语言对切片的支持有所不同,比如有些语言只允许取得连续的局部元素,而有些语言可以取得离散元素,甚至有些语言可以对hash结构进行切片操作</p>
<p>Rust也支持Slice操作,Rust中的切片操作只允许获取一段连续的局部数据,切片操作获取到的数据称为切片数据</p>
<p>Rust常见的数据类型中,有三种类型已支持Slice操作:String类型、Array类型和Vec类型</p>
<p>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = [10,20,30,40,50,60];</span><br><span class="line"><span class="built_in">let</span> slice = &amp;a[1..3];</span><br><span class="line">println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,slice);</span><br></pre></td></tr></table></figure>

<p>切片常用函数如下:</p>
<p><img src="/../assets/img/8-3.jpg" alt="图8-3" title="8-3"></p>
<p>此处不挨个举例，简单举例几个比较特殊的函数</p>
<p>1.windows</p>
<p><img src="/../assets/img/8-4.jpg" alt="图8-4" title="8-4"></p>
<p>2 start_with</p>
<p><img src="/../assets/img/8-5.jpg" alt="图8-5" title="8-5"></p>
<hr>
<p>思考：给定一个整数数组nums,返回一个数组answer,使得answer[i]等于nums除之外nums[i]的所有元素的乘积:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> a = [1,-1,1,1];</span><br><span class="line">    <span class="built_in">let</span> b:Vec&lt;i32&gt; = complete(&amp;a);</span><br><span class="line">    println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn complete(arr: &amp;[i32]) -&gt; Vec&lt;i32&gt;&#123;</span><br><span class="line">    <span class="built_in">let</span> length = arr.len();</span><br><span class="line">    <span class="built_in">let</span> mut result = vec![1; length];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">let</span> mut left_product = 1;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> 0..length &#123;</span><br><span class="line">        result[i] *= left_product;</span><br><span class="line">        left_product *= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">let</span> mut right_product = 1;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (0..length).<span class="function"><span class="title">rev</span></span>() &#123;</span><br><span class="line">        result[i] *= right_product;</span><br><span class="line">        right_product *= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/12/rust8/" data-id="cm0y2xqu70000eguy8ziae905" data-title="rust 学习笔记八 Rust 中的数组与切片" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust7" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/10/rust7/" class="article-date">
  <time class="dt-published" datetime="2024-09-09T17:51:03.438Z" itemprop="datePublished">2024-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/10/rust7/">rust 学习笔记七 Rust 中的引用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）在rust中，引用分为可变引用和不可变引用"><a href="#（一）在rust中，引用分为可变引用和不可变引用" class="headerlink" title="（一）在rust中，引用分为可变引用和不可变引用"></a>（一）在rust中，引用分为可变引用和不可变引用</h3><p>·不可变引用(Immutable Reference):通过不可变引用,可以读取数据,但不能修改数据。一个变量可以有多个不可变引用,但不能与可变引用共存</p>
<p>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> s1 = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">let</span> s2 = &amp;s1;</span><br><span class="line"><span class="built_in">let</span> s3 = &amp;s1;</span><br></pre></td></tr></table></figure>

<p>可变引用(Mutable Reference):通过可变引用,可以读取和修改数据。一个变量在某一时刻只能有一个可变引用,且不能与不可变引用共存</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> mut s1 = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">let</span> s2 = &amp;mut s1;</span><br></pre></td></tr></table></figure>

<p>综上，同一时间内一个变量只能<strong>有一个可变引用或者多个不可变引用，且必须总是有效</strong></p>
<p>但是在以下情况下，是可以正常执行的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> mut s1 = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">let</span> s2 = &amp;s1;</span><br><span class="line"><span class="built_in">let</span> s3 = &amp;s1;</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>,s2, s3);</span><br><span class="line"><span class="built_in">let</span> s4 = &amp; mut s1;</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s4);</span><br></pre></td></tr></table></figure>

<p>但是在这种情况下，是可以正常执行的，因为可以把2~4行中对于s1的引用视作一个单独的作用域，而在打印结束之后不会有关于引用的使用，所以可以视作对s1的不可变引用已经结束了，所以不会影响后面继续对s1创建可变引用</p>
<h3 id="（二）关于引用的一些概念"><a href="#（二）关于引用的一些概念" class="headerlink" title="（二）关于引用的一些概念"></a>（二）关于引用的一些概念</h3><ol>
<li><p>Move</p>
<p> 主要描述堆数据所有权的转移</p>
</li>
<li><p>borrowing</p>
<p> 在向函数传入参的时候，函数对于变量所有权的借用</p>
</li>
<li><p>referenceing</p>
<p> 包含了borrowing 以及 字符串和数组的切片（对堆上某一段数据的引用）</p>
</li>
</ol>
<h3 id="（三）生命周期"><a href="#（三）生命周期" class="headerlink" title="（三）生命周期"></a>（三）生命周期</h3><p>生命周期是Rust用来保证引用有效性的机制。生命周期注解允许编译器推断引用的有效范围,确保在引用仍然有效时使用它们</p>
<p>先看下面的示例：</p>
<p><img src="/../assets/img/7-1.jpg" alt="图7-1" title="7-1"></p>
<p>直接这样写会报错，提示是不能返回一个对于函数中临时值的引用，前文所有权中见过，作用域结束时会自动调用drop，在其他地方调用会导致<strong>悬垂指针</strong>的问题</p>
<p>在rust中，解决办法是：</p>
<p><img src="/../assets/img/7-2.jpg" alt="图7-2" title="7-2"></p>
<p>在外面创建一个空变量，将其可变引用传入函数进行修改，然后返回</p>
<p>或者：</p>
<p><img src="/../assets/img/7-3.jpg" alt="图7-3" title="7-3"></p>
<p>但如果向下面这样传入引用修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = getLongest(&amp;<span class="string">&quot;a&quot;</span>.to_owned(), &amp;<span class="string">&quot;b&quot;</span>.to_owned());</span><br><span class="line">fn getLongest(a: &amp;String,b :&amp;String) -&gt; &amp;String&#123;</span><br><span class="line">    <span class="keyword">if</span> a.len() &gt; b.<span class="function"><span class="title">len</span></span>()&#123;</span><br><span class="line">        a</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>!(<span class="string">&quot;&#123;&#125;&quot;</span>,a);</span><br></pre></td></tr></table></figure>

<p>会报错：<strong>缺少生命周期</strong></p>
<p>此时我们需要根据提示标记一下声明周期’a，（具体原因后面描述），像下面这样，即可通过编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> s1 = <span class="string">&quot;a&quot;</span>.to_owned();</span><br><span class="line"><span class="built_in">let</span> s2 = <span class="string">&quot;b&quot;</span>.to_owned();</span><br><span class="line"><span class="built_in">let</span> a = getLongest(&amp;s1, &amp;s2);</span><br><span class="line">fn getLongest&lt;<span class="string">&#x27;a&gt;(a: &amp;&#x27;</span>a String,b :&amp;<span class="string">&#x27;a String) -&gt; &amp;&#x27;</span>a String&#123;</span><br><span class="line">    <span class="keyword">if</span> a.len() &gt; b.<span class="function"><span class="title">len</span></span>()&#123;</span><br><span class="line">        a</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>!(<span class="string">&quot;&#123;&#125;&quot;</span>,a);</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/10/rust7/" data-id="cm0vaxrzs0000pkuyc2837ljl" data-title="rust 学习笔记七 Rust 中的引用" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust6" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/08/rust6/" class="article-date">
  <time class="dt-published" datetime="2024-09-08T10:20:29.774Z" itemprop="datePublished">2024-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/08/rust6/">rust 学习笔记六 Rust中的所有权</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Rust是一种系统编程语言,其设计目的是确保内存安全并限防止数据竞争,而不依赖垃圾回收器。这种内存安全性主要通过<strong>所有权系统</strong>来实现</p>
<p>先看看主流编程语言的内存回收机制对比 :</p>
<p><img src="/../assets/img/6-1.png" alt="图6-1" title="6-1"></p>
<p>而在rust中，内存管理是通过<strong>所有权系统</strong>完成的</p>
<h3 id="一-有以下特点："><a href="#一-有以下特点：" class="headerlink" title="(一)有以下特点："></a>(一)有以下特点：</h3><p>1.Rust使用所有权系统进行内存管理,编译器在编译时通过静态态分析来确保内存安全</p>
<p>2.每个值<strong>都有一个所有者,在任何时候只能有一个有效的所有者</strong></p>
<p>3.通过 <strong>借用(引用)</strong> 机制来共享数据,同时保证数据竞争和悬垂指针的安全</p>
<p>4.当所有者离开作用域(scope),值会被丢弃(drop)</p>
<h3 id="二-为什么要有所有权："><a href="#二-为什么要有所有权：" class="headerlink" title="(二)为什么要有所有权："></a>(二)为什么要有所有权：</h3><p>举例说明：</p>
<p>对于分布在栈上的数据，如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> x = 5;</span><br><span class="line"><span class="built_in">let</span> y = x;</span><br></pre></td></tr></table></figure>

<p>这种情况下，是将原来的值进行了一个拷贝，而没有改变原来数据的所有权</p>
<p>而对于分布在堆上的数据，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> s1 = String::from(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="built_in">let</span> s2 = s1;</span><br></pre></td></tr></table></figure>

<p>实则是改变了数据的所有权到s2上，此时直接使用s1，会报错</p>
<p>故所有权可以<strong>确保程序在运行时不会访问无效的内存，避免了数据竞争和内存泄漏</strong></p>
<p>对于以下情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">let</span> s1 = String::from(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="built_in">let</span> s2 = s1;</span><br><span class="line">&#125;</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s2);</span><br></pre></td></tr></table></figure>

<p>也是不能正常访问的，因为在编译过程中，在scope结束时，会自动添加类似drop(s2)的代码，作用域一结束，s2就失效了</p>
<h3 id="三-实践一下"><a href="#三-实践一下" class="headerlink" title="(三)实践一下"></a>(三)实践一下</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> s1 = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">let</span> s2 = take_ownership(s1) ;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s1);</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s2);</span><br><span class="line">&#125;</span><br><span class="line">fn take_ownership(s:String) -&gt; String&#123;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接执行这段代码会报错。因为<code>ake_ownership</code> 函数获取了 s1 的所有权，因此 s1 不再有效，</p>
<p>如果需要保持s1所有权不变的前提下，将其值传入函数可以将s1进行<strong>克隆</strong>，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> s1 = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">let</span> s2 = take_ownership(s1.clone()) ;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s1);</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s2);</span><br><span class="line">&#125;</span><br><span class="line">fn take_ownership(s:String) -&gt; String&#123;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者传入s1的<strong>不可变引用</strong>到函数中，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> s1 = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">let</span> s2 = take_ownership(&amp;s1) ;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s1);</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s2);</span><br><span class="line">&#125;</span><br><span class="line">fn take_ownership(s:&amp;String) -&gt; String&#123;</span><br><span class="line">    <span class="built_in">return</span>  s.to_string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述两种方法中，更推荐使用第二种方法，因为第一种方法在参数体积比较大的时候，对参数进行clone，可能会导致对内存的占用和对性能的消耗</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/08/rust6/" data-id="cm0tfotgz00007cuyaj06gdu9" data-title="rust 学习笔记六 Rust中的所有权" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/11/09/rust25/">rust 学习笔记二十五 Rust中的共享内存</a>
          </li>
        
          <li>
            <a href="/2024/11/03/rust24/">rust 学习笔记二十四 Rust的并发</a>
          </li>
        
          <li>
            <a href="/2024/10/31/rust23/">rust 学习笔记二十三 Rust测试</a>
          </li>
        
          <li>
            <a href="/2024/10/29/rust22/">rust 学习笔记二十二 Rust中的迭代器&amp;关联类型</a>
          </li>
        
          <li>
            <a href="/2024/10/27/rust21/">rust 学习笔记二十一 Rust中的闭包</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Liu Canzhu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>