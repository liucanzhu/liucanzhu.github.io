<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>canzhu&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="canzhu&#39;s blog">
<meta property="og:url" content="https://liucanzhu.github.io/page/2/index.html">
<meta property="og:site_name" content="canzhu&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liu Canzhu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="canzhu's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">canzhu&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://liucanzhu.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-rust18" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/15/rust18/" class="article-date">
  <time class="dt-published" datetime="2024-10-15T13:45:07.177Z" itemprop="datePublished">2024-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/15/rust18/">rust 学习笔记十八 Rust中的生命周期</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>生命周期在rust中用于<strong>内存安全，帮助编译器处理悬垂指针的问题</strong></p>
<h3 id="（一）创建"><a href="#（一）创建" class="headerlink" title="（一）	创建"></a>（一）	创建</h3><p>在Rust中,生命周期主要通过生命周期注解来创建和使用。生命周期注解是一种显式声明引用有效时间的方式,通常用’a、’b这样的符号表示。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;</span><br><span class="line">    if x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        У</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中,longest函数接受两个字符串切片参数,并过返回其中一个更长的字符串切片。’a生命周期注解表明<strong>返回的生命周期与输入参数的生命周期相同</strong></p>
<h3 id="（二）分类"><a href="#（二）分类" class="headerlink" title="（二）	分类"></a>（二）	分类</h3><h4 id="1-fn"><a href="#1-fn" class="headerlink" title="1.fn:"></a>1.fn:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn example&lt;&#x27;a&gt;(input: &amp;&#x27;a str)-&gt; &amp;&#x27;a str&#123;</span><br><span class="line">    input</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-struct"><a href="#2-struct" class="headerlink" title="2.struct"></a>2.struct</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct: struct Example&lt;&#x27;a&gt; &#123;</span><br><span class="line">    part: &amp;&#x27;a str,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-enum"><a href="#3-enum" class="headerlink" title="3.enum"></a>3.enum</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum: enum StringOption&lt;&#x27;a&gt; &#123;</span><br><span class="line">    Some(&amp;&#x27;a str),</span><br><span class="line">    None</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（三）使用场景"><a href="#（三）使用场景" class="headerlink" title="（三）	使用场景"></a>（三）	使用场景</h3><p>在rust开发中，什么时候需要显式的添加生命周期呢，理论上，当牵涉到值的引用传递时，我们都需要声明生命周期，因为其他类型的数据，rust能检测到数据的存活周期，能自动识别什么时候应该释放这些数据<br>但也不是所有包含了引用值传递的情况修需要声明生命周期：</p>
<p>看下面这个例子：</p>
<p><img src="/../assets/img/18-1.jpg" alt="图18-1" title="18-1"></p>
<p>在这种情况下，没有声明，但是也没有任何报错,实际上，在上面代码编译过程中，rust自动帮我们完成了这部分工作，那么什么情况下rust会自动帮我们完成这部分工作呢：</p>
<h4 id="生命周期消除-LifetimeElision"><a href="#生命周期消除-LifetimeElision" class="headerlink" title="生命周期消除(LifetimeElision)"></a>生命周期消除(LifetimeElision)</h4><p>rust编译器自动推理,无需手动重复添加</p>
<p>1.每个引用参数都有自己的生命周期参数。所以当参数为单个引用的时候不会报错：</p>
<p><img src="/../assets/img/18-2.jpg" alt="图18-2" title="18-2"></p>
<p>2.如果只有一个输入引用参数,那么它的生命周期会被赋予所有输出引用。</p>
<p><img src="/../assets/img/18-3.jpg" alt="图18-3" title="18-3"></p>
<p>因为函数执行完后所有变量都将被drop,所以唯一可以作为参考的就是入参的生命周期了</p>
<p>3.如果有多个输入生命周期参数,但其中一个是&amp;self或&amp;mut self,那么 self的生命周期会被赋予所有输出引用。</p>
<h4 id="特殊生命周期标注"><a href="#特殊生命周期标注" class="headerlink" title="特殊生命周期标注"></a>特殊生命周期标注</h4><p>‘static生命周期表示整个程序运行期间都有效的生命周期。这通常用于全局变量或字符串字面量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s: &amp;&#x27;static str = &quot;hello&quot;;</span><br><span class="line">const SOME_COORDINATE: (i32, i32) = (7, 4);</span><br><span class="line">let static_reference: &amp;&#x27;static (i32, i32) = &amp;SOME_COORDINATE;</span><br></pre></td></tr></table></figure>

<p>如果在一个impl中，并不关注每个函数中的生命周期（默认和结构体实例的生命周期相同），则可以在最开始声明时用一个占位符代替,</p>
<p>如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Counter&lt;&#x27;a&gt; &#123;</span><br><span class="line">    counter: &amp;&#x27;a mut i32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl  Counter&lt;&#x27;_&gt; &#123;</span><br><span class="line">    fn increment(&amp;mut self) &#123;</span><br><span class="line">        *self.counter += 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生命周期约束"><a href="#生命周期约束" class="headerlink" title="生命周期约束"></a>生命周期约束</h4><p>生命周期注解可以用来约束多个引用之间的关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn example&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;b str) -&gt; &amp;&#x27;a str</span><br><span class="line">where</span><br><span class="line">    &#x27;b:&#x27;a,</span><br><span class="line">&#123;</span><br><span class="line">    X</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中,’b:’a表示生命周期 ‘b必须不短于a</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/10/15/rust18/" data-id="cm2ai0wj50000o4uy31ok0g0p" data-title="rust 学习笔记十八 Rust中的生命周期" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust17" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/13/rust17/" class="article-date">
  <time class="dt-published" datetime="2024-10-13T09:03:48.873Z" itemprop="datePublished">2024-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/13/rust17/">rust 学习笔记十七 Rust 泛型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）概念"><a href="#（一）概念" class="headerlink" title="（一）	概念"></a>（一）	概念</h3><p>当使用泛型定义函数时,本来在函数签名中指定参数和返回值的类型的地方,会改用泛型来表示。采用这种技术,使得代码适应性更强,从而为函数的调用者提供更多的功能,同时也避免了代码的重复。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn add&lt;T&gt;(a:T,b:T) -&gt;T &#123;</span><br><span class="line">    a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的T就是泛型参数<br>不是所有T类型都能进行相加操作,因此我们需要用std::ops::Add&lt;Output&#x3D;T&gt;对T进行限制:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn add&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a: T, b: T) -&gt; T&#123;</span><br><span class="line">    a+b</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    println!(&quot;add i8:&#123;&#125;&quot;, add(2i8, 3i8));</span><br><span class="line">    println!(&quot;add i32:&#123;&#125;&quot;, add(20, 30));</span><br><span class="line">    println!(&quot;add f64:&#123;&#125;&quot;, add(1.32, 1.32));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，比较大小的泛型函数也需要声明，传入的T都是支持大小符号比较的</p>
<h3 id="（二）结构体定义中的泛型"><a href="#（二）结构体定义中的泛型" class="headerlink" title="（二）结构体定义中的泛型"></a>（二）结构体定义中的泛型</h3><p>声明结构体名称后面的<strong>尖括号中声明泛型参数的名称</strong>,结构体定义中可以指定具体数据类型的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Point &lt;T&gt;&#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let integer=Point&#123;x:5,y:10&#125;;</span><br><span class="line">    let float=Point&#123;x:1.0,y:4.0&#125;;</span><br><span class="line">    let wont_work=Point&#123;x:5,y:4&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（三）枚举中使用泛型"><a href="#（三）枚举中使用泛型" class="headerlink" title="（三）枚举中使用泛型"></a>（三）枚举中使用泛型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> enum Option&lt;T&gt; &#123;</span><br><span class="line">    Some(T),</span><br><span class="line">    None</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Result&lt;T, E&gt; &#123;</span><br><span class="line">    Ok(T),</span><br><span class="line">    Err(E)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="（四）方法中使用泛型"><a href="#（四）方法中使用泛型" class="headerlink" title="（四）方法中使用泛型"></a>（四）方法中使用泛型</h3><p><img src="/../assets/img/17-1.jpg" alt="图17-1" title="17-1"></p>
<p>如图所示：两个结构体实例的参数类型完全不相同，通过泛型完成了二者参数的组合，形成了另一类新的结构体实例</p>
<h3 id="（五）const泛型-Rust1-51版本引入的重要特性"><a href="#（五）const泛型-Rust1-51版本引入的重要特性" class="headerlink" title="（五）	const泛型(Rust1.51版本引入的重要特性)"></a>（五）	const泛型(Rust1.51版本引入的重要特性)</h3><p>[i32;3]和[i32;2]是两个完全不同的类型,因此无法用同一个函数调用。</p>
<p><img src="/../assets/img/17-3.jpg" alt="图17-3" title="17-3"></p>
<p>如图所示：当规定了传入的数组长度时，就必须传入固定长度的数组，否则会报错，如果我们希望争对不同长度的数组复用这个函数时，可以改为泛型传入，并将参数改为引用</p>
<p><img src="/../assets/img/17-2.jpg" alt="图17-2" title="17-2"></p>
<p>也可以不传入引用，增加一个表示长度的参数：</p>
<p>此时需要用到const泛型，此处定义的N限制了传入必须是已经确定长度的数组</p>
<p><img src="/../assets/img/17-4.jpg" alt="图17-4" title="17-4"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/10/13/rust17/" data-id="cm27d26zx000024uyggri8lkl" data-title="rust 学习笔记十七 Rust 泛型" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust16" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/12/rust16/" class="article-date">
  <time class="dt-published" datetime="2024-10-11T16:37:11.423Z" itemprop="datePublished">2024-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/12/rust16/">rust 学习笔记十六 Rust 智能指针</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）概念"><a href="#（一）概念" class="headerlink" title="（一）	概念"></a>（一）	概念</h3><p>智能指针(Smart Pointers)是一类数据结构,它不仅包含一个指针,还附带一些额外的元数据和功能。与普通指针不同,智能指针在Rust中实现了<strong>Deref和Drop两个trait</strong>,这使得它们可以像指针一样解引用并在离开作用域时自动清理资源</p>
<h3 id="（二）作用"><a href="#（二）作用" class="headerlink" title="（二）	作用"></a>（二）	作用</h3><h4 id="1-资源管理"><a href="#1-资源管理" class="headerlink" title="1 资源管理"></a>1 资源管理</h4><p>自动管理资源的分配和释放,避免内存泄漏</p>
<h4 id="2-所有权与借用"><a href="#2-所有权与借用" class="headerlink" title="2 所有权与借用"></a>2 所有权与借用</h4><p>Rust的所有权系统通过智能指针来确保内存安全,避免数据竞争和悬垂指针</p>
<h4 id="3-复杂数据结构"><a href="#3-复杂数据结构" class="headerlink" title="3 复杂数据结构"></a>3 复杂数据结构</h4><p>通过智能指针可以构建复杂的数据结构,如递归结构、共享数据等</p>
<h3 id="（三）特性"><a href="#（三）特性" class="headerlink" title="（三）	特性"></a>（三）	特性</h3><h4 id="1-Deref-Trait"><a href="#1-Deref-Trait" class="headerlink" title="1 Deref Trait"></a>1 Deref Trait</h4><p>实现了Dereftrait的类型可以像常规引用一样使用*运算符解引用</p>
<p>例如:Box<T>实现了Deref,所以可以通过*解引用获取其内部数据</p>
<h4 id="2-Drop-Trait"><a href="#2-Drop-Trait" class="headerlink" title="2 Drop Trait"></a>2 Drop Trait</h4><p>实现了Droptrait的类型在离开作用域时会自动调用其drop方法,用于释放资源</p>
<p>例如:Box<T>在超出作用域时会自动释放堆内存</p>
<h3 id="（四）Box"><a href="#（四）Box" class="headerlink" title="（四）	Box"></a>（四）	Box<T></h3><h4 id="1-概念："><a href="#1-概念：" class="headerlink" title="1. 概念："></a>1. 概念：</h4><p>Box<T>将类型T的值分配在堆上,而不是栈上（堆容量大得多，大型数据放在栈上会存在栈溢出）。当Box被销毁时,堆上的数据也会被销毁。</p>
<h4 id="2-底层实现"><a href="#2-底层实现" class="headerlink" title="2.	底层实现"></a>2.	底层实现</h4><h5 id="a-Box的底层原理"><a href="#a-Box的底层原理" class="headerlink" title="a. Box的底层原理"></a>a. Box的底层原理</h5><p>Box<T>指针实际上是一个智能指针,内部包含一个指向堆上分配内存的裸指针, 当Box<T>被销毁时,其Drop trait会被调用,释放堆上的内存。</p>
<h5 id="b-内存分配"><a href="#b-内存分配" class="headerlink" title="b. 内存分配"></a>b. 内存分配</h5><p>Rust使用系统的全局分配器(如malloc和free)来管理堆内存, Box::new分配内存,Drop释放内存。</p>
<h5 id="c-安全性"><a href="#c-安全性" class="headerlink" title="c. 安全性"></a>c. 安全性</h5><p>Rust的所有权系统确保Box<T>的内存安全。所有权转移多时,堆内存的生命周期也会随之变化。</p>
<h4 id="3-Box的应用场景"><a href="#3-Box的应用场景" class="headerlink" title="3.	 Box的应用场景"></a>3.	 Box的应用场景</h4><h6 id="a-堆分配"><a href="#a-堆分配" class="headerlink" title="a.堆分配"></a>a.堆分配</h6><p>Box最常见的用途是将数据分配在堆上,而不是栈上。这在处理较大数据结构或数据结构的大小在编译时不确定时尤为重要。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let b=Box::new(5);</span><br><span class="line">    println!(&quot;b=&#123;&#125;&quot;,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="b-动态大小类型-DST"><a href="#b-动态大小类型-DST" class="headerlink" title="b. 动态大小类型(DST)"></a>b. 动态大小类型(DST)</h5><p>Box允许处理动态大小类型,如str和[T]</p>
<p><img src="/../assets/img/16-1.jpg" alt="图16-1" title="16-1"></p>
<h5 id="c-递归数据结构"><a href="#c-递归数据结构" class="headerlink" title="c. 递归数据结构"></a>c. 递归数据结构</h5><p>递归数据结构需要指针类型来引用自身,而Box提供了这一功能。</p>
<p><img src="/../assets/img/16-2.jpg" alt="图16-2" title="16-2"></p>
<h5 id="d-类型擦除"><a href="#d-类型擦除" class="headerlink" title="d. 类型擦除"></a>d. 类型擦除</h5><p>Box<dyn Trait>用于类型擦除,允许<strong>在运行时决定类型</strong></p>
<p><img src="/../assets/img/16-3.jpg" alt="图16-3" title="16-3"></p>
<p>如图所示，动态数组中包含了Dog和Cat两种结构的智能指针，他们都实现了trait中的方法，只需要将vec声明为<dyn trait>即可（dyn 关键字用于表示动态分发的 trait）</p>
<h5 id="e-内存管理和性能优化"><a href="#e-内存管理和性能优化" class="headerlink" title="e. 内存管理和性能优化"></a>e. 内存管理和性能优化</h5><p>通过使用Box,可以控制内存的分配和释放,从而优化性能能和内存使用。例如,将大型数据结构放在堆上,而不是栈上,可以减少栈的使用量,从而避免栈溢出。</p>
<p>声明到堆上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let start = Instant::now(); </span><br><span class="line"></span><br><span class="line">let large_array = Box::new([0u8; 1_000_000]);</span><br><span class="line"></span><br><span class="line">let duration = start.elapsed();</span><br></pre></td></tr></table></figure>
<p>打印duration得到：363.2µs,</p>
<p>而直接声明到栈上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let large_array = [0u8; 1_000_000]);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let start = Instant::now(); </span><br><span class="line"></span><br><span class="line">let large_array = [0u8; 1_000_000];</span><br><span class="line"></span><br><span class="line">let duration = start.elapsed();</span><br></pre></td></tr></table></figure>
<p>打印duration得到：30µs</p>
<p>由此可见，创建一个堆上的 Box 数组（large_array）比直接在栈上创建数组（large_array2）要花费更多的时间，这是因为 Box::new 涉及到堆内存分配</p>
<h4 id="4-Box的优缺点"><a href="#4-Box的优缺点" class="headerlink" title="4.	Box的优缺点"></a>4.	Box的优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>提供堆内存分配,支持复杂数据结构，与Rust的所有权系统完美集成,确保<strong>内存安全</strong>。动态分配对象,实现类型擦除。</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>需要<strong>堆内存分配和释放,可能带来性能开销</strong>。不适合需要频繁分配和释放的场景。</p>
<h3 id="（五）Drop、Deref和DerefMut"><a href="#（五）Drop、Deref和DerefMut" class="headerlink" title="（五）Drop、Deref和DerefMut"></a>（五）Drop、Deref和DerefMut</h3><h4 id="1-Drop-Trait"><a href="#1-Drop-Trait" class="headerlink" title="1. Drop Trait"></a>1. Drop Trait</h4><p>Dropt rait定义了当一个值离开作用域时应该执行的操作。</p>
<p>例如:Box<T>在超出作用域时会自动调用其Drop trait,释放堆上的内存。</p>
<p>Drop trait用于自定义当值离开作用域时执行的代码,通常用于释放资源(例如内存、文件句柄、网络连接等)。</p>
<p><img src="/../assets/img/16-4.jpg" alt="图16-4" title="16-4"></p>
<p>如图所示，在两个变量依次离开当前作用域时，drop函数均被自动触发</p>
<h4 id="2-Deref-Trait"><a href="#2-Deref-Trait" class="headerlink" title="2. Deref Trait"></a>2. Deref Trait</h4><p>Deref trait定义了如何将一个类型转换为引用。</p>
<p>例如:Box<T>实现了Deref,所以可以通过*运算符解引用获取其内部数据。</p>
<p>Deref trait定义了一个deref方法,该方法返回指向目标类型的引用。</p>
<p><img src="/../assets/img/16-5.jpg" alt="图16-5" title="16-5"></p>
<h4 id="3-DerefMut-Trait"><a href="#3-DerefMut-Trait" class="headerlink" title="3. DerefMut Trait"></a>3. DerefMut Trait</h4><p>与Deref类似,Deref Mut用于重载可变解引用运算符(*),允许对自定义类型进行可变解引用。</p>
<p>将变量声明为mut后，为其实现Deref</p>
<p>特性中的deref方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">impl&lt;T&gt; Deref for MyBox&lt;T&gt; &#123;</span><br><span class="line">    type Target = T;</span><br><span class="line">    fn deref(&amp;self)-&gt;&amp;T &#123;</span><br><span class="line">        println!(&quot;deref called&quot;);</span><br><span class="line">        &amp;self.0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即可通过*获取并修改变量</p>
<h3 id="六-Rc"><a href="#六-Rc" class="headerlink" title="(六) Rc"></a>(六) Rc<T></h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>Rc是Reference Counted的缩写</p>
<p>允许<strong>多所有者的共享所有权</strong>模型</p>
<p>使用Box<T>定义conslist的例子。这一次,我们希望创建两个共享第三个列表所有权的列表,其概念将会看起来如下图所示</p>
<p><img src="/../assets/img/16-7.jpg" alt="图16-6" title="16-6"></p>
<h4 id="2-实践"><a href="#2-实践" class="headerlink" title="2.实践"></a>2.实践</h4><p>首先看下面代码：</p>
<p><img src="/../assets/img/16-8.jpg" alt="图16-7" title="16-7"></p>
<p>当用Box实现这个递归的结构时，发现报错当a元素的所有权已经在第一次传入Box时发生了移动，所以这时候我们可以使用引用而非Box的方式来创建递归List</p>
<p><img src="/../assets/img/16-9.jpg" alt="图16-8" title="16-8"></p>
<p>需要在声明struct结构时声明生命周期，表示所有被引用的List生命周期都和引用者相同</p>
<p>也可以通过Rc<T>智能指针实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">enum List&#123;</span><br><span class="line">    Cons(i32, Rc&lt;List&gt;),</span><br><span class="line">    Nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use std::rc::Rc;</span><br><span class="line"></span><br><span class="line">use crate::List::*;</span><br><span class="line"></span><br><span class="line">fn study() &#123;</span><br><span class="line">    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));</span><br><span class="line">    let b = Cons(3, Rc::clone(&amp;a)); </span><br><span class="line">    let c = Cons(4, Rc::clone(&amp;a));</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;,a);</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;,b);</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在b和c中，Rc智能指针实现了引用的共享,如图所示，在三行声明之后分别打印对a的引用个数，依次增加一</p>
<p><img src="/../assets/img/16-9.jpg" alt="图16-9" title="16-9"></p>
<h3 id="七-Refcell"><a href="#七-Refcell" class="headerlink" title="(七) Refcell"></a>(七) Refcell<T></h3><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1.概念"></a>1.概念</h4><p>有时候我们需要一个可以在运行时改变其值的变量，即使这个变量本身被声明为不可变的, RefCell<T>是Rust标准库中的一个智能指针类型,它提供了内部可变性,即允许<strong>在不可变引用的情况下修改数据</strong>。这种特性使得你可以在编译时保证安全的情况下动态地借用和修改数据。</p>
<h4 id="2-主要特征"><a href="#2-主要特征" class="headerlink" title="2.主要特征"></a>2.主要特征</h4><h5 id="a-内部可变性"><a href="#a-内部可变性" class="headerlink" title="a. 内部可变性:"></a>a. 内部可变性:</h5><p>RefCell<T>允许你在其拥有的T内部进行修改,即使RefCell本身是不可变的。这是通过在运行时进行借用检查实现的。</p>
<h5 id="b-运行时借用检查"><a href="#b-运行时借用检查" class="headerlink" title="b.运行时借用检查:"></a>b.运行时借用检查:</h5><p>RefCell 使用动态借用检查,确保在运行时遵循Rust的借用规则。即在任何时刻,RefCell只能有一个可变借用或多个不可变借用,<strong>但不能同时存在。</strong></p>
<h4 id="3-borrow和borrow-mut方法"><a href="#3-borrow和borrow-mut方法" class="headerlink" title="3.borrow和borrow mut方法:"></a>3.borrow和borrow mut方法:</h4><p>RefCell提供了两个方法来获取对内部数据的借用:</p>
<h5 id="a-borrow"><a href="#a-borrow" class="headerlink" title="a.borrow()"></a>a.borrow()</h5><p>获取不可变借用(Ref<T>),可以同时有多个个.</p>
<h5 id="b-borrow-mut"><a href="#b-borrow-mut" class="headerlink" title="b.borrow_mut()"></a>b.borrow_mut()</h5><p>获取可变借用(RefMut<T>),在同一时间只能有一个.</p>
<h4 id="4-关键点"><a href="#4-关键点" class="headerlink" title="4.关键点"></a>4.关键点</h4><h5 id="a-借用规则"><a href="#a-借用规则" class="headerlink" title="a.借用规则:"></a>a.借用规则:</h5><p>RefCell在运行时检查借用规则,以防止数据竞争和未定义行为。编详器不进行这些检查,而是依赖RefCell在运行时进行。</p>
<h5 id="b-运行时开销"><a href="#b-运行时开销" class="headerlink" title="b.运行时开销:"></a>b.运行时开销:</h5><p>因为RefCell 需要在运行时检查借用规则,所以它会引入一一定的性能开销。这在需要在编译时确定所有借用规则的场景中不可替代。</p>
<h5 id="c-错误处理"><a href="#c-错误处理" class="headerlink" title="c.错误处理:"></a>c.错误处理:</h5><p>如果违反了借用规则(例如,尝试同时获取多个可变借用),RefCell会在运行时引发panic</p>
<h5 id="d-使用场景"><a href="#d-使用场景" class="headerlink" title="d.使用场景"></a>d.使用场景</h5><p>数据结构:</p>
<p>在需要可变性但又受限于Rust的所有权系统时,RefCell允许在数数据结构中使用内部可变性。例如,实现需要共享但修改的数据结构(如图、树)</p>
<p>单线程环境:</p>
<p>RefCell主要用于单线程环境。如果你需要在多线程环境中处理内部可变性,应该使用Mutex或RwLock这类类型。</p>
<p><img src="/../assets/img/16-10.jpg" alt="图16-10" title="16-10"></p>
<h3 id="八-Weak"><a href="#八-Weak" class="headerlink" title="(八) Weak"></a>(八) Weak<T></h3><p>首先看下<strong>引用循环与内存泄漏</strong>的问题</p>
<p>在Rust中,引用计数(RC<T>)和原子引用计数(Arc<T>)可以让多个所有者共享同一个数据。然而,这种共享机制如果不当使用,可能会导致引用循环(reference cycle),从而造成内存泄漏。</p>
<p>如下所示：当first与second之间互相引用时，直接打印引用数量发现两者的强引用个数都是2，而当我们只打印first或者second时，出现了堆栈溢出：</p>
<p><img src="/../assets/img/16-11.jpg" alt="图16-11" title="16-11"></p>
<p>如果我们需要互相引用又不希望出现这种问题，需要用到Weak指针：</p>
<h4 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1.概念"></a>1.概念</h4><p>什么是Weak<T>?</p>
<p>弱引用</p>
<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h4><h5 id="a-非所有权引用"><a href="#a-非所有权引用" class="headerlink" title="a.非所有权引用:"></a>a.非所有权引用:</h5><p>Weak<T>并不拥有数据的所有权,因此它不会影响 RC<T>的引用计数。</p>
<h5 id="b-不会引发内存泄漏"><a href="#b-不会引发内存泄漏" class="headerlink" title="b.不会引发内存泄漏:"></a>b.不会引发内存泄漏:</h5><p>由于Weak<T><strong>不增加引用计数,可以以避免引用循环问题,从而避免内存泄漏。</strong></p>
<h5 id="c-必须升级"><a href="#c-必须升级" class="headerlink" title="c.必须升级:"></a>c.必须升级:</h5><p>Weak<T>是一个非所有权引用,因此在使用数据之前,需要通过upgrade()方法将其升级为Rc<T>,如果数据已经被释放,upgrade()会返回 None</p>
<p><img src="/../assets/img/16-12.jpg" alt="图16-12" title="16-12"></p>
<p>如上所示：在struct中添加了弱引用, 并通过强弱引用将二者相互关联，最终打印时发现，first存在一个弱引用, 此时再打印first,发现next指向了second,second的prev是弱指针</p>
<h4 id="3-强引用与弱引用的主要区别"><a href="#3-强引用与弱引用的主要区别" class="headerlink" title="3.强引用与弱引用的主要区别"></a>3.强引用与弱引用的主要区别</h4><h5 id="a-所有权"><a href="#a-所有权" class="headerlink" title="a.所有权:"></a>a.所有权:</h5><p>强引用(RC<T>):持有数据的所有权,保证数据在作用内不会被释放</p>
<p>弱引用(Weak<T>):不持有数据的所有权,不影响数据的生命周期。</p>
<h5 id="b-引用计数"><a href="#b-引用计数" class="headerlink" title="b.引用计数:"></a>b.引用计数:</h5><p>强引用:增加引用计数,数据被多个所有者共享。</p>
<p>弱引用:不增加引用计数,不干扰RC<T>的生命周期管理。</p>
<h5 id="c-内存管理"><a href="#c-内存管理" class="headerlink" title="c.内存管理:"></a>c.内存管理:</h5><p>强引用:只有当所有强引用都被丢弃时,数据才会被释放.</p>
<p>弱引用:只能通过升级<code>upgrade()</code>来访问数据,如果数数据已经被释放,则升级会失败.</p>
<h5 id="d-适用场景"><a href="#d-适用场景" class="headerlink" title="d.适用场景:"></a>d.适用场景:</h5><p>强引用:当你希望共享数据并确保数据在至少一个强引用存在时不会被释放。</p>
<p>弱引用:当你需要避免引用循环或只需要偶尔访问数据,不想持有其所有权时.</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><h4 id="1-实现一个简单的文件系统模拟-其中包含文件和文件夹的根念。支持创建和罗列"><a href="#1-实现一个简单的文件系统模拟-其中包含文件和文件夹的根念。支持创建和罗列" class="headerlink" title="1. 实现一个简单的文件系统模拟,其中包含文件和文件夹的根念。支持创建和罗列"></a>1. 实现一个简单的文件系统模拟,其中包含文件和文件夹的根念。支持创建和罗列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">struct File &#123;</span><br><span class="line">    name: String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Dir &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    contents: Vec&lt;(String, Box&lt;FileNode&gt;)&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum FileNode &#123;</span><br><span class="line">    File(File),</span><br><span class="line">    Dir(Dir),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Dir &#123;</span><br><span class="line">    fn new(name: String) -&gt; Dir &#123;</span><br><span class="line">        Dir &#123;</span><br><span class="line">            name,</span><br><span class="line">            contents: Vec::new(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn add_file(&amp;mut self, name: String) &#123;</span><br><span class="line">        let file = File &#123;</span><br><span class="line">            name: name.clone(),</span><br><span class="line">        &#125;;</span><br><span class="line">        self.contents.push((name, Box::new(FileNode::File(file))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn add_dir(&amp;mut self, name: String) -&gt; &amp;mut Dir &#123;</span><br><span class="line">        let dir = Dir::new(name.clone());</span><br><span class="line">        self.contents.push((name.clone(), Box::new(FileNode::Dir(dir))));</span><br><span class="line">        self.get_dir_mut(&amp;name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn get_dir_mut(&amp;mut self, name: &amp;str) -&gt; &amp;mut Dir &#123;</span><br><span class="line">        for (ref mut n, ref mut node) in &amp;mut self.contents &#123;</span><br><span class="line">            if n == name &#123;</span><br><span class="line">                if let FileNode::Dir(ref mut dir) = node.as_mut() &#123;</span><br><span class="line">                    return dir;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        panic!(&quot;Directory not found&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut root = Dir::new(&quot;root&quot;.to_string());</span><br><span class="line"></span><br><span class="line">    let mut dir1 = root.add_dir(&quot;dir1&quot;.to_string());</span><br><span class="line">    dir1.add_file(&quot;file1.txt&quot;.to_string());</span><br><span class="line"></span><br><span class="line">    let mut subdir1 = dir1.add_dir(&quot;subdir1&quot;.to_string());</span><br><span class="line">    subdir1.add_file(&quot;file2.txt&quot;.to_string());</span><br><span class="line"></span><br><span class="line">    // 打印目录结构以验证结果</span><br><span class="line">    fn print_dir(dir: &amp;Dir, indent: usize) &#123;</span><br><span class="line">        for (name, node) in &amp;dir.contents &#123;</span><br><span class="line">            println!(&quot;&#123;&#125;&#123;name&#125;&quot;, &quot; &quot;.repeat(indent));</span><br><span class="line">            match node.as_ref() &#123;</span><br><span class="line">                FileNode::File(_) =&gt; println!(&quot;&#123;&#125; (file)&quot;, name),</span><br><span class="line">                FileNode::Dir(subdir) =&gt; &#123;</span><br><span class="line">                    println!(&quot;&#123;&#125; (dir)&quot;, name);</span><br><span class="line">                    print_dir(&amp;subdir, indent + 4);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print_dir(&amp;root, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-实现一个简单的社交网络系统-包含用户和朋友关系。使用Rc-RefCell-Weak来处理"><a href="#2-实现一个简单的社交网络系统-包含用户和朋友关系。使用Rc-RefCell-Weak来处理" class="headerlink" title="2.实现一个简单的社交网络系统,包含用户和朋友关系。使用Rc,RefCell,Weak来处理"></a>2.实现一个简单的社交网络系统,包含用户和朋友关系。使用Rc<T>,RefCell<T>,Weak<T>来处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">use std::cell::RefCell;</span><br><span class="line">use std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"></span><br><span class="line">#[derive(Debug, Clone)]</span><br><span class="line">struct User &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    friends: RefCell&lt;Vec&lt;Weak&lt;User&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl User &#123;</span><br><span class="line">    fn new(name: &amp;str) -&gt; Rc&lt;User&gt; &#123;</span><br><span class="line">        Rc::new(User &#123;</span><br><span class="line">            name: name.to_string(),</span><br><span class="line">            friends: RefCell::new(vec![]),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn add_friend(&amp;self, other: Rc&lt;User&gt;) &#123;</span><br><span class="line">        // if !other.friends.borrow().contains(&amp;Rc::downgrade(&amp;Rc::new(self.clone()))) &#123;</span><br><span class="line">            self.friends.borrow_mut().push(Rc::downgrade(&amp;other));</span><br><span class="line">            other.friends.borrow_mut().push(Rc::downgrade(&amp;Rc::new(self.clone())));</span><br><span class="line">        // &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn show_friends(&amp;self) &#123;</span><br><span class="line">        let friends_list = self.friends.borrow().iter().filter_map(|weak| &#123;</span><br><span class="line">            weak.upgrade()</span><br><span class="line">        &#125;).collect::&lt;Vec&lt;_&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        println!(&quot;&#123;&#125;&#x27;s friends:&quot;, self.name);</span><br><span class="line">        for friend in friends_list.iter() &#123;</span><br><span class="line">            println!(&quot;&#123;&#125;&quot;, friend.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let user1 = User::new(&quot;Alice&quot;);</span><br><span class="line">    let user2 = User::new(&quot;Bob&quot;);</span><br><span class="line">    let user3 = User::new(&quot;Charlie&quot;);</span><br><span class="line"></span><br><span class="line">    user1.add_friend(user2.clone());</span><br><span class="line">    user2.add_friend(user3.clone());</span><br><span class="line">    user3.add_friend(user1.clone()); // This will create a cycle, but we handle it.</span><br><span class="line"></span><br><span class="line">    user1.show_friends();</span><br><span class="line">    user2.show_friends();</span><br><span class="line">    user3.show_friends();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>















      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/10/12/rust16/" data-id="cm26g9orz000058uyhmah69ik" data-title="rust 学习笔记十六 Rust 智能指针" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust15" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/10/rust15/" class="article-date">
  <time class="dt-published" datetime="2024-10-09T16:17:15.815Z" itemprop="datePublished">2024-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/10/rust15/">rust 学习笔记十五 Rust 的模块化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）概念"><a href="#（一）概念" class="headerlink" title="（一）	概念"></a>（一）	概念</h3><h4 id="1-packages"><a href="#1-packages" class="headerlink" title="1. packages"></a>1. packages</h4><p>一项cargo特性，可让您<strong>构建、测试和共享crates</strong>, 一个packages可以包含多个binary crates和可选的lib crates。至少包含一个crate</p>
<p>Packages的基础结构如图所示：</p>
<p><img src="/../assets/img/15-1.jpg" alt="图15-1" title="15-1"></p>
<p>其中bin目录下存放的就是多个binary crates，通过<code>cargo new</code>创建的项目就是一个标准的package结构，如果在创建时使用<code>cargo new –lib name</code>, 创建出的src目录下的主文件就是lib.rs(正常情况下是main.rs)像这样创建出的package就是只有单个crate，这两种crate分别叫<strong>binary crate和lib crate</strong>，区别在于binary crate是可以直接通过cargo run 执行的，而lib则不能</p>
<h4 id="2-crates"><a href="#2-crates" class="headerlink" title="2. crates"></a>2. crates</h4><p>生成库或可执行文件的module tree, 刚才有提到，crates分为binary crate 和 library crate，一般情况下有一个lib crate,项目的bin目录下包含多个binary crate</p>
<h4 id="3-modules-and-use"><a href="#3-modules-and-use" class="headerlink" title="3. modules and use"></a>3. modules and use</h4><p>控制路径的组织、范围和隐私</p>
<p>在一个crate中可以包含多个module</p>
<p>首先是module的声明</p>
<h5 id="a-使用mod关键字："><a href="#a-使用mod关键字：" class="headerlink" title="a. 使用mod关键字："></a>a. 使用mod关键字：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mod a &#123;</span><br><span class="line">    const num:usize = 1;</span><br><span class="line">    fn echo() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模块中可以定义方法, 同时模块也支持嵌套：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mod a &#123;</span><br><span class="line">    const num:usize = 1;</span><br><span class="line">    fn echo() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    mod b &#123;</span><br><span class="line">        fn log() &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当需要在同crate中的main函数访问mod中的方法时, 需要通过双冒号调用：</p>
<p><img src="/../assets/img/15-2.jpg" alt="图15-2" title="15-2"></p>
<p>发现报错：方法是<strong>默认私有</strong>的，现在我们需要用到pub关键字</p>
<h5 id="b-pub关键字："><a href="#b-pub关键字：" class="headerlink" title="b. pub关键字："></a>b. pub关键字：</h5><p>将mod中的对应法修改为共有的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub fn echo() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是此时如果需要在子模块b中调用父级模块a的echo方法，是可以不用声明为pub的，只不过需要在子模块中声明<code>use super::echo;</code>表示继承父模块的方法</p>
<p>如果mod中嵌套的层级较深，需要调用很底层的方法的话，除了需要将路径上的子模块和方法都设置为pub外，每次调用都写出全部路径似乎显得不够简洁，影响可读性，在这里可以用到use关键字</p>
<h5 id="c-use关键字"><a href="#c-use关键字" class="headerlink" title="c. use关键字:"></a>c. use关键字:</h5><p><img src="/../assets/img/15-3.jpg" alt="图15-3" title="15-3"></p>
<p>之后就可以在外层直接通过方法名调用了, 当不同路径的两个同名的方法都被use声明时，为了区分，需要将其中一个方法用as关键字声明为另外的别名</p>
<h5 id="d-as关键字"><a href="#d-as关键字" class="headerlink" title="d. as关键字:"></a>d. as关键字:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">use a::&#123;b::log, log as other_log&#125;;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    //a::b::log();</span><br><span class="line"></span><br><span class="line">    log();</span><br><span class="line">    other_log();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mod a &#123;</span><br><span class="line">    const num:usize = 1;</span><br><span class="line">    pub fn log() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    pub mod b &#123;</span><br><span class="line">        pub fn log() &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时as在rust中也可以用于基础类型的类型转换</p>
<h5 id="从刚才的pub中可以扩展说一下Rust中的可见性控制"><a href="#从刚才的pub中可以扩展说一下Rust中的可见性控制" class="headerlink" title="从刚才的pub中可以扩展说一下Rust中的可见性控制"></a>从刚才的pub中可以扩展说一下Rust中的可见性控制</h5><p><strong>private(default)</strong> 默认情况下都是私有的</p>
<p><strong>pub(crate)</strong> 仅限于在同一个crate内为公开，其余crate不能调用</p>
<p><strong>pub(in path)</strong> 范围更加精细，控制只能在具体的模块中能访问</p>
<p><strong>pub use</strong></p>
<p>假设有以下结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 在 lib.rs 或 main.rs</span><br><span class="line">mod outer &#123;</span><br><span class="line">    pub mod inner &#123;</span><br><span class="line">        pub fn public_function() &#123;</span><br><span class="line">            println!(&quot;Called public_function()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub use outer::inner::public_function;</span><br></pre></td></tr></table></figure>

<p>通过 pub use，我们将 publicfunction 重新导出到了 crate 的根作用域。现在，其他模块可以使用 use 语句直接访问 public_function，而不需要指定完整的模块路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use crate::public_function;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    public_function(); // 直接调用，无需通过模块路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Paths"><a href="#4-Paths" class="headerlink" title="4.Paths"></a>4.Paths</h4><p>一种命名项目的方式，例如struct、function或modules, 分为<strong>absolute path crate  绝对路径，relative path super self 相对路径</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    crate::a::log();</span><br><span class="line">    a::b::log();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mod a &#123;</span><br><span class="line">    const num:usize = 1;</span><br><span class="line">    pub fn log() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    pub mod b &#123;</span><br><span class="line">        pub fn log() &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>crate::a::log();</code>是绝对路径, <code>a::b::log();</code>是相对路径, 同时上文中还提到了用super关键字来调用父级mod的方法，self表示模块本身,用于调用同一个mod中的其他方法</p>
<h4 id="5-workspace"><a href="#5-workspace" class="headerlink" title="5.workspace:"></a>5.workspace:</h4><p>Workspace是一个由多个crates组成的项目结构，主要用于</p>
<p>代码共享：</p>
<p>在 workspace 中，你可以有一个或多个crate（library crates）和二进制 crate（binary crates）。crate 可以被其他 crate 作为依赖项使用，从而实现代码的共享。</p>
<p>以及统一依赖管理：</p>
<p>workspace 允许你在一个中央位置管理所有 crate 的依赖，这有助于避免重复的依赖项和版本冲突。</p>
<p>使用方法是：使用 cargo new 创建子目录，并在每个子目录中创建一个新的 Cargo.toml 文件，然后配置依赖关系：在根 Cargo.toml 文件中使用 [workspace] 部分配置依赖关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[workspace]</span><br><span class="line">menbers=[&quot;xx&quot;,&quot;xx&quot;,&quot;xx&quot;]</span><br></pre></td></tr></table></figure>

<p>workspace中可以有一个主package，也可以没有</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/10/10/rust15/" data-id="cm222ty5b0000pguyhx2sh1hc" data-title="rust 学习笔记十五 Rust 的模块化" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust14" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/28/rust14/" class="article-date">
  <time class="dt-published" datetime="2024-09-27T19:35:47.737Z" itemprop="datePublished">2024-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/28/rust14/">rust 学习笔记十四 Rust 的返回值与错误处理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）Option返回值"><a href="#（一）Option返回值" class="headerlink" title="（一）	Option返回值"></a>（一）	Option返回值</h3><h4 id="1-解构Option"><a href="#1-解构Option" class="headerlink" title="1. 解构Option"></a>1. 解构Option</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Option&lt;T&gt;&#123;</span><br><span class="line">    Some(T)</span><br><span class="line">    None,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单解释就是:一个变量要么有值:Some(T),要么为空:None</p>
<p>在之前的文章中出现过这样的例子：</p>
<p><img src="/../assets/img/14-1.jpg" alt="图14-1" title="14-1"></p>
<h4 id="2-辅助函数"><a href="#2-辅助函数" class="headerlink" title="2. 辅助函数"></a>2. 辅助函数</h4><p>但是match也有弊端，代码**较为冗杂，当嵌套较深时，不够优雅，因此，option提供了一系列辅助函数</p>
<p>下面举例几个常用的进行说明：</p>
<p>a. unwrap</p>
<p><img src="/../assets/img/14-2.jpg" alt="图14-2" title="14-2"></p>
<p>可见，unwrap可以直接跳过match，得到Some包裹的实际值，但是<strong>如果此时待解构的值是None,直接调用unwrap会发生panic</strong></p>
<p>b. is_some is_none</p>
<p>可以使用is_some和is_none方法来判断Option中是否存在值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">let</span> v=[10,40,30];</span><br><span class="line">    ifv.get(1).<span class="function"><span class="title">is_some</span></span>()&#123;</span><br><span class="line">        println!(<span class="string">&quot;&#123;&#125;&quot;</span>,v[1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用is_none 和 is_some好处是<strong>可以在none值时不panic</strong></p>
<p>c. unwrap_or</p>
<p>如果既需要在报错时候不panic, 也希望能直接拿到值，可以使用unwrap_or方法：</p>
<p><img src="/../assets/img/14-3.jpg" alt="图14-3" title="14-3"></p>
<p>由此可见，<strong>不仅可以取值，还可以在值无效时设置默认值</strong></p>
<h3 id="（二）错误处理"><a href="#（二）错误处理" class="headerlink" title="（二）	错误处理"></a>（二）	错误处理</h3><p>Rust中的错误主要分为两类:</p>
<p><strong>可恢复错误</strong>: 通常用于从系统全局角度来看可以接受的错误,例如:处理用户的访问、操作等错误,这些错误只会影响某个用户自身的操作进程,而不会对系统的全局稳定性产生影响</p>
<p><strong>不可恢复错误</strong>: 刚好相反,该错误通常是全局性或者系统性的错误,例如数组越界访问,系统启动时发生了影响启动流程的错误等等,这些错误的影响往往对于系统来说是致命的</p>
<h4 id="1-Result用于可恢复错误"><a href="#1-Result用于可恢复错误" class="headerlink" title="1. Result&lt;T,E&gt;用于可恢复错误"></a>1. Result&lt;T,E&gt;用于可恢复错误</h4><p>大部分错误并没有严重到需要程序完全停止执行。有时候,一个函数失败,仅仅就是因为一个容易理解和响应的原因, 例如,如果因为打开一个并不存在的文件而失败,此时我们可能想要创建这个文件,而不是终止进程。</p>
<p>泛型参数T代表成功时存入的正确值的类型,存放方式是OK(T)</p>
<p>E代表错误时存入的错误值,存放方式是Err(E)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">enum Result&lt;T,E&gt; &#123;</span><br><span class="line">Ok(T),</span><br><span class="line">Err(E),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum MathError&#123;</span><br><span class="line">    DivisionByZero,</span><br><span class="line">    NegativeSquareRoot,</span><br><span class="line">&#125;</span><br><span class="line">fn div(a:i32, b: i32) -&gt; Result&lt;f64,MathError&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> b!=0&#123;</span><br><span class="line">    Ok(a as f64 / b as f64)</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    Err(MathError::DivisionByZero)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn sqrt(a:f64) -&gt;Result&lt;f64,MathError&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt;0.0&#123;</span><br><span class="line">        Err(MathError::NegativeSquareRoot)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Ok(a.sqrt())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理result：</p>
<p>基础示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> f=File::open(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> f=match f&#123;</span><br><span class="line">    Ok(file)=&gt;file,</span><br><span class="line">    Err(error)=&gt;&#123;</span><br><span class="line">        panic!(<span class="string">&quot;Problem opening the file:&#123;:?&#125;&quot;</span>,error)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对返回的错误进行处理, 我们希望对不同的错误原因采取不同的行为:</p>
<p>如果File::open因为文件不存在而失败,我们希望创建这个文件并返回新文件的句柄</p>
<p>如果File::open因为任何其他原因失败,例如没有打开文件的权限,我们仍然panic!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line">use std::io::ErrorKind;</span><br><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">let</span> greeting_file_result=File::open(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">let</span> greeting_file=match greeting_file_result &#123;</span><br><span class="line">        Ok(file)=&gt;file,</span><br><span class="line">        Err(error)=&gt;match error.<span class="function"><span class="title">kind</span></span>()&#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; match File::create(<span class="string">&quot;hello.txt&quot;</span>)&#123;</span><br><span class="line">                Ok(<span class="built_in">fc</span>)=&gt;<span class="built_in">fc</span>,</span><br><span class="line">                Err(e)=&gt;panic!(<span class="string">&quot;Problem creating the file:&#123;e:?&#125;&quot;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error=&gt;&#123;</span><br><span class="line">                panic!(<span class="string">&quot;Problem opening the file:&#123;other_error:?&#125;&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Result的辅助方法"><a href="#2-Result的辅助方法" class="headerlink" title="2.Result&lt;T,E&gt;的辅助方法"></a>2.Result&lt;T,E&gt;的辅助方法</h4><p>match能够胜任它的工作,不过它可能有点冗长并且不总是能很好的的表明其意图。Result&lt;T,E&gt;类型定义了很多辅助方法来处理各种情况</p>
<p>a. unwrap</p>
<p>其中之一叫做 unwrap,它的实现就类似于示例9-4中的match语问,如果 Result值是成员0k,unwrap会返回 0k 中的值,如果Result是成员Err,unwrap会为我们调用 panic!</p>
<p><img src="/../assets/img/14-5.jpg" alt="图14-5" title="14-5"></p>
<p>b. unwrap_or</p>
<p>同时也支持使用unwrap_or设置失败之后的默认值</p>
<p>c. expect</p>
<p>expect跟unwrap 很像,也是遇到错误直接 panic,但是会带上自定义的错误提示信息,相当于重载了错误打印的函数:</p>
<p><img src="/../assets/img/14-6.jpg" alt="图14-6" title="14-6"></p>
<p>d. map</p>
<p><code>Result&lt;T, E&gt; -&gt; Result&lt;U, E&gt;</code></p>
<p><img src="/../assets/img/14-7.jpg" alt="图14-7" title="14-7"></p>
<p>e. map_err</p>
<p><code>Result&lt;T,E&gt; -&gt; Result&lt;T,F&gt;</code>, 对错误类型进行转换</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line"></span><br><span class="line">fn x() -&gt;Result&lt;(),String&gt;&#123;</span><br><span class="line">    <span class="built_in">let</span> f = File::open(<span class="string">&quot;hello.txt&quot;</span>).map_err(|e: std:: io::Error| -&gt;String&#123;format!(<span class="string">&quot;&#123;e&#125;&quot;</span>)&#125;);</span><br><span class="line">    match f&#123;</span><br><span class="line">        Err(e)=&gt;Err(e),</span><br><span class="line">        Ok(_)=&gt;&#123;</span><br><span class="line">            Ok(())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实上述的代码在Err(e)的时候再将e的类型转换为String也可以，但是当遇到下面这种情况的时候：</p>
<p>传播错误</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fn read_username_from_file() -&gt;Result&lt;String, io::Error&gt;&#123;</span><br><span class="line">    //打开文件,f是`Result&lt;文件句柄,io::Error&gt;</span><br><span class="line">    <span class="built_in">let</span> f=File::open(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">let</span> mut f=match f&#123;</span><br><span class="line">    //打开文件成功,将file句柄赋值给f</span><br><span class="line">    Ok(file)=&gt;file,</span><br><span class="line">    //打开文件失败,将错误返回(向上传播)</span><br><span class="line">    Err(e)=&gt;<span class="built_in">return</span> Err(e),</span><br><span class="line">    &#125;;</span><br><span class="line">    //创建动态字符串s</span><br><span class="line">    <span class="built_in">let</span> mut s=String::new();</span><br><span class="line">    //从f文件句柄读取数据并写入s中</span><br><span class="line">    match f.read_to_string(&amp;mut s)&#123;</span><br><span class="line">    //读取成功,返回0k封装的字符串</span><br><span class="line">    Ok(_)=&gt;Ok(s),</span><br><span class="line">    //将错误向上传播</span><br><span class="line">    Err(e)=&gt;Err(e),</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>整个打开文件再进行读取的过程需要非常多的match，因此可以<strong>使用传播错误的简写?运算符</strong></p>
<p>对于Result, 如果结果是<strong>Ok(T),则把T赋值给f, 如果结果是Err(E),则返回该错误</strong></p>
<p>对于Option, 如果值是Some,<strong>Some中的值作为表达式的返回值同时函数继续, 如果值是None,此时None会从函数中提前返回</strong></p>
<p>所以?特别适合用来传播错误</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn c() -&gt; Result&lt;String, io::Error&gt; &#123;</span><br><span class="line">    <span class="built_in">let</span> mut f: File=File::open(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="built_in">let</span> mut s=String::new();</span><br><span class="line">    f.read_to_string(&amp;mut s)?;</span><br><span class="line">    Ok(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法会使得代码简洁很多,但是当返回值改为Result&lt;String, String&gt;的时候，将不再适用，此时需要用到map_err,来对error进行类型转换</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File::open(<span class="string">&quot;hello.txt&quot;</span>).map_err(|e| format!(<span class="string">&quot;&#123;e&#125;&quot;</span>))?</span><br><span class="line">read_to_string(&amp;mut s).map_err(|e| format!(<span class="string">&quot;&#123;e&#125;&quot;</span>))?</span><br><span class="line">Ok(s)</span><br></pre></td></tr></table></figure>

<h4 id="3-Option与-result的相互转化"><a href="#3-Option与-result的相互转化" class="headerlink" title="3. Option与 result的相互转化"></a>3. Option与 result的相互转化</h4><p>a. Option-&gt;Result: ok_or<br>Some(v) 转为 Ok(v)<br>None 转为 Err(err)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn first(arr: &amp;[i32]) -&gt; Result&lt;&amp;i32, &amp;str&gt; &#123;</span><br><span class="line">    arr.get(0).ok_or(<span class="string">&quot;out of index&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b. Result-&gt;Option: err<br>Err(e) 转为 Some(e)<br>Ok(v) 转为 None</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">let</span> f=File::open(<span class="string">&quot;hello.txt&quot;</span>).err();</span><br><span class="line">    <span class="keyword">if</span> f.<span class="function"><span class="title">is_some</span></span>()&#123;</span><br><span class="line">        println!(<span class="string">&quot;no file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-panic-用于不可恢复错误"><a href="#4-panic-用于不可恢复错误" class="headerlink" title="4. panic!用于不可恢复错误"></a>4. panic!用于不可恢复错误</h4><p>a. 被动触发：</p>
<p>C语言中,尝试读取数据结构之后的值是未定义行为(undefined behavior)。你会得到任何对应数据结构中这个元素的内存位置的值,甚至是这些内存并不属于这个数据结构的情况。这被称为缓冲区溢出(buffer overread),并可能会导致安全漏洞,比如攻击者<br>可以像这样操作索引来读取储存在数据结构之后不被允许的数据。为了保护程序远离这类漏洞,如果尝试读取一个索引不存在的元素,Rust会停止执行并拒绝继续。尝试运行上面的程序会出现如下</p>
<p><img src="/../assets/img/14-4.jpg" alt="图14-4" title="14-4"></p>
<p>b. 主动调用：</p>
<p>对此,Rust为我们提供了panic!宏,当调用执行该宏时,程序会打印印出一个错误信息,展开报错点往前的函数调用堆栈,最后退出程序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    panic!(<span class="string">&quot;crash and burn&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>panic时的两种终止方式</p>
<p>栈展开(unwinding)(默认):Rust会回溯栈上数据和函数调用,因此也意味着更多的善后工作,好处是可以给出充分的报错信息和栈调用信息,便于事后的问题复盘, 直接终止(abort):不清理数据就直接退出程序,善后工作交与操作系统来负责</p>
<p>对于绝大多数用户,使用默认选择是最好的,但是当你关心最终编译出的二进制可执行文件大小时,那么可以尝试夫使用直接终止的防式,例如下面的配置修改Cargo.toml文件,实现在 release模式下遇到panic直接终止</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[profile.release]</span><br><span class="line">panic=<span class="string">&#x27;abort&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后在控制台执行 <code>RUST_BACKTRACE=1 cargo run –release</code></p>
<p><strong>Windows用户需要先在控制台执行 $Env:RUST_BACKTRACE&#x3D;1，再执行cargo run</strong></p>
<h3 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let a = 4;</span><br><span class="line">    let b = Some(1); // 假设 b 是 None</span><br><span class="line">    match call(a, b.unwrap_or(1)) &#123;</span><br><span class="line">        Ok(result) =&gt; println!(&quot;Result: &#123;&#125;&quot;, result),</span><br><span class="line">        Err(e) =&gt; println!(&quot;Error: &#123;&#125;&quot;, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn call(a: i32,b:i32) -&gt; Result&lt;f64,String&gt;&#123;</span><br><span class="line">    let r = divide(a, b);</span><br><span class="line">    let s = match r &#123;</span><br><span class="line">        Some(value) =&gt; sqrt(value),</span><br><span class="line">        None =&gt; return Err(&quot;Division by zero&quot;.to_string()),</span><br><span class="line">    &#125;;</span><br><span class="line">    s.map_err(|e| match e &#123;</span><br><span class="line">        MathError::DivisionByZero =&gt; &quot;Division by zero&quot;.to_string(),</span><br><span class="line">        MathError::NegativeSquareRoot =&gt; &quot;Negative square root&quot;.to_string(),</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fn divide(a:i32,b:i32)-&gt;Option&lt;f64&gt;&#123;</span><br><span class="line">    if b!=0&#123;</span><br><span class="line">        Some(a as f64/b as f64)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        None</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub enum MathError&#123;</span><br><span class="line">    DivisionByZero,</span><br><span class="line">    NegativeSquareRoot,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn sqrt(x:f64) -&gt;Result&lt;f64,MathError&gt;&#123;</span><br><span class="line">    if x&lt;0.0 &#123;</span><br><span class="line">        Err(MathError::NegativeSquareRoot)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        Ok(x.sqrt())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/28/rust14/" data-id="cm1l4o57u0000k4uy82xz2co1" data-title="rust 学习笔记十四 Rust 的返回值与错误处理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust13" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/24/rust13/" class="article-date">
  <time class="dt-published" datetime="2024-09-23T17:27:48.596Z" itemprop="datePublished">2024-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/24/rust13/">rust 学习笔记十三 Rust 中的集合</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Rust中的集合主要分为两类， Vector和HashMap</p>
<h3 id="（一）Vector"><a href="#（一）Vector" class="headerlink" title="（一）Vector"></a>（一）Vector</h3><h4 id="1-什么是Vec"><a href="#1-什么是Vec" class="headerlink" title="1.什么是Vec"></a>1.什么是Vec</h4><p>Vec是一个<strong>动态数组,可以根据需要动态增长和缩小</strong>。适用于需要按顺序存储数据的场景</p>
<h4 id="2-Vec的基本操作"><a href="#2-Vec的基本操作" class="headerlink" title="2.Vec的基本操作"></a>2.Vec的基本操作</h4><p>a.创建和初始化</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    //创建空vec</span><br><span class="line">    <span class="built_in">let</span> v : Vec&lt;i32&gt; = Vec::new();</span><br><span class="line"></span><br><span class="line">    //使用宏来创建vec</span><br><span class="line">    <span class="built_in">let</span> v = vec![1,2,3,4,5];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>b.添加元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">let</span> mut v : Vec&lt;i32&gt; = Vec::new();</span><br><span class="line">v.push(1);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先将其改为mut，然后向其中push即可</p>
<p>c.访问元素</p>
<p>可以使用<strong>直接引用</strong>访问：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> first: &amp;i32 = &amp;v[0];</span><br></pre></td></tr></table></figure>

<p>也可以使用<strong>get方法</strong>进行获取</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">match v.get(0) &#123;</span><br><span class="line">    Some(i) =&gt; &#123;&#125;,</span><br><span class="line">    _=&gt;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为get 获取到的元素是option类型的，所以需要match进行解构</p>
<p>但是第一种方法当访问的元素下标超出了数组长度时会panic</p>
<p>d.修改元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v[0] = 10;</span><br></pre></td></tr></table></figure>

<p>首先也需要声明数组为mut，然后直接对对应元素赋值就行</p>
<p>e.遍历元素</p>
<p>引用遍历：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">        println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不使用引用直接遍历会<strong>导致所有权发生转移</strong></p>
<h4 id="3-Vec的进阶用法"><a href="#3-Vec的进阶用法" class="headerlink" title="3.Vec的进阶用法"></a>3.Vec的进阶用法</h4><p>a. 使用枚举存储多种类型</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum SpreadheetCell &#123;</span><br><span class="line">    Int(i32),</span><br><span class="line">    Float(f64),</span><br><span class="line">    Test(String)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b. 容量与重新分配</p>
<p><img src="/../assets/img/13-1.jpg" alt="图13-1" title="13-1"></p>
<p>可以发现，在向数组中push 元素前后，数组的容量<strong>并没有发生变化</strong>，都等于初始化时设定的容量，因为当向数组中添加的元素长度小于此值时，数组并不会扩容，<strong>如果我们设置初始容量为0，就会发现每次push元素都会导致容量的扩张</strong></p>
<h4 id="4-Vec的常见陷阱"><a href="#4-Vec的常见陷阱" class="headerlink" title="4.Vec的常见陷阱"></a>4.Vec的常见陷阱</h4><p>a. 不安全的索引访问</p>
<p>指索引下标不能超过数组长度-1</p>
<p>b. 可变引用与不可变引用的混用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> mut v = vec![1,2,3,4,5];</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> first = &amp;v[0];</span><br><span class="line"></span><br><span class="line">v.push(4);</span><br><span class="line"></span><br><span class="line">println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,first);</span><br></pre></td></tr></table></figure>

<p>在这种情况下，会报错所有权发生了转移，不再属于first.无法打印，因为<strong>first是动态数组的非可变引用，而v是动态数组的可变引用， 理论上可变引用和非可变引用不能同时存在</strong></p>
<p>要解决这个问题，可以将</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> mut v = vec![1,2,3,4,5];</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">let</span> first = &amp;v[0];</span><br><span class="line">    println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v.push(4);</span><br></pre></td></tr></table></figure>

<p>不可变引用部分的代码单独放到一个作用域中</p>
<h3 id="（二）HashMap"><a href="#（二）HashMap" class="headerlink" title="（二）	HashMap"></a>（二）	HashMap</h3><h4 id="1-什么是HashMap"><a href="#1-什么是HashMap" class="headerlink" title="1.什么是HashMap"></a>1.什么是HashMap</h4><p>HashMap是一个键值对(key-value)存储的数据结构, 适用于<strong>需要快速查找数据的场景</strong>,（时间复杂度O(1)）</p>
<h4 id="2-HashMap的基本操作"><a href="#2-HashMap的基本操作" class="headerlink" title="2. HashMap的基本操作"></a>2. HashMap的基本操作</h4><p>a.创建和初始化</p>
<p><img src="/../assets/img/13-2.jpg" alt="图13-2" title="13-2"></p>
<p>b.访问元素</p>
<p><img src="/../assets/img/13-3.jpg" alt="图13-3" title="13-3"></p>
<p>可以看出HashMap的get函数需要传入key的引用，而且<strong>得到的元素是Option类型，需要通过match解析</strong></p>
<p>c.遍历元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (team, score) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>,team,score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hashmap的引用自身实现了一个<strong>迭代器</strong></p>
<h4 id="3-HashMap的进阶用法"><a href="#3-HashMap的进阶用法" class="headerlink" title="3. HashMap的进阶用法"></a>3. HashMap的进阶用法</h4><p>a.更新哈希表</p>
<p><img src="/../assets/img/13-4.jpg" alt="图13-4" title="13-4"></p>
<p>由此可以看出更新HashMap也可以用insert</p>
<p><img src="/../assets/img/13-5.jpg" alt="图13-5" title="13-5"></p>
<p>由此可以看出更新HashMap也可以用entry（key）.or_insert(value)的格式进行更改，只不过当key存在时，值不会发生变化，当key不存在时，会进行添加，如果需要用这个函数对已知值进行修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> _entry = scores.entry(String::from(<span class="string">&quot;Red&quot;</span>)).or_insert(99);</span><br><span class="line"> *_entry *= 10;</span><br></pre></td></tr></table></figure>

<p>则需要先拿到对应值的引用（该函数的返回值就是对应值的引用），然后解构修改</p>
<p>b.合并哈希表</p>
<p><img src="/../assets/img/13-6.jpg" alt="图13-6" title="13-6"></p>
<h4 id="4-HashMap的常见陷阱"><a href="#4-HashMap的常见陷阱" class="headerlink" title="4. HashMap的常见陷阱"></a>4. HashMap的常见陷阱</h4><p>a. 哈希冲突</p>
<p><img src="/../assets/img/13-7.jpg" alt="图13-7" title="13-7"></p>
<p>由此可见，不同的两个值的hash是不一样的</p>
<p>b值的所有权问题</p>
<p><img src="/../assets/img/13-8.jpg" alt="图13-8" title="13-8"></p>
<p>由此可见，当参数被传入函数insert中之后，发生了所有权的转移，之前的参数将不再有效，此时如果需要继续使用参数，需要在传入函数时使用clone():</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.insert(field_name.clone(), field_value.clone());</span><br></pre></td></tr></table></figure>

<h3 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h3><ol>
<li>使用Vec实现一个简单的栈，实现一个简单的栈(后进先出,LIFO)数据结构,支持push、pop和peek操作。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[derive(Debug)]</span></span><br><span class="line">struct VecA&#123;</span><br><span class="line">    vec:Vec&lt;i32&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl VecA &#123;</span><br><span class="line">    fn new(vec:Vec&lt;i32&gt;) -&gt; VecA&#123;</span><br><span class="line">        VecA &#123; vec: vec &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn add(&amp;mut self, num: i32) &#123;</span><br><span class="line">        self.vec.push(num)</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    fn delete(&amp;mut self) -&gt; Option&lt;i32&gt;&#123;</span><br><span class="line">        self.vec.pop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn peek(&amp; self, index:usize) -&gt; Option&lt;&amp;i32&gt; &#123;</span><br><span class="line">        self.vec.get(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> mut rect1=VecA::new(vec![1,2,3]);</span><br><span class="line">    println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,rect1);</span><br><span class="line">    rect1.add(1);</span><br><span class="line">    println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,rect1);</span><br><span class="line">    <span class="built_in">let</span> s = rect1.delete();</span><br><span class="line">    match s &#123;</span><br><span class="line">        Some(value) =&gt; &#123;</span><br><span class="line">            println!(<span class="string">&quot;删除的最后一个元素是：&#123;&#125;&quot;</span>,value);</span><br><span class="line">        &#125;</span><br><span class="line">        None =&gt; &#123;println!(<span class="string">&quot;已经没有元素&quot;</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">let</span> num = rect1.peek(0);</span><br><span class="line">    match num &#123;</span><br><span class="line">        Some(value) =&gt; &#123;</span><br><span class="line">            println!(<span class="string">&quot;&#123;&#125;&quot;</span>,value);</span><br><span class="line">        &#125;</span><br><span class="line">        None =&gt; &#123;println!(<span class="string">&quot;不存在该元素&quot;</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2:使用HashMap实现一个字频统计器,编写一个程序,统计一个字符串中每个单词出现的频率。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> text = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">let</span> mut frequency_counter = HashMap::new();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> character <span class="keyword">in</span> text.<span class="function"><span class="title">chars</span></span>() &#123;</span><br><span class="line">            *frequency_counter.entry(character).or_insert(0) += 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (character, frequency) <span class="keyword">in</span> &amp;frequency_counter &#123;</span><br><span class="line">        println!(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, character, frequency);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>综合练习:使用Vec和HashMap实现一个简单的书籍库存管理系统</li>
</ol>
<p>实现一个书籍库存管理系统,可以添加书籍、查询库存、更新库存以及删除书籍</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">struct BookInventory &#123;</span><br><span class="line">    inventory: HashMap&lt;String, i32&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl BookInventory &#123;</span><br><span class="line">    fn new() -&gt; BookInventory &#123;</span><br><span class="line">        BookInventory &#123;</span><br><span class="line">            inventory: HashMap::new(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn add_book(&amp;mut self, title: String, quantity: i32) &#123;</span><br><span class="line">        *self.inventory.entry(title).or_insert(0) += quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn get_count(&amp;self, title: &amp;str) -&gt; i32 &#123;</span><br><span class="line">        *self.inventory.get(title).unwrap_or(&amp;0)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn update_count(&amp;mut self, title: String, quantity: i32) &#123;</span><br><span class="line">        self.inventory.insert(title, quantity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn delete_book(&amp;mut self, title: &amp;str) &#123;</span><br><span class="line">        self.inventory.remove(title);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn list_books(&amp;self) &#123;</span><br><span class="line">        <span class="keyword">for</span> (title, &amp;quantity) <span class="keyword">in</span> &amp;self.inventory &#123;</span><br><span class="line">            println!(<span class="string">&quot;Title: &#123;&#125;, Quantity: &#123;&#125;&quot;</span>, title, quantity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> mut inventory = BookInventory::new();</span><br><span class="line"></span><br><span class="line">    inventory.add_book(<span class="string">&quot;The Rust Programming Language&quot;</span>.to_string(), 10);</span><br><span class="line">    inventory.add_book(<span class="string">&quot;Programming Rust&quot;</span>.to_string(), 5);</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;Initial inventory:&quot;</span>);</span><br><span class="line">    inventory.list_books();</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;\nStock count for &#x27;The Rust Programming Language&#x27;:&quot;</span>);</span><br><span class="line">    println!(<span class="string">&quot;Count: &#123;&#125;&quot;</span>, inventory.get_count(<span class="string">&quot;The Rust Programming Language&quot;</span>));</span><br><span class="line"></span><br><span class="line">    inventory.update_count(<span class="string">&quot;Programming Rust&quot;</span>.to_string(), 10);</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;\nUpdated inventory:&quot;</span>);</span><br><span class="line">    inventory.list_books();</span><br><span class="line"></span><br><span class="line">    inventory.delete_book(<span class="string">&quot;Programming Rust&quot;</span>);</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;\nFinal inventory:&quot;</span>);</span><br><span class="line">    inventory.list_books();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/24/rust13/" data-id="cm1gj9sqq0000x0uy0izleek2" data-title="rust 学习笔记十三 Rust 中的集合" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust12" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/21/rust12/" class="article-date">
  <time class="dt-published" datetime="2024-09-21T09:29:21.620Z" itemprop="datePublished">2024-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/21/rust12/">rust 学习笔记十三 Rust 中的集合</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Rust中的集合主要分为两类， Vector和HashMap</p>
<h3 id="（一）Vector"><a href="#（一）Vector" class="headerlink" title="（一）Vector"></a>（一）Vector</h3><p>什么是模式匹配:模式匹配是一种强大的功能,可以检查数据的结构并进行相应操作。</p>
<p>为什么使用模式匹配:提高代码的可读性和简洁性,减少错误,尤其是在处理复杂数据结构时。</p>
<p>举例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> number = 13;</span><br><span class="line">    match number &#123;</span><br><span class="line">    1=&gt;println!(<span class="string">&quot;One!&quot;</span>),</span><br><span class="line">    2=&gt;println!(<span class="string">&quot;Two!&quot;</span>),</span><br><span class="line">    3=&gt;println! (<span class="string">&quot;Three!&quot;</span>),</span><br><span class="line">    _=&gt;println!(<span class="string">&quot;Something else!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（二）模式匹配的各种模式"><a href="#（二）模式匹配的各种模式" class="headerlink" title="（二）模式匹配的各种模式"></a>（二）模式匹配的各种模式</h3><p>1.字面量模式</p>
<p>最为常见，上面举的基础例子就是字面量模式，<strong>必须穷举</strong>,列出所有可能性,通常与通配符模式搭配使用</p>
<p>2.变量模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> x= 42;</span><br><span class="line">match x&#123;</span><br><span class="line">    var =&gt; println!(<span class="string">&quot;The value is:&#123;&#125;&quot;</span>,var),</span><br><span class="line">&#125;</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,x);</span><br></pre></td></tr></table></figure>

<p>当变量为i32类型时，可以正常工作，当变量为没实现Copy trait的String类型时,存在报错：</p>
<p><img src="/../assets/img/12-1.jpg" alt="图12-1" title="12-1"></p>
<p>因为发生了所有权的转移</p>
<p>3.通配符模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">match x&#123;</span><br><span class="line">_=&gt; println!(<span class="string">&quot;Any value&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.结构模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    struct Point&#123;x:i32,y:i32&#125;</span><br><span class="line">    <span class="built_in">let</span> p = Point&#123;x:0,y:7&#125;;</span><br><span class="line">    match p &#123;</span><br><span class="line">        Point&#123;x,y:0&#125; =&gt; println!(<span class="string">&quot;On the x axis at &#123;&#125;&quot;</span>,x),</span><br><span class="line">        Point&#123;x:0,y&#125; =&gt; println!(<span class="string">&quot;On the y axis at &#123;&#125;&quot;</span>,y),</span><br><span class="line">        Point&#123;x,y&#125;=&gt;println!(<span class="string">&quot;On neither axis:(&#123;&#125;,&#123;&#125;)&quot;</span>,x,y),</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将会在第一个匹配到的项中输出,其余的元组模式、枚举模式、解构模式都与之类似,需要在匹配项中解构</p>
<p>5.守卫与绑定</p>
<p>a.守卫:在模式匹配中,可以使用守卫来添加额外的条件判断</p>
<p><img src="/../assets/img/12-3.jpg" alt="图12-3" title="12-3"></p>
<p>b.绑定:在模式匹配中,可以使用绑定来将模式中的值绑定到变量上</p>
<p><img src="/../assets/img/12-2.jpg" alt="图12-2" title="12-2"></p>
<p>使用一个@可以规定范围,再举例一个比较复杂的枚举绑定模式：</p>
<p><img src="/../assets/img/12-4.jpg" alt="图12-4" title="12-4"></p>
<h3 id="（三）应用场景"><a href="#（三）应用场景" class="headerlink" title="（三）应用场景"></a>（三）应用场景</h3><p>1.处理错误</p>
<p>原本返回Result的函数写法是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn divide(a:i32,b:i32)-&gt;Result&lt;i32,String&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span> b==0&#123;</span><br><span class="line">        Err(String::from(<span class="string">&quot;Cannotdivide by zero&quot;</span>))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Ok(a/b)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以改为match,更易读：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">match divide(4,2)&#123;</span><br><span class="line">    Ok(result)=&gt; println!(<span class="string">&quot;Result is &#123;&#125;&quot;</span>, result),</span><br><span class="line">    Err(e) =&gt; println!(<span class="string">&quot;Error:&#123;&#125;&quot;</span>,e),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>解析命令行参数</li>
<li>解析配置文件</li>
<li>解析数据包</li>
<li>解析XML或JSON等数据格式</li>
</ol>
<h3 id="（四）高级模式匹配技巧"><a href="#（四）高级模式匹配技巧" class="headerlink" title="（四）高级模式匹配技巧"></a>（四）高级模式匹配技巧</h3><p>1.嵌套模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum Message &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move&#123;x:i32,y:i32&#125;,</span><br><span class="line">    Write(String),</span><br><span class="line">    ChangeColor(i32,i32,i32),</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> msg = Message::ChangeColor(0,160,255);</span><br><span class="line">match msg &#123;</span><br><span class="line">    Message::ChangeColor(r,g,b)=&gt;println!(<span class="string">&quot;Change the color to red &#123;&#125;, green &#123;&#125;,and blue&#123;&#125;&quot;</span>,r,g,b),</span><br><span class="line">    _=&gt;&#123;&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>2.模式匹配与迭代器:结合iter和match使用</p>
<p><img src="/../assets/img/12-5.jpg" alt="图12-5" title="12-5"></p>
<p>可见将vec1和 vec2的对应元素进行了匹配</p>
<p>3.if let 和 while let:</p>
<p>简化单个模式匹配</p>
<p><img src="/../assets/img/12-7.jpg" alt="图12-7" title="12-7"></p>
<p>4.ref 和 mut ref</p>
<p>使用场景：</p>
<p>借用数据而不转移所有权:在某些情况下,你只需要借用数据而不是转移其所有权。例如在递归数据结构中,借用数据可以避免所有权转移带来的复杂性。</p>
<p>对数据进行修改:使用ref mut可以在模式匹配时对数据进行修改,而无需转移所有权。</p>
<p><img src="/../assets/img/12-6.jpg" alt="图12-6" title="12-6"></p>
<p>附加：假设你有一个包含用户信息的JSON字符串:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;nane&quot;</span>:<span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: 30,</span><br><span class="line">    <span class="string">&quot;email&quot;</span>: <span class="string">&quot;alicefexanple.con&quot;</span>,</span><br><span class="line">    <span class="string">&quot;address&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;street&quot;</span>: <span class="string">&quot;123 Main St&quot;</span>,</span><br><span class="line">        <span class="string">&quot;city&quot;</span>:<span class="string">&quot;Wonderland&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;phone_numbers&quot;</span>: [<span class="string">&quot;123-456-7890&quot;</span>, <span class="string">&quot;987-654-3210&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 serde_json库解析JSON字符串, 使用模式匹配提取JSON对象中的不同字段, 处理不同类型的数据(字符串、数字、数组、嵌套对象等):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">use serde_json::&#123;Value, Error&#125;;</span><br><span class="line"></span><br><span class="line">fn main() -&gt; Result&lt;(), Error&gt; &#123;</span><br><span class="line">    // JSON 字符串</span><br><span class="line">    <span class="built_in">let</span> json_str = r#<span class="string">&quot;</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;</span>name<span class="string">&quot;: &quot;</span>Alice<span class="string">&quot;,</span></span><br><span class="line"><span class="string">            &quot;</span>age<span class="string">&quot;: 30,</span></span><br><span class="line"><span class="string">            &quot;</span>email<span class="string">&quot;: &quot;</span>alice@example.com<span class="string">&quot;,</span></span><br><span class="line"><span class="string">            &quot;</span>address<span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">                &quot;</span>street<span class="string">&quot;: &quot;</span>123 Main St<span class="string">&quot;,</span></span><br><span class="line"><span class="string">                &quot;</span>city<span class="string">&quot;: &quot;</span>Wonderland<span class="string">&quot;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            &quot;</span>phone_numbers<span class="string">&quot;: [&quot;</span>123-456-7890<span class="string">&quot;, &quot;</span>987-654-3210<span class="string">&quot;]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &quot;</span>#;</span><br><span class="line"></span><br><span class="line">    // 解析 JSON 字符串</span><br><span class="line">    <span class="built_in">let</span> v: Value = serde_json::from_str(json_str)?;</span><br><span class="line">    println!(<span class="string">&quot;aaaa&#123;:?&#125;&quot;</span>,v);</span><br><span class="line">    // 使用模式匹配提取字段</span><br><span class="line">    match v &#123;</span><br><span class="line">        // 匹配嵌套对象</span><br><span class="line">        Value::Object(m) =&gt; &#123;</span><br><span class="line">            // 提取字符串字段</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">let</span> Some(name) = m.get(<span class="string">&quot;name&quot;</span>).and_then(Value::as_str) &#123;</span><br><span class="line">                println!(<span class="string">&quot;Name: &#123;&#125;&quot;</span>, name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">let</span> Some(email) = m.get(<span class="string">&quot;email&quot;</span>).and_then(Value::as_str) &#123;</span><br><span class="line">                println!(<span class="string">&quot;Email: &#123;&#125;&quot;</span>, email);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 提取数字字段</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">let</span> Some(age) = m.get(<span class="string">&quot;age&quot;</span>).and_then(Value::as_i64) &#123;</span><br><span class="line">                println!(<span class="string">&quot;Age: &#123;&#125;&quot;</span>, age);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 提取嵌套对象</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">let</span> Some(address) = m.get(<span class="string">&quot;address&quot;</span>) &#123;</span><br><span class="line">                match address &#123;</span><br><span class="line">                    Value::Object(addr) =&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">let</span> Some(street) = addr.get(<span class="string">&quot;street&quot;</span>).and_then(Value::as_str) &#123;</span><br><span class="line">                            println!(<span class="string">&quot;Street: &#123;&#125;&quot;</span>, street);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">let</span> Some(city) = addr.get(<span class="string">&quot;city&quot;</span>).and_then(Value::as_str) &#123;</span><br><span class="line">                            println!(<span class="string">&quot;City: &#123;&#125;&quot;</span>, city);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    _ =&gt; println!(<span class="string">&quot;Address is not an object&quot;</span>),</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 提取数组字段</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">let</span> Some(phone_numbers) = m.get(<span class="string">&quot;phone_numbers&quot;</span>) &#123;</span><br><span class="line">                match phone_numbers &#123;</span><br><span class="line">                    Value::Array(nums) =&gt; &#123;</span><br><span class="line">                        println!(<span class="string">&quot;Phone numbers:&quot;</span>);</span><br><span class="line">                        <span class="keyword">for</span> num <span class="keyword">in</span> nums &#123;</span><br><span class="line">                            <span class="keyword">if</span> <span class="built_in">let</span> Some(n) = num.<span class="function"><span class="title">as_str</span></span>() &#123;</span><br><span class="line">                                println!(<span class="string">&quot;  &#123;&#125;&quot;</span>, n);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    _ =&gt; println!(<span class="string">&quot;Phone numbers are not an array&quot;</span>),</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; println!(<span class="string">&quot;JSON is not an object&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
























      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/21/rust12/" data-id="cm1bybu85000020uy38i6b4c5" data-title="rust 学习笔记十三 Rust 中的集合" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust11" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/20/rust11/" class="article-date">
  <time class="dt-published" datetime="2024-09-19T16:20:24.066Z" itemprop="datePublished">2024-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/20/rust11/">rust 学习笔记十一 Rust 中的结构体</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）结构体的定义"><a href="#（一）结构体的定义" class="headerlink" title="（一）结构体的定义"></a>（一）结构体的定义</h3><p>使用struct关键字并为整个结构体提供一个名字，结构体的定义的位置没有要求,实例化的作用域在定义的范围内即可，大括号中,定义每一部分数据的名字和类型,称为字段(field)<br>使用逗号分隔每个字段</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width:u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有以下注意事项：</p>
<p>1、初始化结构体时<strong>每一个字段都必须初始化</strong></p>
<p>2、字段赋值顺序和定义顺序<strong>不需要一致</strong></p>
<p>3、字段名使用逗号分局</p>
<p>4、结构体中变量名和实际变量名一样的时候，可以只写一个</p>
<p>如果两个结构体实例的属性高度重合，也可以选择复用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">let</span> user2 = User&#123;</span><br><span class="line">    email:String::from(<span class="string">&quot;someone2@example.com&quot;</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种方法叫结构体更新语法</p>
<p>RUST的访问：通过实例. 属性名的方式，修改：需要将实例修改为<strong>mut</strong></p>
<h3 id="（二）结构体分类"><a href="#（二）结构体分类" class="headerlink" title="（二）结构体分类"></a>（二）结构体分类</h3><p>1.元组结构体(TupleStruct)</p>
<p>结构体必须要有名称,但是结构体的字段可以没有名称,这种结构体长得很像元组,因此被称为元组结构体，元组结构体<strong>希望有一个整体名称,但是又不关心里面字段的的名称</strong>时将非常有用.</p>
<p>例如Point元组结构体,众所周知3D点是(x,y,z)形式的坐标点,因此我们无需再为内部的字段逐一命名为:x,y,z</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Color(i32,i32,i32);</span><br><span class="line">struct Point(i32,i32,i32);</span><br><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">let</span> black=Color(0,0,0);</span><br><span class="line">    <span class="built_in">let</span> origin=Point(0,0,0);</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,black.0,origin.1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.单元结构体(Unit-like Struct)</p>
<p>如果你定义一个类型,但是<strong>不关心该类型的内容,只关心它的行为</strong>时,就可以使用单元结构体,定义AlwaysEqual,我们使用 struct关键字,接着是我们想要的名称,然后是一个分号<br>实例化不需要花括号或圆括号!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct AlwaysEqual;</span><br><span class="line"><span class="built_in">let</span> subject=AlwaysEqual;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（三）所有权"><a href="#（三）所有权" class="headerlink" title="（三）	所有权"></a>（三）	所有权</h3><p><img src="/../assets/img/11-1.jpg" alt="图11-1" title="11-1"></p>
<p><img src="/../assets/img/11-2.jpg" alt="图11-2" title="11-2"></p>
<p>从上面两个例子可以看出：对struct中的两个不同属性进行赋值有不同结果，active仍然可以正常打印但是email却会报错，这是因为active是bool类型，实现了copy trait，赋值过程并不会发生所有权的移动，但email 却是没有实现copy特性的类型，所以<strong>发生了所有权的转移</strong>.</p>
<p><img src="/../assets/img/11-3.jpg" alt="图11-3" title="11-3"></p>
<p>在这个例子中，当结构体中有一个元素发生了所有权的转移，之后将这个结构体作为参数进行传递时，也会报错，因此可以得出结论：<strong>一旦字结构体中一个字段发生了所有权移动,那么整个结构体就不能再被腻值了</strong>，同样，在前文中提到的结构体实例复用，如果发生了未实现copy trait类型的值的复用，也会发生所有权转移：</p>
<p><img src="/../assets/img/11-4.jpg" alt="图11-4" title="11-4"></p>
<p>如果我们将类型String 替换为 &amp;str,是不是就可以实现赋值了呢，发现有报错提示：需要生命周期参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct User&lt;<span class="string">&#x27;a&gt;&#123;</span></span><br><span class="line"><span class="string">    active:bool,</span></span><br><span class="line"><span class="string">    username: &amp;&#x27;</span>a str,</span><br><span class="line">    email:&amp;<span class="string">&#x27;a str,</span></span><br><span class="line"><span class="string">    sign_in_count: u64,</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>根据提示添加生命周期参数后,可以正常执行</p>
<h3 id="（四）方法"><a href="#（四）方法" class="headerlink" title="（四）	方法"></a>（四）	方法</h3><p>定义方法：使用<strong>fn关键字和名称声明</strong>,可以拥有参数和返回值,同时包含在某处调用该方法时会执行的代码。方法与函数是不同的,因为它们<strong>在结构体的上下文中被定义</strong>,并且它门<strong>第一个参数总是self,它代表调用该方法的结构体实例.</strong></p>
<p>定义方法和enum类似:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#[derive(Debug)]</span></span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line">impl Rectangle &#123;</span><br><span class="line">fn area(&amp;self) -&gt; u32 &#123;</span><br><span class="line">self.width * self.height</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line"><span class="built_in">let</span> rect1=Rectangle&#123;width:30,height:50&#125;;</span><br><span class="line">    println!(<span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">    rect1.area());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时要修改实例的值的话，也可以在方法中使用可变引用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#[derive(Debug)]</span></span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line">impl Rectangle &#123;</span><br><span class="line">    fn area(&amp;self) -&gt; u32 &#123;</span><br><span class="line">        self.width * self.height</span><br><span class="line">    &#125;</span><br><span class="line">    fn setWidth(&amp;mut self, newWidth:u32) &#123;</span><br><span class="line">        self.width = newWidth; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line"><span class="built_in">let</span> mut rect1=Rectangle&#123;width:30,height:50&#125;;</span><br><span class="line">    rect1.setWidth(20);</span><br><span class="line">    println!(<span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">    rect1.area());</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了这种自带实例引用的方法外，还有一种不带实例引用的方法，和enum中的静态方法一样，只能通过结构体名称::方法名的格式来调用：如下：</p>
<p><img src="/../assets/img/11-5.jpg" alt="图11-5" title="11-5"></p>
<h3 id="（五）实现trait"><a href="#（五）实现trait" class="headerlink" title="（五）	实现trait"></a>（五）	实现trait</h3><p>为类型实现特征</p>
<p>如果不同的类型具有相同的行为,那么我们就可以定义一个特征,然后为这些类型实现该特征,定义特征是把一些方法组合在一起,目的是定义一个实现某些目际所必需的行为的集合.</p>
<p>像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">trait Shape&#123;</span><br><span class="line">    fn area(&amp;self) -&gt; f64;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#[derive(Debug)]</span></span><br><span class="line"></span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width:u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct  Circle &#123;</span><br><span class="line">    r: f64</span><br><span class="line">&#125;</span><br><span class="line">impl Shape <span class="keyword">for</span> Rectangle &#123;</span><br><span class="line">    fn area(&amp;self) -&gt; f64 &#123;</span><br><span class="line">        (self.width * self.height) as f64</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Shape <span class="keyword">for</span>  Circle&#123;</span><br><span class="line">    fn area(&amp;self) -&gt; f64 &#123;</span><br><span class="line">        (self.r * self.r * 3.14) as f64</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn print_area(shape: &amp;impl Shape)&#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,shape.area());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> cir1 = Circle&#123;r:1.0&#125;;</span><br><span class="line">    print_area(&amp;cir1);</span><br><span class="line">    <span class="built_in">let</span> rec1 = Rectangle&#123;width:1, height:2&#125;;</span><br><span class="line">    print_area(&amp;rec1);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>类型Circle和 类型 Rectangle 都需要实现求面积的方法，于是写了一个名为Shape的trait，其中的方法area需要在Circle 和 Rectangle分别实现，最后在函数print_area中传入结构体实例的引用，会自动根据类型匹配到对用的方法执行</p>
<h3 id="（六）打印结构体"><a href="#（六）打印结构体" class="headerlink" title="（六）	打印结构体"></a>（六）	打印结构体</h3><p>直接使用如下方式进行打印：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> cir1 = Circle&#123;r:1.0&#125;;</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,cir1);</span><br></pre></td></tr></table></figure>

<p>依然是报错：该类型没有实现display这个trait</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,cir1);</span><br></pre></td></tr></table></figure>

<p>改为这样还是报错：该类型没有实现debug这个trait,解决办法是在相应的结构体定义上方加上<code>#[derive(Debug)]</code>派生</p>
<p>我们也可以不使用派生而是自己实现这些特征：</p>
<p>a.Display:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">impl Display <span class="keyword">for</span> Rectangle &#123;</span><br><span class="line">    fn <span class="built_in">fmt</span>(&amp;self, f: &amp;mut std::<span class="built_in">fmt</span>::Formatter&lt;<span class="string">&#x27;_&gt;) -&gt; std::fmt::Result &#123;</span></span><br><span class="line"><span class="string">        for _ in 0..self.height &#123;</span></span><br><span class="line"><span class="string">            let mut s =  String::new();</span></span><br><span class="line"><span class="string">            for _ in 0..self.width &#123;</span></span><br><span class="line"><span class="string">                s.push(&#x27;</span>#<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            write!(f, &quot;&#123;&#125;\n&quot;, s);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return  Ok(());</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>b.Debug:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">impl  Debug <span class="keyword">for</span> Circle &#123;</span><br><span class="line">    fn <span class="built_in">fmt</span>(&amp;self, f: &amp;mut std::<span class="built_in">fmt</span>::Formatter&lt;<span class="string">&#x27;_&gt;) -&gt; std::fmt::Result &#123;</span></span><br><span class="line"><span class="string">        let _ = f.debug_struct(&quot;Circle&quot;)</span></span><br><span class="line"><span class="string">        .field(&quot;r&quot;, &amp;self.r)</span></span><br><span class="line"><span class="string">        .finish();</span></span><br><span class="line"><span class="string">        return  Ok(());</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>










      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/20/rust11/" data-id="cm19i4pqj0000louya52f0m2m" data-title="rust 学习笔记十一 Rust 中的结构体" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust10" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/15/rust10/" class="article-date">
  <time class="dt-published" datetime="2024-09-15T14:24:06.288Z" itemprop="datePublished">2024-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/15/rust10/">rust 学习笔记十 Rust 中的ENUM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）概览"><a href="#（一）概览" class="headerlink" title="（一）概览"></a>（一）概览</h3><p>rust中创建字符串主要有以下两种方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    enum Pets&#123;</span><br><span class="line">        Bird,</span><br><span class="line">        Cat(String),</span><br><span class="line">        Dog&#123; name:String, age:usize&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">let</span> bird= Pets::Bird;</span><br><span class="line">    <span class="built_in">let</span> <span class="built_in">cat</span> = Pets::Cat(<span class="string">&quot;jack&quot;</span>.to_string());</span><br><span class="line">    <span class="built_in">let</span> dog = Pets::Dog &#123; name: <span class="string">&quot;tom&quot;</span>.to_string(), age: 18 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Enum中的元素可以没有任何参数，可以是带有一个参数的变体，也可以是有多个name声明的结构体</p>
<p>如果直接对初始化出来的元素进行打印：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println!(<span class="string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,bird, <span class="built_in">cat</span>, dog);</span><br></pre></td></tr></table></figure>

<p>会发现报错：没有实现debug trait，此时我们可以通过在代码上方直接添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[derive(Debug)]</span></span><br></pre></td></tr></table></figure>

<p>这样相当于在枚举中自动补全了debug trait.</p>
<p>可以为枚举实现一些方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">impl Pets &#123;</span><br><span class="line">    fn speak(&amp;self) &#123;</span><br><span class="line">        println!(<span class="string">&quot;speak&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的speak就叫做<strong>methods（方法）</strong>,其中第一个参数&amp;self是<strong>对当前这个枚举实例的引用</strong>, 然后枚举中的元素的实例可以调用这个方法：<code>dog.speak();</code></p>
<p>此外还有一种关联函数，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">impl Pets &#123;</span><br><span class="line">    fn <span class="function"><span class="title">log</span></span>() &#123;</span><br><span class="line">        println!(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这类函数参数中将不会再有枚举实例的引用，调用方法也和methods有区别，不再是通过枚举中元素的，而是直接通过<strong>枚举名称::静态方法</strong>名来调用：<code> Pets::log();</code></p>
<h3 id="二-用法"><a href="#二-用法" class="headerlink" title="(二) 用法"></a>(二) 用法</h3><p>1，比较</p>
<p>先看下面这个例子：</p>
<p><img src="/../assets/img/10-1.jpg" alt="图10-1" title="10-1"></p>
<p>bird 和 cat 是同一个枚举 Pets 的不同变体的实例，如果直接将这两个实例进行对比，会报错：<code>binary operation `==` cannot be applied to type `Pets</code>,在rust中，是不支持直接用等号来比较两个变体实例的，根据提示，<br><code>an implementation of `PartialEq` might be missing for `Pets`,consider annotating `Pets` with `#[derive(PartialEq)]`: </code>, 和刚才一样，在最前面添加一个<code>#[derive(PartialEq)]</code>进行补全，即可使用等号比较.</p>
<ol start="2">
<li>Match vs if let</li>
</ol>
<p>对于创建出来的变体实例，可以通过match判断其类型</p>
<p>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">match <span class="built_in">cat</span> &#123;</span><br><span class="line">    Pets::Cat(e) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Pets::Dog&#123;name, age&#125; =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Pets::Bird =&gt; todo!(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在匹配到对应类型时，可以直接访问其中的变量</p>
<p>同时match也适用于rust中的普通变量，比如可以用来匹配i32常数:</p>
<p><img src="/../assets/img/10-2.jpg" alt="图10-2" title="10-2"></p>
<p>但此时发现有报错：因为match要求列举完可能的所有情况，但我们无法将i32的所有可能值全部列举，所以可以在下面再加一种可能：</p>
<p>用<strong>下划线</strong>代替其余的所有可能</p>
<p><img src="/../assets/img/10-3.jpg" alt="图10-3" title="10-3"></p>
<p>而如果觉得每次都进行模糊匹配有点复杂，可以选择使用if let，便可以只关注需要匹配的类型：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">let</span> <span class="built_in">cat</span> = Pets::Cat &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是if let无法像match一样获取到匹配的参数.</p>
<h3 id="三-rust中的两大枚举"><a href="#三-rust中的两大枚举" class="headerlink" title="(三) rust中的两大枚举"></a>(三) rust中的两大枚举</h3><ol>
<li>Option</li>
</ol>
<p>示例如下：</p>
<p><img src="/../assets/img/10-4.jpg" alt="图10-4" title="10-4"></p>
<p>被分为<strong>some和none</strong>两种情况</p>
<p>如果存在一个map,如下:</p>
<p><img src="/../assets/img/10-5.jpg" alt="图10-5" title="10-5"></p>
<p>通过get获取其中的某个key,此时获得的是一个<strong>option</strong>类型的元素,我们将其进行match匹配:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">match a &#123;</span><br><span class="line">    Some(val)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    None =&gt;&#123; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，对于一个动态数组，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = vec![1,2,3,4];</span><br><span class="line"><span class="built_in">let</span> a = arr.iter().last();</span><br></pre></td></tr></table></figure>

<p>我们取出它的最后一个元素，根据提示，也是option类型，故也可以用match进行匹配</p>
<ol start="2">
<li>Result</li>
</ol>
<p>先看示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> num:Result&lt;usize, ()&gt; = Ok(1);</span><br><span class="line">match num &#123;</span><br><span class="line">    Ok(val)=&gt;&#123;&#125;,</span><br><span class="line">    Err(_)=&gt;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果同样使用match进行匹配，只不过其中的匹配项变成了<strong>Ok()和 Err()</strong></p>
<p>在Rust当中，可以声明函数的返回值为Result类型,比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() -&gt; Result&lt;(), ()&gt;&#123;</span><br><span class="line">    <span class="built_in">let</span> num: Result&lt;usize, ()&gt; = Ok(1);</span><br><span class="line">    match num &#123;</span><br><span class="line">        Ok(val)=&gt;&#123;&#125;</span><br><span class="line">        Err(_)=&gt;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而将&amp;str类型进行反序列化的parse函数返回值也是Result类型</p>
<ol start="3">
<li>Option  和  Result 的相互转换</li>
</ol>
<p>a.Option转result:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> opt = Some(42);</span><br><span class="line"><span class="built_in">let</span> result:Result&lt;i32, &amp;str&gt; = opt.ok_or(<span class="string">&quot;err&quot;</span>);</span><br><span class="line">assert_eq!(result, Ok(42));</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> none:Option&lt;i32&gt; = None;</span><br><span class="line"><span class="built_in">let</span> result:Result&lt;i32, &amp;str&gt; = none.ok_or(<span class="string">&quot;err&quot;</span>);</span><br><span class="line">assert_eq!(result, Err(<span class="string">&quot;err&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>其中第一个result走的是ok，所以得到的是Ok(42),第二个和or相匹配，得到的是Err(“err”)</p>
<p>b.Result转option</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> res:Result&lt;i32, &amp;str&gt; = Ok(1);</span><br><span class="line"><span class="built_in">let</span> option = res.ok();</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> res:Result&lt;i32, &amp;str&gt; = Err(<span class="string">&quot;err&quot;</span>);</span><br><span class="line"><span class="built_in">let</span> option = res.ok();</span><br></pre></td></tr></table></figure>

<p>如果是第二种情况，会转换成None,正常情况则是Some</p>
<p>4.常见api</p>
<p>a.可以通过map来遍历option:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> option = Some(1);</span><br><span class="line"><span class="built_in">let</span> b = option.map(|num| num + 1);</span><br></pre></td></tr></table></figure>

<p>b.如果需要多层match层层嵌套，会导致代码繁琐，易读性不高，所以有语法糖，可以直接取出值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> option = Some(1);</span><br><span class="line"><span class="built_in">let</span> a= option.unwrap();</span><br></pre></td></tr></table></figure>

<p>但如果值是None,会panic，也可以使用expect:<code>let a = option.expect(“msg”);</code>可以传入默认值</p>
<p>c.or_else</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> option = Some(1);</span><br><span class="line"><span class="built_in">let</span> a = option.or_else(|| Some((<span class="number">3</span>)));</span><br></pre></td></tr></table></figure>

<p>返回值也是一个Some，用于优雅的处理可能为None的值，给一个默认值</p>
<p>d.mem::size_of::<T>() </p>
<p>mem::size_of::<T>() 函数返回类型 T 在当前平台上的内存大小（以字节为单位）</p>
<p>示例如下：</p>
<p><img src="/../assets/img/10-6.jpg" alt="图10-6" title="10-6"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/15/rust10/" data-id="cm13ta5d30000xsuy91ri6psf" data-title="rust 学习笔记十 Rust 中的ENUM" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust9" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/13/rust9/" class="article-date">
  <time class="dt-published" datetime="2024-09-13T14:48:45.404Z" itemprop="datePublished">2024-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/13/rust9/">rust 学习笔记九 Rust 中的字符串</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）创建字符串的方式"><a href="#（一）创建字符串的方式" class="headerlink" title="（一）	创建字符串的方式"></a>（一）	创建字符串的方式</h3><p>rust中创建字符串主要有以下两种方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> s = String::from(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> s = <span class="string">&quot;hello world2&quot;</span>;</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br></pre></td></tr></table></figure>

<p>其中，第二种直接引号创建的方式，叫<strong>字符串字面值</strong>,我们在编译时就知道其内容,最终字面值文本被直接硬编码进可执行文件，字符串字面量”hello world”就是<strong>str类型</strong>,它被硬编码进可执行程序的数据部分</p>
<p>既然我们已经存储了这个字符串,就需要一种方法来访问它:这就是<strong>切片引用</strong>&amp;str的意义所在，&amp;str是一种<strong>不可变引用</strong>,所以它没有所有权，str类型是硬编码进可执行文件,也<strong>无法被修改</strong>.</p>
<p>但如果我们需要对这种数据进行修改的时候，就需要用到第一种创建方法，String在rust中是一个复合数据类型,存储在<strong>堆上</strong>,定义如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pub struct String&#123;</span><br><span class="line">vec: Vec&lt;u8&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>意味string可改变的、并且<strong>拥有所有权</strong>的</p>
<p>总结一下二者区别:</p>
<p><strong>&amp;str</strong>:这是一个字符串切片,它是固定大小的,并且不能改变</p>
<p><strong>&amp;string</strong>:这是一个可增长的、可改变的、拥有所有权的、UTF-8编码的字符串类型。它通常用于需要改变或者增长字符串的情况</p>
<h3 id="（二）类型转换"><a href="#（二）类型转换" class="headerlink" title="（二）	类型转换"></a>（二）	类型转换</h3><p><img src="/../assets/img/9-1.jpg" alt="图9-1" title="9-1"></p>
<p>这其中发生了从u8数组到str的转换，但将数组的定义改为vec定义也可以：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> b = vec!(104, 101, 108, 108, 111);</span><br></pre></td></tr></table></figure>

<p>这是因为vector对其进行了隐式的类型转换，同样，也可以进行从str到utf8数组的转换</p>
<p><img src="/../assets/img/9-2.jpg" alt="图9-2" title="9-2"></p>
<p>如果需要进行str 和 string的相互转换：</p>
<p>从String类型转变为&amp;str是非常便捷的,而且<strong>无损的</strong>(性能无损,不会造成重写malloc或者数据移动),另外,由于Rust实现了自动解引用,那么&amp;String在必要的时候可以自动转换为&amp;str,因此在很多函数中,如果接收参数是字符串的引用,通常会采用&amp;str作为入参,以获取更好的数据兼容性<br>,字符串是UTF-8编码,因此需要保证索引的字节刚好落在<strong>字符的边界</strong></p>
<p><img src="/../assets/img/9-3.jpg" alt="图9-3" title="9-3"></p>
<p>如果需要从&amp;str转为string则需要用 String::from进行包裹：</p>
<p><img src="/../assets/img/9-4.jpg" alt="图9-4" title="9-4"></p>
<p>但是这样做对内存消耗较大，因为&amp;str类型的数据是被硬编码在可执行文件中的，但是转换为string类型需要<strong>重新到堆上申请内存</strong></p>
<h3 id="（三）常见修改String的方法"><a href="#（三）常见修改String的方法" class="headerlink" title="（三）	常见修改String的方法"></a>（三）	常见修改String的方法</h3><ol>
<li>追加</li>
</ol>
<p>a.使用<strong>push()<strong>方法追加字符char<br>b.使用</strong>push_str()<strong>方法追加字符串字面量<br>两个方法都是在原有的字符串上追加,并</strong>不会返回新的字符串</strong><br>字符串追加操作要修改原来的字符串,则该字符串必须是可变的,即字符串变量必须由<strong>mut</strong>关键字修饰</p>
<p><img src="/../assets/img/9-5.jpg" alt="图9-5" title="9-5"></p>
<ol start="2">
<li>插入</li>
</ol>
<p>a.使用<strong>insert()<strong>方法插入单个字符char<br>b.使用</strong>insert_str()<strong>方法插入字符串字面量<br>这俩方法需要传入两个参数,第一个参数是字符(串)插入位置的索引,索引从0开始计数;第二个参数是要插入的字符<br>如果越界则会发生错误<br>如果参数所给的位置不是</strong>合法的字符边界</strong>,也会发生错误<br>由于字符串插入操作要修改原来的字符串,则该字符串必须是可变的,即字符串变量必须由<strong>mut</strong>关键字修饰</p>
<p><img src="/../assets/img/9-6.jpg" alt="图9-6" title="9-6"></p>
<ol start="3">
<li>替换</li>
</ol>
<p>a. <strong>replace()<strong>方法接收两个参数,第一个参数是要被替换的字符串,第二个参数是新的字符串<br>该方法会替换所有匹配到的字符串<br>该方法是返回一个新的字符串,而不是操作原来的字符串,故不会修改原字符串，</strong>不需要mut修饰</strong></p>
<p><img src="/../assets/img/9-7.jpg" alt="图9-7" title="9-7"></p>
<p>b. <strong>replace_range()<strong>接收两个参数,第一个参数是要替换字符串的范围(Range),第二个参数是新的字符串<br>该方法是直接操作原来的字符串,不会返回新的字符串。该方去需要使用</strong>mut</strong>关键字修饰<br>如果range的范围大于&#x2F;小于新字符串的长度会因为不在<strong>合法边界</strong>而报错</p>
<p><img src="/../assets/img/9-8.jpg" alt="图9-8" title="9-8"></p>
<p>4.删除</p>
<p>a.pop<br><strong>删除并返回</strong>字符串的最后一个字符<br>其返回值是一个<strong>Option类型</strong>,如果字符串为空,则返回<br>该方法是直接操作原来的字符串</p>
<p><img src="/../assets/img/9-9.jpg" alt="图9-9" title="9-9"></p>
<p>b.remove<br>该方法是直接操作原来的字符串<br>其返回值是<strong>删除位置的字符串</strong><br>只接收一个参数,表示该字符<strong>起始索引位置</strong><br>方法是按照字节来处理字符串的,如果参数所给的位置不是<strong>合法的的字符边界</strong>,则会发生错误</p>
<p><img src="/../assets/img/9-10.jpg" alt="图9-10" title="9-10"></p>
<p>c.truncat<br>删除字符串中<strong>从指定位置开始到结尾的全部字符</strong><br>方法是按照字节来处理字符串的,如果参数所给的位置不是<strong>合法的字符边界</strong>,则会发生错误<br>该方法是直接操作原来的字符串</p>
<p><img src="/../assets/img/9-11.jpg" alt="图9-11" title="9-11"></p>
<p>d.clear<br>清空字符串<br>该方法是直接操作原来的字符串</p>
<p><img src="/../assets/img/9-12.jpg" alt="图9-12" title="9-12"></p>
<p>5.连接</p>
<p>a.使用+或者+&#x3D;连接字符串<br>这里add()方法的第二个参数必须为字符串的<strong>切片引用类型</strong><br>是返回一个新的字符串,所以变量声明可以<strong>不需要mut关键字修饰</strong></p>
<p><img src="/../assets/img/9-13.jpg" alt="图9-13" title="9-13"></p>
<p>b.使用format!连接字符串<br>format!的用法与 print!的用法类似</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/13/rust9/" data-id="cm10u4a4g0000e4uy9nle6pel" data-title="rust 学习笔记九 Rust 中的字符串" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/11/21/solana3/">solana 学习笔记三 Solana基础，账户与简单交互</a>
          </li>
        
          <li>
            <a href="/2024/11/17/solana2/">solana 学习笔记二 Solana开发入门</a>
          </li>
        
          <li>
            <a href="/2024/11/13/solana1/">solana 学习笔记一 Solana基础与环境搭建</a>
          </li>
        
          <li>
            <a href="/2024/11/09/rust25/">rust 学习笔记二十五 Rust中的共享内存</a>
          </li>
        
          <li>
            <a href="/2024/11/03/rust24/">rust 学习笔记二十四 Rust的并发</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Liu Canzhu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>