<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>canzhu&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="canzhu&#39;s blog">
<meta property="og:url" content="https://liucanzhu.github.io/page/3/index.html">
<meta property="og:site_name" content="canzhu&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liu Canzhu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="canzhu's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">canzhu&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://liucanzhu.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-rust11" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/20/rust11/" class="article-date">
  <time class="dt-published" datetime="2024-09-19T16:20:24.066Z" itemprop="datePublished">2024-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/20/rust11/">rust 学习笔记十一 Rust 中的结构体</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）结构体的定义"><a href="#（一）结构体的定义" class="headerlink" title="（一）结构体的定义"></a>（一）结构体的定义</h3><p>使用struct关键字并为整个结构体提供一个名字，结构体的定义的位置没有要求,实例化的作用域在定义的范围内即可，大括号中,定义每一部分数据的名字和类型,称为字段(field)<br>使用逗号分隔每个字段</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width:u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有以下注意事项：</p>
<p>1、初始化结构体时<strong>每一个字段都必须初始化</strong></p>
<p>2、字段赋值顺序和定义顺序<strong>不需要一致</strong></p>
<p>3、字段名使用逗号分局</p>
<p>4、结构体中变量名和实际变量名一样的时候，可以只写一个</p>
<p>如果两个结构体实例的属性高度重合，也可以选择复用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">let</span> user2 = User&#123;</span><br><span class="line">    email:String::from(<span class="string">&quot;someone2@example.com&quot;</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种方法叫结构体更新语法</p>
<p>RUST的访问：通过实例. 属性名的方式，修改：需要将实例修改为<strong>mut</strong></p>
<h3 id="（二）结构体分类"><a href="#（二）结构体分类" class="headerlink" title="（二）结构体分类"></a>（二）结构体分类</h3><p>1.元组结构体(TupleStruct)</p>
<p>结构体必须要有名称,但是结构体的字段可以没有名称,这种结构体长得很像元组,因此被称为元组结构体，元组结构体<strong>希望有一个整体名称,但是又不关心里面字段的的名称</strong>时将非常有用.</p>
<p>例如Point元组结构体,众所周知3D点是(x,y,z)形式的坐标点,因此我们无需再为内部的字段逐一命名为:x,y,z</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Color(i32,i32,i32);</span><br><span class="line">struct Point(i32,i32,i32);</span><br><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="built_in">let</span> black=Color(0,0,0);</span><br><span class="line">    <span class="built_in">let</span> origin=Point(0,0,0);</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,black.0,origin.1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.单元结构体(Unit-like Struct)</p>
<p>如果你定义一个类型,但是<strong>不关心该类型的内容,只关心它的行为</strong>时,就可以使用单元结构体,定义AlwaysEqual,我们使用 struct关键字,接着是我们想要的名称,然后是一个分号<br>实例化不需要花括号或圆括号!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct AlwaysEqual;</span><br><span class="line"><span class="built_in">let</span> subject=AlwaysEqual;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（三）所有权"><a href="#（三）所有权" class="headerlink" title="（三）	所有权"></a>（三）	所有权</h3><p><img src="/../assets/img/11-1.jpg" alt="图11-1" title="11-1"></p>
<p><img src="/../assets/img/11-2.jpg" alt="图11-2" title="11-2"></p>
<p>从上面两个例子可以看出：对struct中的两个不同属性进行赋值有不同结果，active仍然可以正常打印但是email却会报错，这是因为active是bool类型，实现了copy trait，赋值过程并不会发生所有权的移动，但email 却是没有实现copy特性的类型，所以<strong>发生了所有权的转移</strong>.</p>
<p><img src="/../assets/img/11-3.jpg" alt="图11-3" title="11-3"></p>
<p>在这个例子中，当结构体中有一个元素发生了所有权的转移，之后将这个结构体作为参数进行传递时，也会报错，因此可以得出结论：<strong>一旦字结构体中一个字段发生了所有权移动,那么整个结构体就不能再被腻值了</strong>，同样，在前文中提到的结构体实例复用，如果发生了未实现copy trait类型的值的复用，也会发生所有权转移：</p>
<p><img src="/../assets/img/11-4.jpg" alt="图11-4" title="11-4"></p>
<p>如果我们将类型String 替换为 &amp;str,是不是就可以实现赋值了呢，发现有报错提示：需要生命周期参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct User&lt;<span class="string">&#x27;a&gt;&#123;</span></span><br><span class="line"><span class="string">    active:bool,</span></span><br><span class="line"><span class="string">    username: &amp;&#x27;</span>a str,</span><br><span class="line">    email:&amp;<span class="string">&#x27;a str,</span></span><br><span class="line"><span class="string">    sign_in_count: u64,</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>根据提示添加生命周期参数后,可以正常执行</p>
<h3 id="（四）方法"><a href="#（四）方法" class="headerlink" title="（四）	方法"></a>（四）	方法</h3><p>定义方法：使用<strong>fn关键字和名称声明</strong>,可以拥有参数和返回值,同时包含在某处调用该方法时会执行的代码。方法与函数是不同的,因为它们<strong>在结构体的上下文中被定义</strong>,并且它门<strong>第一个参数总是self,它代表调用该方法的结构体实例.</strong></p>
<p>定义方法和enum类似:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#[derive(Debug)]</span></span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line">impl Rectangle &#123;</span><br><span class="line">fn area(&amp;self) -&gt; u32 &#123;</span><br><span class="line">self.width * self.height</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line"><span class="built_in">let</span> rect1=Rectangle&#123;width:30,height:50&#125;;</span><br><span class="line">    println!(<span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">    rect1.area());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时要修改实例的值的话，也可以在方法中使用可变引用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#[derive(Debug)]</span></span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line">impl Rectangle &#123;</span><br><span class="line">    fn area(&amp;self) -&gt; u32 &#123;</span><br><span class="line">        self.width * self.height</span><br><span class="line">    &#125;</span><br><span class="line">    fn setWidth(&amp;mut self, newWidth:u32) &#123;</span><br><span class="line">        self.width = newWidth; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line"><span class="built_in">let</span> mut rect1=Rectangle&#123;width:30,height:50&#125;;</span><br><span class="line">    rect1.setWidth(20);</span><br><span class="line">    println!(<span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">    rect1.area());</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了这种自带实例引用的方法外，还有一种不带实例引用的方法，和enum中的静态方法一样，只能通过结构体名称::方法名的格式来调用：如下：</p>
<p><img src="/../assets/img/11-5.jpg" alt="图11-5" title="11-5"></p>
<h3 id="（五）实现trait"><a href="#（五）实现trait" class="headerlink" title="（五）	实现trait"></a>（五）	实现trait</h3><p>为类型实现特征</p>
<p>如果不同的类型具有相同的行为,那么我们就可以定义一个特征,然后为这些类型实现该特征,定义特征是把一些方法组合在一起,目的是定义一个实现某些目际所必需的行为的集合.</p>
<p>像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">trait Shape&#123;</span><br><span class="line">    fn area(&amp;self) -&gt; f64;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#[derive(Debug)]</span></span><br><span class="line"></span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width:u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct  Circle &#123;</span><br><span class="line">    r: f64</span><br><span class="line">&#125;</span><br><span class="line">impl Shape <span class="keyword">for</span> Rectangle &#123;</span><br><span class="line">    fn area(&amp;self) -&gt; f64 &#123;</span><br><span class="line">        (self.width * self.height) as f64</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Shape <span class="keyword">for</span>  Circle&#123;</span><br><span class="line">    fn area(&amp;self) -&gt; f64 &#123;</span><br><span class="line">        (self.r * self.r * 3.14) as f64</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn print_area(shape: &amp;impl Shape)&#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,shape.area());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> cir1 = Circle&#123;r:1.0&#125;;</span><br><span class="line">    print_area(&amp;cir1);</span><br><span class="line">    <span class="built_in">let</span> rec1 = Rectangle&#123;width:1, height:2&#125;;</span><br><span class="line">    print_area(&amp;rec1);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>类型Circle和 类型 Rectangle 都需要实现求面积的方法，于是写了一个名为Shape的trait，其中的方法area需要在Circle 和 Rectangle分别实现，最后在函数print_area中传入结构体实例的引用，会自动根据类型匹配到对用的方法执行</p>
<h3 id="（六）打印结构体"><a href="#（六）打印结构体" class="headerlink" title="（六）	打印结构体"></a>（六）	打印结构体</h3><p>直接使用如下方式进行打印：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> cir1 = Circle&#123;r:1.0&#125;;</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,cir1);</span><br></pre></td></tr></table></figure>

<p>依然是报错：该类型没有实现display这个trait</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,cir1);</span><br></pre></td></tr></table></figure>

<p>改为这样还是报错：该类型没有实现debug这个trait,解决办法是在相应的结构体定义上方加上<code>#[derive(Debug)]</code>派生</p>
<p>我们也可以不使用派生而是自己实现这些特征：</p>
<p>a.Display:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">impl Display <span class="keyword">for</span> Rectangle &#123;</span><br><span class="line">    fn <span class="built_in">fmt</span>(&amp;self, f: &amp;mut std::<span class="built_in">fmt</span>::Formatter&lt;<span class="string">&#x27;_&gt;) -&gt; std::fmt::Result &#123;</span></span><br><span class="line"><span class="string">        for _ in 0..self.height &#123;</span></span><br><span class="line"><span class="string">            let mut s =  String::new();</span></span><br><span class="line"><span class="string">            for _ in 0..self.width &#123;</span></span><br><span class="line"><span class="string">                s.push(&#x27;</span>#<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            write!(f, &quot;&#123;&#125;\n&quot;, s);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return  Ok(());</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>b.Debug:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">impl  Debug <span class="keyword">for</span> Circle &#123;</span><br><span class="line">    fn <span class="built_in">fmt</span>(&amp;self, f: &amp;mut std::<span class="built_in">fmt</span>::Formatter&lt;<span class="string">&#x27;_&gt;) -&gt; std::fmt::Result &#123;</span></span><br><span class="line"><span class="string">        let _ = f.debug_struct(&quot;Circle&quot;)</span></span><br><span class="line"><span class="string">        .field(&quot;r&quot;, &amp;self.r)</span></span><br><span class="line"><span class="string">        .finish();</span></span><br><span class="line"><span class="string">        return  Ok(());</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>










      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/20/rust11/" data-id="cm19i4pqj0000louya52f0m2m" data-title="rust 学习笔记十一 Rust 中的结构体" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust10" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/15/rust10/" class="article-date">
  <time class="dt-published" datetime="2024-09-15T14:24:06.288Z" itemprop="datePublished">2024-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/15/rust10/">rust 学习笔记十 Rust 中的ENUM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）概览"><a href="#（一）概览" class="headerlink" title="（一）概览"></a>（一）概览</h3><p>rust中创建字符串主要有以下两种方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    enum Pets&#123;</span><br><span class="line">        Bird,</span><br><span class="line">        Cat(String),</span><br><span class="line">        Dog&#123; name:String, age:usize&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">let</span> bird= Pets::Bird;</span><br><span class="line">    <span class="built_in">let</span> <span class="built_in">cat</span> = Pets::Cat(<span class="string">&quot;jack&quot;</span>.to_string());</span><br><span class="line">    <span class="built_in">let</span> dog = Pets::Dog &#123; name: <span class="string">&quot;tom&quot;</span>.to_string(), age: 18 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Enum中的元素可以没有任何参数，可以是带有一个参数的变体，也可以是有多个name声明的结构体</p>
<p>如果直接对初始化出来的元素进行打印：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println!(<span class="string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,bird, <span class="built_in">cat</span>, dog);</span><br></pre></td></tr></table></figure>

<p>会发现报错：没有实现debug trait，此时我们可以通过在代码上方直接添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[derive(Debug)]</span></span><br></pre></td></tr></table></figure>

<p>这样相当于在枚举中自动补全了debug trait.</p>
<p>可以为枚举实现一些方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">impl Pets &#123;</span><br><span class="line">    fn speak(&amp;self) &#123;</span><br><span class="line">        println!(<span class="string">&quot;speak&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的speak就叫做<strong>methods（方法）</strong>,其中第一个参数&amp;self是<strong>对当前这个枚举实例的引用</strong>, 然后枚举中的元素的实例可以调用这个方法：<code>dog.speak();</code></p>
<p>此外还有一种关联函数，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">impl Pets &#123;</span><br><span class="line">    fn <span class="function"><span class="title">log</span></span>() &#123;</span><br><span class="line">        println!(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这类函数参数中将不会再有枚举实例的引用，调用方法也和methods有区别，不再是通过枚举中元素的，而是直接通过<strong>枚举名称::静态方法</strong>名来调用：<code> Pets::log();</code></p>
<h3 id="二-用法"><a href="#二-用法" class="headerlink" title="(二) 用法"></a>(二) 用法</h3><p>1，比较</p>
<p>先看下面这个例子：</p>
<p><img src="/../assets/img/10-1.jpg" alt="图10-1" title="10-1"></p>
<p>bird 和 cat 是同一个枚举 Pets 的不同变体的实例，如果直接将这两个实例进行对比，会报错：<code>binary operation `==` cannot be applied to type `Pets</code>,在rust中，是不支持直接用等号来比较两个变体实例的，根据提示，<br><code>an implementation of `PartialEq` might be missing for `Pets`,consider annotating `Pets` with `#[derive(PartialEq)]`: </code>, 和刚才一样，在最前面添加一个<code>#[derive(PartialEq)]</code>进行补全，即可使用等号比较.</p>
<ol start="2">
<li>Match vs if let</li>
</ol>
<p>对于创建出来的变体实例，可以通过match判断其类型</p>
<p>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">match <span class="built_in">cat</span> &#123;</span><br><span class="line">    Pets::Cat(e) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Pets::Dog&#123;name, age&#125; =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Pets::Bird =&gt; todo!(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在匹配到对应类型时，可以直接访问其中的变量</p>
<p>同时match也适用于rust中的普通变量，比如可以用来匹配i32常数:</p>
<p><img src="/../assets/img/10-2.jpg" alt="图10-2" title="10-2"></p>
<p>但此时发现有报错：因为match要求列举完可能的所有情况，但我们无法将i32的所有可能值全部列举，所以可以在下面再加一种可能：</p>
<p>用<strong>下划线</strong>代替其余的所有可能</p>
<p><img src="/../assets/img/10-3.jpg" alt="图10-3" title="10-3"></p>
<p>而如果觉得每次都进行模糊匹配有点复杂，可以选择使用if let，便可以只关注需要匹配的类型：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">let</span> <span class="built_in">cat</span> = Pets::Cat &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是if let无法像match一样获取到匹配的参数.</p>
<h3 id="三-rust中的两大枚举"><a href="#三-rust中的两大枚举" class="headerlink" title="(三) rust中的两大枚举"></a>(三) rust中的两大枚举</h3><ol>
<li>Option</li>
</ol>
<p>示例如下：</p>
<p><img src="/../assets/img/10-4.jpg" alt="图10-4" title="10-4"></p>
<p>被分为<strong>some和none</strong>两种情况</p>
<p>如果存在一个map,如下:</p>
<p><img src="/../assets/img/10-5.jpg" alt="图10-5" title="10-5"></p>
<p>通过get获取其中的某个key,此时获得的是一个<strong>option</strong>类型的元素,我们将其进行match匹配:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">match a &#123;</span><br><span class="line">    Some(val)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    None =&gt;&#123; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，对于一个动态数组，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = vec![1,2,3,4];</span><br><span class="line"><span class="built_in">let</span> a = arr.iter().last();</span><br></pre></td></tr></table></figure>

<p>我们取出它的最后一个元素，根据提示，也是option类型，故也可以用match进行匹配</p>
<ol start="2">
<li>Result</li>
</ol>
<p>先看示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> num:Result&lt;usize, ()&gt; = Ok(1);</span><br><span class="line">match num &#123;</span><br><span class="line">    Ok(val)=&gt;&#123;&#125;,</span><br><span class="line">    Err(_)=&gt;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果同样使用match进行匹配，只不过其中的匹配项变成了<strong>Ok()和 Err()</strong></p>
<p>在Rust当中，可以声明函数的返回值为Result类型,比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() -&gt; Result&lt;(), ()&gt;&#123;</span><br><span class="line">    <span class="built_in">let</span> num: Result&lt;usize, ()&gt; = Ok(1);</span><br><span class="line">    match num &#123;</span><br><span class="line">        Ok(val)=&gt;&#123;&#125;</span><br><span class="line">        Err(_)=&gt;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而将&amp;str类型进行反序列化的parse函数返回值也是Result类型</p>
<ol start="3">
<li>Option  和  Result 的相互转换</li>
</ol>
<p>a.Option转result:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> opt = Some(42);</span><br><span class="line"><span class="built_in">let</span> result:Result&lt;i32, &amp;str&gt; = opt.ok_or(<span class="string">&quot;err&quot;</span>);</span><br><span class="line">assert_eq!(result, Ok(42));</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> none:Option&lt;i32&gt; = None;</span><br><span class="line"><span class="built_in">let</span> result:Result&lt;i32, &amp;str&gt; = none.ok_or(<span class="string">&quot;err&quot;</span>);</span><br><span class="line">assert_eq!(result, Err(<span class="string">&quot;err&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>其中第一个result走的是ok，所以得到的是Ok(42),第二个和or相匹配，得到的是Err(“err”)</p>
<p>b.Result转option</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> res:Result&lt;i32, &amp;str&gt; = Ok(1);</span><br><span class="line"><span class="built_in">let</span> option = res.ok();</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> res:Result&lt;i32, &amp;str&gt; = Err(<span class="string">&quot;err&quot;</span>);</span><br><span class="line"><span class="built_in">let</span> option = res.ok();</span><br></pre></td></tr></table></figure>

<p>如果是第二种情况，会转换成None,正常情况则是Some</p>
<p>4.常见api</p>
<p>a.可以通过map来遍历option:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> option = Some(1);</span><br><span class="line"><span class="built_in">let</span> b = option.map(|num| num + 1);</span><br></pre></td></tr></table></figure>

<p>b.如果需要多层match层层嵌套，会导致代码繁琐，易读性不高，所以有语法糖，可以直接取出值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> option = Some(1);</span><br><span class="line"><span class="built_in">let</span> a= option.unwrap();</span><br></pre></td></tr></table></figure>

<p>但如果值是None,会panic，也可以使用expect:<code>let a = option.expect(“msg”);</code>可以传入默认值</p>
<p>c.or_else</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> option = Some(1);</span><br><span class="line"><span class="built_in">let</span> a = option.or_else(|| Some((<span class="number">3</span>)));</span><br></pre></td></tr></table></figure>

<p>返回值也是一个Some，用于优雅的处理可能为None的值，给一个默认值</p>
<p>d.mem::size_of::<T>() </p>
<p>mem::size_of::<T>() 函数返回类型 T 在当前平台上的内存大小（以字节为单位）</p>
<p>示例如下：</p>
<p><img src="/../assets/img/10-6.jpg" alt="图10-6" title="10-6"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/15/rust10/" data-id="cm13ta5d30000xsuy91ri6psf" data-title="rust 学习笔记十 Rust 中的ENUM" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust9" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/13/rust9/" class="article-date">
  <time class="dt-published" datetime="2024-09-13T14:48:45.404Z" itemprop="datePublished">2024-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/13/rust9/">rust 学习笔记九 Rust 中的字符串</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）创建字符串的方式"><a href="#（一）创建字符串的方式" class="headerlink" title="（一）	创建字符串的方式"></a>（一）	创建字符串的方式</h3><p>rust中创建字符串主要有以下两种方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> s = String::from(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> s = <span class="string">&quot;hello world2&quot;</span>;</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br></pre></td></tr></table></figure>

<p>其中，第二种直接引号创建的方式，叫<strong>字符串字面值</strong>,我们在编译时就知道其内容,最终字面值文本被直接硬编码进可执行文件，字符串字面量”hello world”就是<strong>str类型</strong>,它被硬编码进可执行程序的数据部分</p>
<p>既然我们已经存储了这个字符串,就需要一种方法来访问它:这就是<strong>切片引用</strong>&amp;str的意义所在，&amp;str是一种<strong>不可变引用</strong>,所以它没有所有权，str类型是硬编码进可执行文件,也<strong>无法被修改</strong>.</p>
<p>但如果我们需要对这种数据进行修改的时候，就需要用到第一种创建方法，String在rust中是一个复合数据类型,存储在<strong>堆上</strong>,定义如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pub struct String&#123;</span><br><span class="line">vec: Vec&lt;u8&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>意味string可改变的、并且<strong>拥有所有权</strong>的</p>
<p>总结一下二者区别:</p>
<p><strong>&amp;str</strong>:这是一个字符串切片,它是固定大小的,并且不能改变</p>
<p><strong>&amp;string</strong>:这是一个可增长的、可改变的、拥有所有权的、UTF-8编码的字符串类型。它通常用于需要改变或者增长字符串的情况</p>
<h3 id="（二）类型转换"><a href="#（二）类型转换" class="headerlink" title="（二）	类型转换"></a>（二）	类型转换</h3><p><img src="/../assets/img/9-1.jpg" alt="图9-1" title="9-1"></p>
<p>这其中发生了从u8数组到str的转换，但将数组的定义改为vec定义也可以：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> b = vec!(104, 101, 108, 108, 111);</span><br></pre></td></tr></table></figure>

<p>这是因为vector对其进行了隐式的类型转换，同样，也可以进行从str到utf8数组的转换</p>
<p><img src="/../assets/img/9-2.jpg" alt="图9-2" title="9-2"></p>
<p>如果需要进行str 和 string的相互转换：</p>
<p>从String类型转变为&amp;str是非常便捷的,而且<strong>无损的</strong>(性能无损,不会造成重写malloc或者数据移动),另外,由于Rust实现了自动解引用,那么&amp;String在必要的时候可以自动转换为&amp;str,因此在很多函数中,如果接收参数是字符串的引用,通常会采用&amp;str作为入参,以获取更好的数据兼容性<br>,字符串是UTF-8编码,因此需要保证索引的字节刚好落在<strong>字符的边界</strong></p>
<p><img src="/../assets/img/9-3.jpg" alt="图9-3" title="9-3"></p>
<p>如果需要从&amp;str转为string则需要用 String::from进行包裹：</p>
<p><img src="/../assets/img/9-4.jpg" alt="图9-4" title="9-4"></p>
<p>但是这样做对内存消耗较大，因为&amp;str类型的数据是被硬编码在可执行文件中的，但是转换为string类型需要<strong>重新到堆上申请内存</strong></p>
<h3 id="（三）常见修改String的方法"><a href="#（三）常见修改String的方法" class="headerlink" title="（三）	常见修改String的方法"></a>（三）	常见修改String的方法</h3><ol>
<li>追加</li>
</ol>
<p>a.使用<strong>push()<strong>方法追加字符char<br>b.使用</strong>push_str()<strong>方法追加字符串字面量<br>两个方法都是在原有的字符串上追加,并</strong>不会返回新的字符串</strong><br>字符串追加操作要修改原来的字符串,则该字符串必须是可变的,即字符串变量必须由<strong>mut</strong>关键字修饰</p>
<p><img src="/../assets/img/9-5.jpg" alt="图9-5" title="9-5"></p>
<ol start="2">
<li>插入</li>
</ol>
<p>a.使用<strong>insert()<strong>方法插入单个字符char<br>b.使用</strong>insert_str()<strong>方法插入字符串字面量<br>这俩方法需要传入两个参数,第一个参数是字符(串)插入位置的索引,索引从0开始计数;第二个参数是要插入的字符<br>如果越界则会发生错误<br>如果参数所给的位置不是</strong>合法的字符边界</strong>,也会发生错误<br>由于字符串插入操作要修改原来的字符串,则该字符串必须是可变的,即字符串变量必须由<strong>mut</strong>关键字修饰</p>
<p><img src="/../assets/img/9-6.jpg" alt="图9-6" title="9-6"></p>
<ol start="3">
<li>替换</li>
</ol>
<p>a. <strong>replace()<strong>方法接收两个参数,第一个参数是要被替换的字符串,第二个参数是新的字符串<br>该方法会替换所有匹配到的字符串<br>该方法是返回一个新的字符串,而不是操作原来的字符串,故不会修改原字符串，</strong>不需要mut修饰</strong></p>
<p><img src="/../assets/img/9-7.jpg" alt="图9-7" title="9-7"></p>
<p>b. <strong>replace_range()<strong>接收两个参数,第一个参数是要替换字符串的范围(Range),第二个参数是新的字符串<br>该方法是直接操作原来的字符串,不会返回新的字符串。该方去需要使用</strong>mut</strong>关键字修饰<br>如果range的范围大于&#x2F;小于新字符串的长度会因为不在<strong>合法边界</strong>而报错</p>
<p><img src="/../assets/img/9-8.jpg" alt="图9-8" title="9-8"></p>
<p>4.删除</p>
<p>a.pop<br><strong>删除并返回</strong>字符串的最后一个字符<br>其返回值是一个<strong>Option类型</strong>,如果字符串为空,则返回<br>该方法是直接操作原来的字符串</p>
<p><img src="/../assets/img/9-9.jpg" alt="图9-9" title="9-9"></p>
<p>b.remove<br>该方法是直接操作原来的字符串<br>其返回值是<strong>删除位置的字符串</strong><br>只接收一个参数,表示该字符<strong>起始索引位置</strong><br>方法是按照字节来处理字符串的,如果参数所给的位置不是<strong>合法的的字符边界</strong>,则会发生错误</p>
<p><img src="/../assets/img/9-10.jpg" alt="图9-10" title="9-10"></p>
<p>c.truncat<br>删除字符串中<strong>从指定位置开始到结尾的全部字符</strong><br>方法是按照字节来处理字符串的,如果参数所给的位置不是<strong>合法的字符边界</strong>,则会发生错误<br>该方法是直接操作原来的字符串</p>
<p><img src="/../assets/img/9-11.jpg" alt="图9-11" title="9-11"></p>
<p>d.clear<br>清空字符串<br>该方法是直接操作原来的字符串</p>
<p><img src="/../assets/img/9-12.jpg" alt="图9-12" title="9-12"></p>
<p>5.连接</p>
<p>a.使用+或者+&#x3D;连接字符串<br>这里add()方法的第二个参数必须为字符串的<strong>切片引用类型</strong><br>是返回一个新的字符串,所以变量声明可以<strong>不需要mut关键字修饰</strong></p>
<p><img src="/../assets/img/9-13.jpg" alt="图9-13" title="9-13"></p>
<p>b.使用format!连接字符串<br>format!的用法与 print!的用法类似</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/13/rust9/" data-id="cm10u4a4g0000e4uy9nle6pel" data-title="rust 学习笔记九 Rust 中的字符串" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust8" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/12/rust8/" class="article-date">
  <time class="dt-published" datetime="2024-09-11T16:29:39.235Z" itemprop="datePublished">2024-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/12/rust8/">rust 学习笔记八 Rust 中的数组与切片</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>类型[T;N]表示N个值的数组,每个值的类型为T。数组的大小是<strong>在编译期就已确定的常量</strong>,并且是类型的一部分,不能追加新元素或缩小数组。类型&amp;[T]和&amp;mut[T]可称为T的<strong>共享切片</strong>和T的<strong>可变切片</strong>,它们是对一系列元素的引用,这些元素是某个其他值(比如数组或向量)的一部分。可以将切片视为<strong>指向其第一个元素的指针</strong>,以及从该点开始允许访问的元素数量的计数。可变切片&amp;mut[T]<strong>允许读取元素和修改元素,但不能共享</strong>;共享切片&amp;[T]允许<strong>在多个读取者之间共享访问权限,但不允许修改元素</strong>。</p>
<p>rust会检查类型中任意一种类型的值v,表达式v.len()都会给出v中的元素数,而v[i]引用的是V的第 i 个元素， 第一个元素是v[0],最后一个元素是v[v.len()-1]。Rust总是会检查i是否在这个范围内,如果没在,则此表达式会出现panic（），长度可能为0,在这种情况下,任何对其进行索引的尝试都会出现panic。i的类型必须是<strong>usize</strong>,不能使用任何其他整型作为索引。</p>
<h3 id="（一）数组"><a href="#（一）数组" class="headerlink" title="（一）	数组"></a>（一）	数组</h3><p>数组有以下特征：</p>
<p>1.数组的定义其实就是为分配一段<strong>连续的相同数据类型的内存块</strong></p>
<p>2.数组是<strong>静态</strong>的。这意味着一旦定义和初始化,则永远不可更改它的长度</p>
<p>3.数组的元素有着<strong>相同</strong>的数据类型,每一个元素都独占者数据类型大小的内存块。也就是说。数组的内存大小等于数组的长度乘以数组的数据类型</p>
<p>4.数组中的每一个元素都按照顺序依次存储,这个顺序号既代表着元素的存储位置,也是数组元素的唯一标识。我们把这个标识称之为数组下标</p>
<p>5.填充数组中的每一个元素的过程称为数组初始化。也就是说数组初始化就是为数组中的每一个元素赋值</p>
<p>6.可以更新或修改数组元素的值,但<strong>不能删除数组元素</strong>。如果要删除功能,你可以将它的值赋值为0或其它表示删除的值</p>
<p>介绍几种初始化数组的方法：</p>
<p>1.首先是最标准的格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr:[i32;4] = [10,11,12,13];</span><br></pre></td></tr></table></figure>
<p>在数组名称后面添加<code>[类型；个数]</code>的声明</p>
<p>2.或者也可以不声明，rust会自行推导</p>
<p>3.如果数组中每个元素的类型和值都一样的话，可以不用挨个列出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr= [10;4];</span><br></pre></td></tr></table></figure>

<p>如果需要获取数组的长度，通常通过调用函数len():<code>arr.len();</code></p>
<p>数组的遍历：</p>
<p>1.可通过之前说过的for循环结合序列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> 0..4&#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,arr[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2:可通过rust的迭代器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> arr.<span class="function"><span class="title">iter</span></span>()&#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  也可以这样写，更精简：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.iter().for_each(|value| println!(<span class="string">&quot;&#123;&#125;&quot;</span>,value));</span><br></pre></td></tr></table></figure>

<p>如果需要修改一个数组中的元素，直接像下面这样：<code>arr[0] = 1;</code>是会报错的，因为这是个<strong>不可变数组</strong>需要修改的话需要将数组声明为mut</p>
<p>在看下面这个例子：</p>
<p><img src="/../assets/img/8-1.jpg" alt="图8-1" title="8-1"></p>
<p>可以发现在函数内打印的数组已经被修改了，但是并没有在函数作用域外起作用，这样的操作叫<strong>值传递</strong>,如果需要在函数中修改数组中的值，需要使用<strong>引用传递</strong>：</p>
<p><img src="/../assets/img/8-2.jpg" alt="图8-2" title="8-2"></p>
<h3 id="（二）切片"><a href="#（二）切片" class="headerlink" title="（二）	切片"></a>（二）	切片</h3><p>Slice类型通常翻译为切片,它表示从某个包含多个元素的容器中取得局部数据,这个过程称为切片操作。不同语言对切片的支持有所不同,比如有些语言只允许取得连续的局部元素,而有些语言可以取得离散元素,甚至有些语言可以对hash结构进行切片操作</p>
<p>Rust也支持Slice操作,Rust中的切片操作只允许获取一段连续的局部数据,切片操作获取到的数据称为切片数据</p>
<p>Rust常见的数据类型中,有三种类型已支持Slice操作:String类型、Array类型和Vec类型</p>
<p>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = [10,20,30,40,50,60];</span><br><span class="line"><span class="built_in">let</span> slice = &amp;a[1..3];</span><br><span class="line">println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,slice);</span><br></pre></td></tr></table></figure>

<p>切片常用函数如下:</p>
<p><img src="/../assets/img/8-3.jpg" alt="图8-3" title="8-3"></p>
<p>此处不挨个举例，简单举例几个比较特殊的函数</p>
<p>1.windows</p>
<p><img src="/../assets/img/8-4.jpg" alt="图8-4" title="8-4"></p>
<p>2 start_with</p>
<p><img src="/../assets/img/8-5.jpg" alt="图8-5" title="8-5"></p>
<hr>
<p>思考：给定一个整数数组nums,返回一个数组answer,使得answer[i]等于nums除之外nums[i]的所有元素的乘积:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> a = [1,-1,1,1];</span><br><span class="line">    <span class="built_in">let</span> b:Vec&lt;i32&gt; = complete(&amp;a);</span><br><span class="line">    println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn complete(arr: &amp;[i32]) -&gt; Vec&lt;i32&gt;&#123;</span><br><span class="line">    <span class="built_in">let</span> length = arr.len();</span><br><span class="line">    <span class="built_in">let</span> mut result = vec![1; length];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">let</span> mut left_product = 1;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> 0..length &#123;</span><br><span class="line">        result[i] *= left_product;</span><br><span class="line">        left_product *= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">let</span> mut right_product = 1;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (0..length).<span class="function"><span class="title">rev</span></span>() &#123;</span><br><span class="line">        result[i] *= right_product;</span><br><span class="line">        right_product *= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/12/rust8/" data-id="cm0y2xqu70000eguy8ziae905" data-title="rust 学习笔记八 Rust 中的数组与切片" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust7" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/10/rust7/" class="article-date">
  <time class="dt-published" datetime="2024-09-09T17:51:03.438Z" itemprop="datePublished">2024-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/10/rust7/">rust 学习笔记七 Rust 中的引用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）在rust中，引用分为可变引用和不可变引用"><a href="#（一）在rust中，引用分为可变引用和不可变引用" class="headerlink" title="（一）在rust中，引用分为可变引用和不可变引用"></a>（一）在rust中，引用分为可变引用和不可变引用</h3><p>·不可变引用(Immutable Reference):通过不可变引用,可以读取数据,但不能修改数据。一个变量可以有多个不可变引用,但不能与可变引用共存</p>
<p>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> s1 = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">let</span> s2 = &amp;s1;</span><br><span class="line"><span class="built_in">let</span> s3 = &amp;s1;</span><br></pre></td></tr></table></figure>

<p>可变引用(Mutable Reference):通过可变引用,可以读取和修改数据。一个变量在某一时刻只能有一个可变引用,且不能与不可变引用共存</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> mut s1 = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">let</span> s2 = &amp;mut s1;</span><br></pre></td></tr></table></figure>

<p>综上，同一时间内一个变量只能<strong>有一个可变引用或者多个不可变引用，且必须总是有效</strong></p>
<p>但是在以下情况下，是可以正常执行的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> mut s1 = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">let</span> s2 = &amp;s1;</span><br><span class="line"><span class="built_in">let</span> s3 = &amp;s1;</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>,s2, s3);</span><br><span class="line"><span class="built_in">let</span> s4 = &amp; mut s1;</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s4);</span><br></pre></td></tr></table></figure>

<p>但是在这种情况下，是可以正常执行的，因为可以把2~4行中对于s1的引用视作一个单独的作用域，而在打印结束之后不会有关于引用的使用，所以可以视作对s1的不可变引用已经结束了，所以不会影响后面继续对s1创建可变引用</p>
<h3 id="（二）关于引用的一些概念"><a href="#（二）关于引用的一些概念" class="headerlink" title="（二）关于引用的一些概念"></a>（二）关于引用的一些概念</h3><ol>
<li><p>Move</p>
<p> 主要描述堆数据所有权的转移</p>
</li>
<li><p>borrowing</p>
<p> 在向函数传入参的时候，函数对于变量所有权的借用</p>
</li>
<li><p>referenceing</p>
<p> 包含了borrowing 以及 字符串和数组的切片（对堆上某一段数据的引用）</p>
</li>
</ol>
<h3 id="（三）生命周期"><a href="#（三）生命周期" class="headerlink" title="（三）生命周期"></a>（三）生命周期</h3><p>生命周期是Rust用来保证引用有效性的机制。生命周期注解允许编译器推断引用的有效范围,确保在引用仍然有效时使用它们</p>
<p>先看下面的示例：</p>
<p><img src="/../assets/img/7-1.jpg" alt="图7-1" title="7-1"></p>
<p>直接这样写会报错，提示是不能返回一个对于函数中临时值的引用，前文所有权中见过，作用域结束时会自动调用drop，在其他地方调用会导致<strong>悬垂指针</strong>的问题</p>
<p>在rust中，解决办法是：</p>
<p><img src="/../assets/img/7-2.jpg" alt="图7-2" title="7-2"></p>
<p>在外面创建一个空变量，将其可变引用传入函数进行修改，然后返回</p>
<p>或者：</p>
<p><img src="/../assets/img/7-3.jpg" alt="图7-3" title="7-3"></p>
<p>但如果向下面这样传入引用修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = getLongest(&amp;<span class="string">&quot;a&quot;</span>.to_owned(), &amp;<span class="string">&quot;b&quot;</span>.to_owned());</span><br><span class="line">fn getLongest(a: &amp;String,b :&amp;String) -&gt; &amp;String&#123;</span><br><span class="line">    <span class="keyword">if</span> a.len() &gt; b.<span class="function"><span class="title">len</span></span>()&#123;</span><br><span class="line">        a</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>!(<span class="string">&quot;&#123;&#125;&quot;</span>,a);</span><br></pre></td></tr></table></figure>

<p>会报错：<strong>缺少生命周期</strong></p>
<p>此时我们需要根据提示标记一下声明周期’a，（具体原因后面描述），像下面这样，即可通过编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> s1 = <span class="string">&quot;a&quot;</span>.to_owned();</span><br><span class="line"><span class="built_in">let</span> s2 = <span class="string">&quot;b&quot;</span>.to_owned();</span><br><span class="line"><span class="built_in">let</span> a = getLongest(&amp;s1, &amp;s2);</span><br><span class="line">fn getLongest&lt;<span class="string">&#x27;a&gt;(a: &amp;&#x27;</span>a String,b :&amp;<span class="string">&#x27;a String) -&gt; &amp;&#x27;</span>a String&#123;</span><br><span class="line">    <span class="keyword">if</span> a.len() &gt; b.<span class="function"><span class="title">len</span></span>()&#123;</span><br><span class="line">        a</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>!(<span class="string">&quot;&#123;&#125;&quot;</span>,a);</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/10/rust7/" data-id="cm0vaxrzs0000pkuyc2837ljl" data-title="rust 学习笔记七 Rust 中的引用" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust6" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/08/rust6/" class="article-date">
  <time class="dt-published" datetime="2024-09-08T10:20:29.774Z" itemprop="datePublished">2024-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/08/rust6/">rust 学习笔记六 Rust中的所有权</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Rust是一种系统编程语言,其设计目的是确保内存安全并限防止数据竞争,而不依赖垃圾回收器。这种内存安全性主要通过<strong>所有权系统</strong>来实现</p>
<p>先看看主流编程语言的内存回收机制对比 :</p>
<p><img src="/../assets/img/6-1.png" alt="图6-1" title="6-1"></p>
<p>而在rust中，内存管理是通过<strong>所有权系统</strong>完成的</p>
<h3 id="一-有以下特点："><a href="#一-有以下特点：" class="headerlink" title="(一)有以下特点："></a>(一)有以下特点：</h3><p>1.Rust使用所有权系统进行内存管理,编译器在编译时通过静态态分析来确保内存安全</p>
<p>2.每个值<strong>都有一个所有者,在任何时候只能有一个有效的所有者</strong></p>
<p>3.通过 <strong>借用(引用)</strong> 机制来共享数据,同时保证数据竞争和悬垂指针的安全</p>
<p>4.当所有者离开作用域(scope),值会被丢弃(drop)</p>
<h3 id="二-为什么要有所有权："><a href="#二-为什么要有所有权：" class="headerlink" title="(二)为什么要有所有权："></a>(二)为什么要有所有权：</h3><p>举例说明：</p>
<p>对于分布在栈上的数据，如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> x = 5;</span><br><span class="line"><span class="built_in">let</span> y = x;</span><br></pre></td></tr></table></figure>

<p>这种情况下，是将原来的值进行了一个拷贝，而没有改变原来数据的所有权</p>
<p>而对于分布在堆上的数据，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> s1 = String::from(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="built_in">let</span> s2 = s1;</span><br></pre></td></tr></table></figure>

<p>实则是改变了数据的所有权到s2上，此时直接使用s1，会报错</p>
<p>故所有权可以<strong>确保程序在运行时不会访问无效的内存，避免了数据竞争和内存泄漏</strong></p>
<p>对于以下情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">let</span> s1 = String::from(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="built_in">let</span> s2 = s1;</span><br><span class="line">&#125;</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s2);</span><br></pre></td></tr></table></figure>

<p>也是不能正常访问的，因为在编译过程中，在scope结束时，会自动添加类似drop(s2)的代码，作用域一结束，s2就失效了</p>
<h3 id="三-实践一下"><a href="#三-实践一下" class="headerlink" title="(三)实践一下"></a>(三)实践一下</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> s1 = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">let</span> s2 = take_ownership(s1) ;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s1);</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s2);</span><br><span class="line">&#125;</span><br><span class="line">fn take_ownership(s:String) -&gt; String&#123;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接执行这段代码会报错。因为<code>ake_ownership</code> 函数获取了 s1 的所有权，因此 s1 不再有效，</p>
<p>如果需要保持s1所有权不变的前提下，将其值传入函数可以将s1进行<strong>克隆</strong>，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> s1 = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">let</span> s2 = take_ownership(s1.clone()) ;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s1);</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s2);</span><br><span class="line">&#125;</span><br><span class="line">fn take_ownership(s:String) -&gt; String&#123;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者传入s1的<strong>不可变引用</strong>到函数中，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> s1 = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">let</span> s2 = take_ownership(&amp;s1) ;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s1);</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s2);</span><br><span class="line">&#125;</span><br><span class="line">fn take_ownership(s:&amp;String) -&gt; String&#123;</span><br><span class="line">    <span class="built_in">return</span>  s.to_string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述两种方法中，更推荐使用第二种方法，因为第一种方法在参数体积比较大的时候，对参数进行clone，可能会导致对内存的占用和对性能的消耗</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/08/rust6/" data-id="cm0tfotgz00007cuyaj06gdu9" data-title="rust 学习笔记六 Rust中的所有权" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust5" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/08/rust5/" class="article-date">
  <time class="dt-published" datetime="2024-09-07T17:19:56.729Z" itemprop="datePublished">2024-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/08/rust5/">rust 学习笔记五 Rust中的数据类型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本篇主要讲解一下rust中的数据类型，主要从以下几个方面进行讲解：<strong>基础数据类型，整形，浮点，字符，序列，类型强制转换</strong></p>
<h3 id="（一）rust类型概览"><a href="#（一）rust类型概览" class="headerlink" title="（一）rust类型概览"></a>（一）rust类型概览</h3><p>rust中的主要类型如下图所示：</p>
<p><img src="/../assets/img/5-1.png" alt="图5-1" title="5-1"></p>
<p><img src="/../assets/img/5-2.png" alt="图5-2" title="5-2"></p>
<p><img src="/../assets/img/5-3.png" alt="图5-3" title="5-3"></p>
<h3 id="（二）整型"><a href="#（二）整型" class="headerlink" title="（二）整型"></a>（二）整型</h3><p>根据数据的大小，我们可以将有符号和无符号整数类型进—步分类为不同的类别:其中固定的有8, 16, 32, 64, 128位，在前面加i或者u表示是否有符号，不固定的有isize 和 usize, <strong>在不同架构上不一样</strong>，<br>在rust中定义整形默认是32位，此外，在rust中如果数字或者字符太长时，可以用_进行分隔使其更易读，表达的意思是一样的，比如：</p>
<p><img src="/../assets/img/5-4.jpg" alt="图5-4" title="5-4"></p>
<h3 id="（三）浮点型"><a href="#（三）浮点型" class="headerlink" title="（三）浮点型"></a>（三）浮点型</h3><p>浮点类型数字是带有小数点的数字,在Rust中浮点类型也有两种基本类型:f32和f64,分别为32位和64位大小。默认浮点类型是f64,在现代的CPU中它的速度与f32几乎相同,但精度更高。<br>由于二进制和十进制之间的转换不是完全精确的，很多十进制小数在转换为二进制时会变成无限循环小数，这导致它们不能被精确地表示，比如在rust 中直接判断 0.1 + 0.2 是否等于0.3，<strong>二者并不会直接相等</strong>，当你执行 0.1 + 0.2 时，你实际上是在计算两个不精确的值的和，结果也是一个不精确的值。这个结果可能非常接近 0.3，但由于精度限制，它可能不完全等于 0.3.最准确的表达方式是<strong>在误差范围内二者相等</strong><br>如下所示：</p>
<p><img src="/../assets/img/5-5.jpg" alt="图5-5" title="5-5"></p>
<h3 id="（四）NAN"><a href="#（四）NAN" class="headerlink" title="（四）NAN"></a>（四）NAN</h3><p>对于数学上未定义的结果,如负数开平方根,Rust的浮点数类型会使用NaN(Not a Number)来处理这些情况。任何与NaN进行交互的操作都会返回NaN,并且NaN不能用于比较(如断言),这会导致程序崩溃。<br>在rust中，可以通过<code>is_nan</code>方法来判断一个元素是否有效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> v = (-1.1_f64).sqrt();</span><br><span class="line"><span class="keyword">if</span> v.<span class="function"><span class="title">is_nan</span></span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>!(<span class="string">&quot;v is nan&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（五）布尔类型"><a href="#（五）布尔类型" class="headerlink" title="（五）布尔类型"></a>（五）布尔类型</h3><p>Rust中的布尔类型有两个可能的值:true和false,布尔值占用内存的大小为1个字节</p>
<h3 id="（六）序列"><a href="#（六）序列" class="headerlink" title="（六）序列"></a>（六）序列</h3><p>Rust提供了一个非常简洁的方式,用来生成连续的数值,例如1..5,生成从1到4的连续数字,不包含5;1.&#x3D;5,生成从1到5的连续数字,包含5,它的用途很简单,常常用于循环中<br>除了在之前文章中提到的用于数字的循环外，也可以用于字符的循环，比如：</p>
<p><img src="/../assets/img/5-6.jpg" alt="图5-6" title="5-6"></p>
<h3 id="七-类型强制转换"><a href="#七-类型强制转换" class="headerlink" title="(七)类型强制转换"></a>(七)类型强制转换</h3><p>在Rust中,<strong>as关键字</strong>用于在原始类型(如i64、f64、u64、char等)之间进行类型转换。然而,需要注意的是,as关健字并<strong>不适用于复合类型</strong>,比如String或其他用户定义的类型。对于复合类型的转换,通常需要使用其他方法或函数。<br>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = 5;</span><br><span class="line"><span class="built_in">let</span> f = a as f32;</span><br></pre></td></tr></table></figure>











      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/08/rust5/" data-id="cm0sf9tq40004sguy12ez38ys" data-title="rust 学习笔记五 Rust中的数据类型" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust4" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/06/rust4/" class="article-date">
  <time class="dt-published" datetime="2024-09-06T15:26:21.339Z" itemprop="datePublished">2024-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/06/rust4/">rust 学习笔记四 Rust中的流程控制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天主要从以下两个方面讲解以下Rust中的流程控制: <strong>条件控制，循环语句</strong>.</p>
<h2 id="（一）条件控制"><a href="#（一）条件控制" class="headerlink" title="（一）条件控制"></a>（一）条件控制</h2><p>示例如下：.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">let</span> number = 3;</span><br><span class="line">    <span class="keyword">if</span> number % 4 == 0 &#123;</span><br><span class="line">        println!(<span class="string">&quot;number is divisible by 4&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % 3 == 0 &#123;</span><br><span class="line">        println!(<span class="string">&quot;number is divisible by 3&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> number % 2 == 0&#123;</span><br><span class="line">        println!(<span class="string">&quot;number is divisible by 2&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键字后直接加结果为bool值的表达式即可.</p>
<p>除此之外，有一个rust的特性，可将条件语句直接绑定在变量上，示例如下：.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = <span class="keyword">if</span> condition  &#123;</span><br><span class="line">    6</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    5 + 2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>直接在条件语句中返回了不同情况下a的初始值，由于这本质上是个赋值语句，所以需要在条件语句后面<strong>加上一个分号</strong>，条件语句中的返回值可以是数值也可以是算式</p>
<h2 id="（二）循环语句"><a href="#（二）循环语句" class="headerlink" title="（二）循环语句"></a>（二）循环语句</h2><p>Rust中的循环语句分为以下几种</p>
<h3 id="1：loop循环"><a href="#1：loop循环" class="headerlink" title="1：loop循环."></a>1：loop循环.</h3><p>示例一如下：.</p>
<p><img src="/../assets/img/4-1.jpg" alt="图4-1" title="4-1"></p>
<p>这是一个最简单的loop循环，直接通过loop包裹即可.</p>
<p>示例二如下：.</p>
<p><img src="/../assets/img/4-2.jpg" alt="图4-2" title="4-2"></p>
<p>可以看出loop循环中 continue 关键字和 break 关键字的作用，其中 continue 关键字可以<strong>跳过当前循环</strong>，break关键字可以<strong>终止当前循环</strong>.</p>
<p>除此之外，loop循环也可以用来给变量初始化值：.</p>
<p><img src="/../assets/img/4-3.jpg" alt="图4-3" title="4-3"></p>
<p>可以看出来在break处的计算结果最后被赋值给了result.</p>
<p>示例三如下：.</p>
<p><img src="/../assets/img/4-4.jpg" alt="图4-4" title="4-4"></p>
<p>这是一个loop的嵌套循环，里面的loop在执行到目标值后就会退出，但是<strong>不影响外层循环一直执行</strong>,如果想在内层循环结束时结束外层循环，可以按如下所示操作：.</p>
<p><img src="/../assets/img/4-5.jpg" alt="图4-5" title="4-5"></p>
<p>在最外层循环处注册一个 <strong>’名字</strong>, 然后在内层循环<strong>break时候加上该名字</strong>即可</p>
<h3 id="2：while循环"><a href="#2：while循环" class="headerlink" title="2：while循环"></a>2：while循环</h3><p>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> a != 10 &#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,a);</span><br><span class="line">    a += 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>While 循环和loop 循环有很多相似之处,但是while更适用于有明确目标的循环（更简洁）.</p>
<h3 id="3：for循环"><a href="#3：for循环" class="headerlink" title="3：for循环"></a>3：for循环</h3><p>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = [10, 20, 30, 40];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a &#123;</span><br><span class="line">   println!(<span class="string">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以快速创建一个类似range的循环：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> e <span class="keyword">in</span> (1..4) &#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,e);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>这样可以得到一个从1到3的循环，如果在这种情况下想要包括4，则需要将 **(1..4)改为(1..&#x3D;4)**，则得到一个1到4的循环，此外，可以继续修改，得到另外的循环，比如将(1..4)改为(1..4).iter().rev()，就能得到一个在原基础上逆序的循环.</p>
<h3 id="4-所有权转移"><a href="#4-所有权转移" class="headerlink" title="4: 所有权转移"></a>4: 所有权转移</h3><p>先看下面例子：.</p>
<p><img src="/../assets/img/4-6.jpg" alt="图4-6" title="4-6"></p>
<p>在循环执行完之后，直接访问vec的元素，发现报错，此vec的<strong>所有权已经在执行循环时发生了转移</strong>，所以为了避免这种情况，我们在执行循环时，应该写成.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时通过地址引用，只是在<strong>借用vec的所有权</strong>，所以在循环执行完之后依然能访问vec的元素.</p>
<p>此外，如果想要在访问的过程中修改vec的元素则需要向如下这样.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> &amp;mut v &#123;</span><br><span class="line">    <span class="keyword">if</span> *e == 1&#123;</span><br><span class="line">        *e = 2;</span><br><span class="line">    &#125;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将v改为mut，然后访问具体元素时在e前面加上 *号 ，表示直接访问元素而不是地址，最后得到修改后的vec.</p>
<p>但是如果此时遍历的不是一个vec而是一个数组：.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> mut  v = [1,2,3];</span><br><span class="line"><span class="keyword">for</span>  e <span class="keyword">in</span>  v &#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,e);</span><br><span class="line">&#125;</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,v[0]); </span><br></pre></td></tr></table></figure>
<p>却可以正常访问，因为<strong>数组是实现了copy属性的类型</strong>，在遍历的过程中并<strong>不会发生所有权的转移</strong>，而是直接进行了<strong>数据的拷贝</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/06/rust4/" data-id="cm0sf9tq30003sguye66dfmj7" data-title="rust 学习笔记四 Rust中的流程控制" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/05/rust3/" class="article-date">
  <time class="dt-published" datetime="2024-09-05T14:06:06.672Z" itemprop="datePublished">2024-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/05/rust3/">rust 学习笔记三 Rust中的函数</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>总结一下rust中常见的函数使用方式</p>
<p>首先标准示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn fn_name(i:<span class="built_in">type</span>, j:<span class="built_in">type</span>) -&gt; return_type&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有以下注意事项:.</p>
<p>需要在每个参数后面<strong>声明参数类型</strong>，并在函数体前面加上<strong>返回值类型</strong>.</p>
<p>函数的定义和调用位置没有固定顺序.</p>
<p>且函数名<strong>不能用数字开头</strong>.</p>
<p>对于函数体中的返回值，有以下两种写法：</p>
<p>常规写法：.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn immutable(i:i32, j:i32) -&gt; i32&#123;</span><br><span class="line">    <span class="built_in">return</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及不带return 和 分号，直接写返回值:.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn immutable(i:i32, j:i32) -&gt; i32&#123;</span><br><span class="line">   i + j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个函数没有返回值，则可以<strong>在返回类型处用（）</strong>表示:.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn immutable(i:i32, j:i32)-&gt;()&#123;</span><br><span class="line">   println!(<span class="string">&quot;i + j == &#123;&#125;&quot;</span>,i + j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者直接<strong>去掉返回值部分</strong>:.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn immutable(i:i32, j:i32)&#123;</span><br><span class="line">   println!(<span class="string">&quot;i + j == &#123;&#125;&quot;</span>,i + j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，对于预期会死循环和抛出错误的函数，可以在返回类型处用感叹号表示:.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn immutable()-&gt;!&#123;</span><br><span class="line">   loop &#123;</span><br><span class="line">       //...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/05/rust3/" data-id="cm0sf9tq10001sguy5yajdczp" data-title="rust 学习笔记三 Rust中的函数" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/04/rust2/" class="article-date">
  <time class="dt-published" datetime="2024-09-04T13:38:52.377Z" itemprop="datePublished">2024-09-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/04/rust2/">rust 学习笔记二 变量与可变性</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Rust 是一门安全性非常强的系统级语言，故了解不同种类变量的特性以及使用场景十分重要，本文主要从以下几个步骤来讲解rust中的变量与可变性:<br><strong>可变变量和不可变变量，常量，静态变量，变量遮蔽</strong>.</p>
<h3 id="（一）可变变量和不可变变量"><a href="#（一）可变变量和不可变变量" class="headerlink" title="（一）	可变变量和不可变变量"></a>（一）	可变变量和不可变变量</h3><p>先举出示例如下：<br>直接通过    </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = 32;</span><br><span class="line">println!(<span class="string">&quot;value of a is &#123;&#125;&quot;</span>, a);</span><br></pre></td></tr></table></figure>
<p>为变量a赋值为正整数32，并打印，控制台执行<code>cargo run</code>得到输出如下：.</p>
<p><img src="/../assets/img/2-1.jpg" alt="图2-1" title="2-1"></p>
<p>此时如果直接尝试修改a的值，会得到错误提示如下：.</p>
<p><img src="/../assets/img/2-2.jpg" alt="图2-2" title="2-2"></p>
<p>此时的a就是一个不可变变量，根据提示，我们可以通过在变量名前通过<strong>mut修饰</strong>将其变为一个可变变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> mut a = 32;</span><br></pre></td></tr></table></figure>
<p>此时再执行<code>cargo run</code>,发现值被成功修改（会有警告，这个后文再谈），说明此时的a是一个可变变量.</p>
<h3 id="（二）常量"><a href="#（二）常量" class="headerlink" title="（二）	常量"></a>（二）	常量</h3><p>先举出一个正确示例：.</p>
<p><img src="/../assets/img/2-3.jpg" alt="图2-3" title="2-3"></p>
<p>使用<code>const name:type = value</code>的解构定义即可<br>常量定义需注意以下几点：<br>定义时<strong>指定数据类型</strong>，否则报错：.</p>
<p><img src="/../assets/img/2-4.jpg" alt="图2-4" title="2-4"></p>
<p>变量名使用<strong>大写字母</strong>, 否则警告：.</p>
<p><img src="/../assets/img/2-5.jpg" alt="图2-5" title="2-5"></p>
<p>定义时必须<strong>赋初始值</strong>，否则报错：.</p>
<p><img src="/../assets/img/2-6.jpg" alt="图2-1" title="2-6"></p>
<p><strong>不支持重定义或者修改初始值</strong>，否则报错：.</p>
<p><img src="/../assets/img/2-7.jpg" alt="图2-7" title="2-7"></p>
<p>以上这些特性与js 中的常量定义有很大相似之处</p>
<p>此外，常量与上文中的不可变变量有以下区别：</p>
<p>常量使用<strong>const</strong>进行声明,不可变变量使用<strong>let</strong>进行声明.</p>
<p>常量在编译时就确定了值,<strong>不能在运行时改变</strong>。不可变变量直到运行时才能确定下来.</p>
<p>常量不可以修改,不可变变量可以通过<strong>变量遮蔽来二次定义</strong>.</p>
<p>常量必须声明类型,不可变变量不需要声明类型.</p>
<p>常量必须使用<strong>大写字母</strong>,不可变变量不需要.</p>
<h3 id="（三）静态变量"><a href="#（三）静态变量" class="headerlink" title="（三）	静态变量"></a>（三）	静态变量</h3><p>先正确示例如下：.</p>
<p><img src="/../assets/img/2-8.jpg" alt="图2-8" title="2-8"></p>
<p>静态变量有以下特性：</p>
<p>使用<strong>static</strong>声明，在编译时分配内存，运行时一直存在.</p>
<p>可以在多个线程之间共享（全局变量）.</p>
<p>一经定义之后<strong>不可更改</strong>，且也需要大写和指明类型.</p>
<p>与上文中的常量有很多相似之处.</p>
<p>但不同之处在于，<strong>静态变量可通过mut修饰进行修改</strong>，但是修改的代码必须放在<strong>unsafe block</strong>内，如下所示：.</p>
<p><img src="/../assets/img/2-9.jpg" alt="图2-9" title="2-9"></p>
<p>常量在编译时被内联,但静态变量不会。在整个程序中静态变量只有一个实例,也就是说所有引用都指向同一个地址.</p>
<h3 id="（四）-变量遮蔽"><a href="#（四）-变量遮蔽" class="headerlink" title="（四）	 变量遮蔽"></a>（四）	 变量遮蔽</h3><p>示例如下：.</p>
<p><img src="/../assets/img/2-10.jpg" alt="图2-10" title="2-10"><br><img src="/../assets/img/2-11.jpg" alt="图2-11" title="2-11"><br>对于变量，可以直接通过let重复定义将之前的值覆盖掉.</p>
<p>此外，还有如下示例：.</p>
<p><img src="/../assets/img/2-12.jpg" alt="图2-12" title="2-12"></p>
<p>可以看出来，变量遮蔽只会在修改代码的小范围作用域内生效，并不能对外层生效.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/04/rust2/" data-id="cm0sf9tq30002sguy0gr82kin" data-title="rust 学习笔记二 变量与可变性" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/02/23/nftmint/">本地开发DEX：nft创建与mint的两种方式</a>
          </li>
        
          <li>
            <a href="/2025/02/15/dex/">本地开发DEX：购买ETF的两种策略</a>
          </li>
        
          <li>
            <a href="/2024/11/26/solana4/">solana 学习笔记四 Solana基础 - Token解析&amp;创建</a>
          </li>
        
          <li>
            <a href="/2024/11/21/solana3/">solana 学习笔记三 Solana基础，账户与简单交互</a>
          </li>
        
          <li>
            <a href="/2024/11/17/solana2/">solana 学习笔记二 Solana开发入门</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Liu Canzhu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>