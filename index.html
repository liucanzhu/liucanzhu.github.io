<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>canzhu&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="canzhu&#39;s blog">
<meta property="og:url" content="https://liucanzhu.github.io/index.html">
<meta property="og:site_name" content="canzhu&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liu Canzhu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="canzhu's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">canzhu&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://liucanzhu.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hardhat" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/30/hardhat/" class="article-date">
  <time class="dt-published" datetime="2025-03-30T12:01:15.535Z" itemprop="datePublished">2025-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/30/hardhat/">Hardhat持久化本地节点：保持合约状态的利器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在智能合约开发过程中，测试是不可或缺的一环。Hardhat作为一个流行的以太坊开发环境，提供了丰富的工具和功能来帮助开发者进行合约测试。然而，在实际开发中，我们经常会遇到一个问题：如何在本地环境中保持合约的状态，以便在多次测试中使用？本文将介绍一种通过Hardhat实现持久化本地节点的方法，并探讨其优劣和适用场景。</p>
<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>在Hardhat的默认配置下，每次运行测试或脚本时，都会重新启动一个本地节点，并在测试结束后自动关闭。这意味着每次运行脚本时，合约的状态都会被重置。对于一些需要多次交互的测试场景，这种方式显然不够高效。例如，当你需要在一个脚本中部署合约，然后在另一个脚本中调用该合约时，由于节点的状态已经丢失，你将无法直接获取到之前部署的合约实例。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>为了解决这个问题，我们可以使用Hardhat的持久化本地节点功能。通过手动启动一个本地节点，并在该节点上进行合约部署和测试，我们可以保持合约的状态，直到手动停止节点。</p>
<h3 id="步骤一：配置Hardhat"><a href="#步骤一：配置Hardhat" class="headerlink" title="步骤一：配置Hardhat"></a>步骤一：配置Hardhat</h3><p>首先，确保你的<code>hardhat.config.ts</code>文件中已经配置了正确的网络和分叉参数。以下是一个示例配置：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;@nomicfoundation/hardhat-ethers&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@nomicfoundation/hardhat-toolbox&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> dotenv <span class="keyword">from</span> <span class="string">&quot;dotenv&quot;</span>;</span><br><span class="line"></span><br><span class="line">dotenv.<span class="title function_">config</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">solidity</span>: <span class="string">&quot;0.8.28&quot;</span>,</span><br><span class="line">  <span class="attr">networks</span>: &#123;</span><br><span class="line">    <span class="attr">hardhat</span>: &#123;</span><br><span class="line">      <span class="attr">forking</span>: &#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;https://eth-mainnet.g.alchemy.com/v2/xxxx&quot;</span>, <span class="comment">//可从alchemy获取 </span></span><br><span class="line">        <span class="attr">blockNumber</span>: <span class="number">22152740</span>, <span class="comment">//如果你想要测试在某个特定区块后的合约行为，你可以设置 blockNumber 为那个区块的编号。</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">chainId</span>: <span class="number">31337</span>, <span class="comment">//使用一个不与公共网络冲突的值</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">localhost</span>: &#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&quot;http://127.0.0.1:8545&quot;</span>,</span><br><span class="line">      <span class="attr">chainId</span>: <span class="number">31337</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 其他网络配置...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> config;</span><br></pre></td></tr></table></figure>

<h3 id="步骤二：启动本地节点"><a href="#步骤二：启动本地节点" class="headerlink" title="步骤二：启动本地节点"></a>步骤二：启动本地节点</h3><p>在终端中运行以下命令来启动一个持久化的本地节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat node --fork https://eth-mainnet.g.alchemy.com/v2/xxxx --fork-block-number 22152740</span><br></pre></td></tr></table></figure>

<p>这将启动一个本地节点，并将其连接到主网的分叉。节点会运行在<code>http://127.0.0.1:8545</code>，直到你手动停止它。</p>
<h3 id="步骤三：部署合约"><a href="#步骤三：部署合约" class="headerlink" title="步骤三：部署合约"></a>步骤三：部署合约</h3><p>在新的终端窗口中，运行部署脚本来部署你的合约：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat run deployments/deploy.js --network localhost</span><br></pre></td></tr></table></figure>

<h3 id="步骤四：运行测试脚本"><a href="#步骤四：运行测试脚本" class="headerlink" title="步骤四：运行测试脚本"></a>步骤四：运行测试脚本</h3><p>部署完成后，你可以运行测试脚本来调用合约：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat run <span class="built_in">test</span>/crptoetf.swap.js --network localhost</span><br></pre></td></tr></table></figure>

<p>只要本地节点保持运行，合约的状态就会被保留，你可以多次运行测试脚本进行测试。</p>
<h2 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li><strong>保持合约状态</strong>：通过持久化的本地节点，你可以保持合约的状态，避免每次测试都要重新部署合约。</li>
<li><strong>支持多脚本测试</strong>：你可以在不同的脚本中调用同一个合约，方便进行复杂的测试场景。</li>
<li><strong>模拟主网环境</strong>：通过分叉主网，你可以在一个接近真实环境的环境中进行测试(可直接调用部署在主网上的合约)。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><strong>手动启动和停止</strong>：需要手动启动和停止本地节点，增加了操作的复杂性。</li>
<li><strong>资源占用</strong>：本地节点会占用一定的系统资源，可能会影响其他任务的运行。</li>
</ol>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>这种方法特别适合以下场景：</p>
<ol>
<li><strong>复杂测试</strong>：需要在多个脚本中调用同一个合约，或者需要保持合约状态进行多次交互的测试。</li>
<li><strong>主网模拟</strong>：需要在一个接近主网的环境中进行测试，以确保合约在主网上的表现与测试环境一致。</li>
<li><strong>开发调试</strong>：在开发过程中，需要频繁地测试和调试合约，保持合约状态可以提高开发效率。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过使用Hardhat的持久化本地节点功能，我们可以有效地保持合约的状态，提高测试效率。虽然这种方法需要一些额外的配置和操作，但在特定的测试场景中，其带来的便利性和效率提升是显而易见的。希望本文能够帮助你在智能合约开发中更好地利用这一功能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2025/03/30/hardhat/" data-id="cm8vmrz3m0000jwuyhd2nd022" data-title="Hardhat持久化本地节点：保持合约状态的利器" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-raydium" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/18/raydium/" class="article-date">
  <time class="dt-published" datetime="2025-03-18T12:05:04.023Z" itemprop="datePublished">2025-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/18/raydium/">在Solana Devnet上 对 raydium Swap功能的应用实践</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>目前在本地实现的DEX项目中，包含一个swap置换token功能，本打算用主网的raydium api完成，但是由于该api仅仅在主网有效 ，所以在 devnet 执行测试时采用了自行创建 pool 并完成swap 的方法，这里用官方demo  <a target="_blank" rel="noopener" href="https://github.com/raydium-io/raydium-sdk-V2-demo">https://github.com/raydium-io/raydium-sdk-V2-demo</a> 中的 <strong>amm pool</strong> 举例：</p>
<h3 id="（一）-环境准备"><a href="#（一）-环境准备" class="headerlink" title="（一） 环境准备"></a>（一） 环境准备</h3><h4 id="1：获取token"><a href="#1：获取token" class="headerlink" title="1：获取token"></a>1：获取token</h4><p>获为了在 devnet 上测试交换，最好创建两个带有供应的 SPL 代币并使用它。可以通过spl-token自行创建代币并mint对应数量，因为创建池子的前提是你的钱包里至少有对应数量的两种token（或者用空投到的wsol, usdc也可以, 这里附上一个领取devnet上usdc token空投的网址：<a target="_blank" rel="noopener" href="https://spl-token-faucet.com/?token-name=USDC">https://spl-token-faucet.com/?token-name=USDC</a>)</p>
<h4 id="2：配置Raydium-SDK"><a href="#2：配置Raydium-SDK" class="headerlink" title="2：配置Raydium SDK"></a>2：配置Raydium SDK</h4><p>修改config.ts中的钱包和RPC connetion配置, 并将创建raydium 实例中的对应mainnet配置项改为devnet</p>
<h3 id="（二）-创建与交易"><a href="#（二）-创建与交易" class="headerlink" title="（二） 创建与交易"></a>（二） 创建与交易</h3><h4 id="1：-创建交易市场（createMarket）"><a href="#1：-创建交易市场（createMarket）" class="headerlink" title="1： 创建交易市场（createMarket）"></a>1： 创建交易市场（createMarket）</h4><p>作用：建立代币交易对的市场订单簿</p>
<p>代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">createMarket</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> raydium = <span class="keyword">await</span> <span class="title function_">getRaydiumInstance</span>() <span class="comment">// 获取raydium实例</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; execute, extInfo, transactions &#125; = <span class="keyword">await</span> raydium.<span class="property">marketV2</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">      <span class="attr">baseInfo</span>: &#123;</span><br><span class="line">        <span class="attr">mint</span>: <span class="keyword">new</span> <span class="title class_">PublicKey</span>(<span class="string">&quot;token address&quot;</span>),</span><br><span class="line">        <span class="attr">decimals</span>: <span class="number">9</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">quoteInfo</span>: &#123;</span><br><span class="line">        <span class="attr">mint</span>: <span class="keyword">new</span> <span class="title class_">PublicKey</span>(<span class="string">&quot;token address&quot;</span>),</span><br><span class="line">        <span class="attr">decimals</span>: <span class="number">9</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">lotSize</span>: <span class="number">0.1</span>,</span><br><span class="line">      <span class="attr">tickSize</span>: <span class="number">0.0001</span>,  </span><br><span class="line">      <span class="attr">dexProgramId</span>: <span class="variable constant_">DEVNET_PROGRAM_ID</span>.<span class="property">OPENBOOK_MARKET</span>,</span><br><span class="line">      <span class="attr">computeBudgetConfig</span>: &#123;</span><br><span class="line">        <span class="attr">units</span>: <span class="number">600000</span>,  </span><br><span class="line">        <span class="attr">microLamports</span>: <span class="number">10000</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">txVersion</span>: <span class="number">0</span>,  </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">      <span class="string">`create market total <span class="subst">$&#123;transactions.length&#125;</span> txs, market info: `</span>,</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">keys</span>(extInfo.<span class="property">address</span>).<span class="title function_">reduce</span>(</span><br><span class="line">        <span class="function">(<span class="params">acc, cur</span>) =&gt;</span> (&#123;</span><br><span class="line">          ...acc,</span><br><span class="line">          [cur]: extInfo.<span class="property">address</span>[cur <span class="keyword">as</span> keyof <span class="keyword">typeof</span> extInfo.<span class="property">address</span>].<span class="title function_">toBase58</span>(),</span><br><span class="line">        &#125;),</span><br><span class="line">        &#123;&#125;</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Attempting to execute transactions...&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> txIds = <span class="keyword">await</span> <span class="title function_">execute</span>(&#123;</span><br><span class="line">      <span class="attr">sequentially</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;create market txIds:&#x27;</span>, txIds)</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">throw</span> error</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    process.<span class="title function_">exit</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加主函数的错误处理</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">main</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">createMarket</span>()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Fatal error:&#x27;</span>, error)</span><br><span class="line">    process.<span class="title function_">exit</span>(<span class="number">1</span>) <span class="comment">// 使用非零状态码退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>()</span><br></pre></td></tr></table></figure>
<p>原理：</p>
<p>通过OpenBook协议创建订单簿市场</p>
<p>lotSize 和 tickSize 决定了交易的精度和价格间隔</p>
<p>生成marketId作为市场的唯一标识</p>
<h4 id="2-创建AMM流动性池（createAmmPool）"><a href="#2-创建AMM流动性池（createAmmPool）" class="headerlink" title="2: 创建AMM流动性池（createAmmPool）"></a>2: 创建AMM流动性池（createAmmPool）</h4><p>作用：为交易对注入初始流动性</p>
<p>根据官方提示和刚才得出的marketid, 以及自身钱包余额修改参数：</p>
<p>代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">createAmmPool</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> raydium = <span class="keyword">await</span> <span class="title function_">getRaydiumInstance</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> marketId = <span class="keyword">new</span> <span class="title class_">PublicKey</span>(<span class="string">&quot;your market id&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> marketBufferInfo = <span class="keyword">await</span> raydium.<span class="property">connection</span>.<span class="title function_">getAccountInfo</span>(<span class="keyword">new</span> <span class="title class_">PublicKey</span>(marketId))</span><br><span class="line">  <span class="keyword">const</span> &#123; baseMint, quoteMint &#125; = <span class="variable constant_">MARKET_STATE_LAYOUT_V3</span>.<span class="title function_">decode</span>(marketBufferInfo!.<span class="property">data</span>)<span class="comment">// 根据id读取订单薄信息</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> baseMintInfo = <span class="keyword">await</span> raydium.<span class="property">token</span>.<span class="title function_">getTokenInfo</span>(baseMint)</span><br><span class="line">  <span class="keyword">const</span> quoteMintInfo = <span class="keyword">await</span> raydium.<span class="property">token</span>.<span class="title function_">getTokenInfo</span>(quoteMint)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> baseAmount = <span class="keyword">new</span> <span class="title function_">BN</span>(); <span class="comment">// 钱包余额需大于输入值</span></span><br><span class="line">  <span class="keyword">const</span> quoteAmount = <span class="keyword">new</span> <span class="title function_">BN</span>(); <span class="comment">// 钱包余额需大于输入值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    baseMintInfo.<span class="property">programId</span> !== <span class="variable constant_">TOKEN_PROGRAM_ID</span>.<span class="title function_">toBase58</span>() ||</span><br><span class="line">    quoteMintInfo.<span class="property">programId</span> !== <span class="variable constant_">TOKEN_PROGRAM_ID</span>.<span class="title function_">toBase58</span>()</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">      <span class="string">&#x27;amm pools with openbook market only support TOKEN_PROGRAM_ID mints, if you want to create pool with token-2022, please create cpmm pool instead&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (baseAmount.<span class="title function_">mul</span>(quoteAmount).<span class="title function_">lte</span>(<span class="keyword">new</span> <span class="title function_">BN</span>(<span class="number">1</span>).<span class="title function_">mul</span>(<span class="keyword">new</span> <span class="title function_">BN</span>(<span class="number">10</span> ** baseMintInfo.<span class="property">decimals</span>)).<span class="title function_">pow</span>(<span class="keyword">new</span> <span class="title function_">BN</span>(<span class="number">2</span>)))) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;initial liquidity too low, try adding more baseAmount/quoteAmount&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; execute, extInfo &#125; = <span class="keyword">await</span> raydium.<span class="property">liquidity</span>.<span class="title function_">createPoolV4</span>(&#123;</span><br><span class="line">    <span class="comment">// programId: AMM_V4,</span></span><br><span class="line">    <span class="attr">programId</span>: <span class="variable constant_">DEVNET_PROGRAM_ID</span>.<span class="property">AmmV4</span>, <span class="comment">// devnet</span></span><br><span class="line">    <span class="attr">marketInfo</span>: &#123;</span><br><span class="line">      marketId,</span><br><span class="line">      <span class="comment">// programId: OPEN_BOOK_PROGRAM,</span></span><br><span class="line">      <span class="attr">programId</span>: <span class="variable constant_">DEVNET_PROGRAM_ID</span>.<span class="property">OPENBOOK_MARKET</span>, <span class="comment">// devent</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">baseMintInfo</span>: &#123;</span><br><span class="line">      <span class="attr">mint</span>: baseMint,</span><br><span class="line">      <span class="attr">decimals</span>: baseMintInfo.<span class="property">decimals</span>, <span class="comment">// if you know mint decimals here, can pass number directly</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">quoteMintInfo</span>: &#123;</span><br><span class="line">      <span class="attr">mint</span>: quoteMint,</span><br><span class="line">      <span class="attr">decimals</span>: quoteMintInfo.<span class="property">decimals</span>, <span class="comment">// if you know mint decimals here, can pass number directly</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">baseAmount</span>: baseAmount,</span><br><span class="line">    <span class="attr">quoteAmount</span>: quoteAmount,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sol devnet faucet: https://faucet.solana.com/</span></span><br><span class="line">    <span class="comment">// baseAmount: new BN(4 * 10 ** 9), // if devent pool with sol/wsol, better use amount &gt;= 4*10**9</span></span><br><span class="line">    <span class="comment">// quoteAmount: new BN(4 * 10 ** 9), // if devent pool with sol/wsol, better use amount &gt;= 4*10**9</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">startTime</span>: <span class="keyword">new</span> <span class="title function_">BN</span>(<span class="number">0</span>), <span class="comment">// unit in seconds</span></span><br><span class="line">    <span class="attr">ownerInfo</span>: &#123;</span><br><span class="line">      <span class="attr">useSOLBalance</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">associatedOnly</span>: <span class="literal">false</span>,</span><br><span class="line">    txVersion,</span><br><span class="line">    <span class="comment">// feeDestinationId: FEE_DESTINATION_ID,</span></span><br><span class="line">    <span class="attr">feeDestinationId</span>: <span class="variable constant_">DEVNET_PROGRAM_ID</span>.<span class="property">FEE_DESTINATION_ID</span>, <span class="comment">// devnet</span></span><br><span class="line">    <span class="comment">// optional: set up priority fee here</span></span><br><span class="line">    <span class="comment">// computeBudgetConfig: &#123;</span></span><br><span class="line">    <span class="comment">//   units: 600000,</span></span><br><span class="line">    <span class="comment">//   microLamports: 4659150,</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// don&#x27;t want to wait confirm, set sendAndConfirm to false or don&#x27;t pass any params to execute</span></span><br><span class="line">  <span class="keyword">const</span> &#123; txId &#125; = <span class="keyword">await</span> <span class="title function_">execute</span>(&#123; <span class="attr">sendAndConfirm</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="string">&#x27;amm pool created! txId: &#x27;</span>,</span><br><span class="line">    txId,</span><br><span class="line">    <span class="string">&#x27;, poolKeys:&#x27;</span>,</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(extInfo.<span class="property">address</span>).<span class="title function_">reduce</span>(</span><br><span class="line">      <span class="function">(<span class="params">acc, cur</span>) =&gt;</span> (&#123;</span><br><span class="line">        ...acc,</span><br><span class="line">        [cur]: extInfo.<span class="property">address</span>[cur <span class="keyword">as</span> keyof <span class="keyword">typeof</span> extInfo.<span class="property">address</span>].<span class="title function_">toBase58</span>(),</span><br><span class="line">      &#125;),</span><br><span class="line">      &#123;&#125;</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  process.<span class="title function_">exit</span>() <span class="comment">// if you don&#x27;t want to end up node execution, comment this line</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** uncomment code below to execute */</span></span><br><span class="line"><span class="title function_">createAmmPool</span>()</span><br></pre></td></tr></table></figure>
<p>AMM机制：</p>
<p>基于恒定乘积公式 x * y &#x3D; k 确定价格</p>
<p>初始流动性比例决定代币的初始汇率</p>
<p>流动性提供者（LP）获得池子份额代币，在这一步后可以看到钱包中已经有了象征你提供的流动性份额的代币</p>
<h4 id="3-执行代币交换（swap）"><a href="#3-执行代币交换（swap）" class="headerlink" title="3: 执行代币交换（swap）"></a>3: 执行代币交换（swap）</h4><p>作用：实现代币间的自动做市商交易</p>
<p>代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">swap</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> raydium = <span class="keyword">await</span> <span class="title function_">getRaydiumInstance</span>()</span><br><span class="line">  <span class="keyword">const</span> amountIn = </span><br><span class="line">  <span class="keyword">const</span> inputMint = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">const</span> poolId = <span class="string">&#x27;&#x27;</span> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">poolInfo</span>: <span class="title class_">ApiV3PoolInfoStandardItem</span> | <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">poolKeys</span>: <span class="title class_">AmmV4Keys</span> | <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">rpcData</span>: <span class="title class_">AmmRpcData</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (raydium.<span class="property">cluster</span> === <span class="string">&#x27;mainnet&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// note: api doesn&#x27;t support get devnet pool info, so in devnet else we go rpc method</span></span><br><span class="line">    <span class="comment">// if you wish to get pool info from rpc, also can modify logic to go rpc method directly</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> raydium.<span class="property">api</span>.<span class="title function_">fetchPoolById</span>(&#123; <span class="attr">ids</span>: poolId &#125;)</span><br><span class="line">    poolInfo = data[<span class="number">0</span>] <span class="keyword">as</span> <span class="title class_">ApiV3PoolInfoStandardItem</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isValidAmm</span>(poolInfo.<span class="property">programId</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;target pool is not AMM pool&#x27;</span>)</span><br><span class="line">    poolKeys = <span class="keyword">await</span> raydium.<span class="property">liquidity</span>.<span class="title function_">getAmmPoolKeys</span>(poolId)</span><br><span class="line">    rpcData = <span class="keyword">await</span> raydium.<span class="property">liquidity</span>.<span class="title function_">getRpcPoolInfo</span>(poolId)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// note: getPoolInfoFromRpc method only return required pool data for computing not all detail pool info</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> raydium.<span class="property">liquidity</span>.<span class="title function_">getPoolInfoFromRpc</span>(&#123; poolId &#125;)</span><br><span class="line">    poolInfo = data.<span class="property">poolInfo</span></span><br><span class="line">    poolKeys = data.<span class="property">poolKeys</span></span><br><span class="line">    rpcData = data.<span class="property">poolRpcData</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> [baseReserve, quoteReserve, status] = [rpcData.<span class="property">baseReserve</span>, rpcData.<span class="property">quoteReserve</span>, rpcData.<span class="property">status</span>.<span class="title function_">toNumber</span>()]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (poolInfo.<span class="property">mintA</span>.<span class="property">address</span> !== inputMint &amp;&amp; poolInfo.<span class="property">mintB</span>.<span class="property">address</span> !== inputMint)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;input mint does not match pool&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> baseIn = inputMint === poolInfo.<span class="property">mintA</span>.<span class="property">address</span></span><br><span class="line">  <span class="keyword">const</span> [mintIn, mintOut] = baseIn ? [poolInfo.<span class="property">mintA</span>, poolInfo.<span class="property">mintB</span>] : [poolInfo.<span class="property">mintB</span>, poolInfo.<span class="property">mintA</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> out = raydium.<span class="property">liquidity</span>.<span class="title function_">computeAmountOut</span>(&#123;</span><br><span class="line">    <span class="attr">poolInfo</span>: &#123;</span><br><span class="line">      ...poolInfo,</span><br><span class="line">      baseReserve,</span><br><span class="line">      quoteReserve,</span><br><span class="line">      status,</span><br><span class="line">      <span class="attr">version</span>: <span class="number">4</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">amountIn</span>: <span class="keyword">new</span> <span class="title function_">BN</span>(amountIn * <span class="number">10</span> ** <span class="number">9</span>),</span><br><span class="line">    <span class="attr">mintIn</span>: mintIn.<span class="property">address</span>,</span><br><span class="line">    <span class="attr">mintOut</span>: mintOut.<span class="property">address</span>,</span><br><span class="line">    <span class="attr">slippage</span>: <span class="number">0.05</span>, <span class="comment">// range: 1 ~ 0.0001, means 100% ~ 0.01%</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="string">`computed swap <span class="subst">$&#123;<span class="keyword">new</span> Decimal(amountIn)</span></span></span><br><span class="line"><span class="subst"><span class="string">      .div(<span class="number">10</span> ** mintIn.decimals)</span></span></span><br><span class="line"><span class="subst"><span class="string">      .toDecimalPlaces(mintIn.decimals)</span></span></span><br><span class="line"><span class="subst"><span class="string">      .toString()&#125;</span> <span class="subst">$&#123;mintIn.<span class="built_in">symbol</span> || mintIn.address&#125;</span> to <span class="subst">$&#123;<span class="keyword">new</span> Decimal(out.amountOut.toString())</span></span></span><br><span class="line"><span class="subst"><span class="string">        .div(<span class="number">10</span> ** mintOut.decimals)</span></span></span><br><span class="line"><span class="subst"><span class="string">        .toDecimalPlaces(mintOut.decimals)</span></span></span><br><span class="line"><span class="subst"><span class="string">        .toString()&#125;</span> <span class="subst">$&#123;mintOut.<span class="built_in">symbol</span> || mintOut.address&#125;</span>, minimum amount out <span class="subst">$&#123;<span class="keyword">new</span> Decimal(out.minAmountOut.toString())</span></span></span><br><span class="line"><span class="subst"><span class="string">          .div(<span class="number">10</span> ** mintOut.decimals)</span></span></span><br><span class="line"><span class="subst"><span class="string">          .toDecimalPlaces(mintOut.decimals)&#125;</span> <span class="subst">$&#123;mintOut.<span class="built_in">symbol</span> || mintOut.address&#125;</span>`</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; execute &#125; = <span class="keyword">await</span> raydium.<span class="property">liquidity</span>.<span class="title function_">swap</span>(&#123;</span><br><span class="line">    poolInfo,</span><br><span class="line">    poolKeys,</span><br><span class="line">    <span class="attr">amountIn</span>: <span class="keyword">new</span> <span class="title function_">BN</span>(amountIn * <span class="number">10</span> ** <span class="number">9</span>),</span><br><span class="line">    <span class="attr">amountOut</span>: out.<span class="property">minAmountOut</span>, <span class="comment">// out.amountOut means amount &#x27;without&#x27; slippage</span></span><br><span class="line">    <span class="attr">fixedSide</span>: <span class="string">&#x27;in&#x27;</span>,</span><br><span class="line">    <span class="attr">inputMint</span>: mintIn.<span class="property">address</span>,</span><br><span class="line">    txVersion,</span><br><span class="line">    <span class="attr">config</span>: &#123;</span><br><span class="line">      <span class="attr">associatedOnly</span>: <span class="literal">false</span>, <span class="comment">// 允许自动创建非关联账户（若设为 true，则必须已有 ATA）</span></span><br><span class="line">      <span class="attr">outputUseSolBalance</span>: <span class="literal">false</span>, <span class="comment">// 禁用直接使用 SOL 余额接收代币（强制创建 ATA）</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional: set up token account</span></span><br><span class="line">    <span class="comment">// config: &#123;</span></span><br><span class="line">    <span class="comment">//   inputUseSolBalance: true, // default: true, if you want to use existed wsol token account to pay token in, pass false</span></span><br><span class="line">    <span class="comment">//   outputUseSolBalance: true, // default: true, if you want to use existed wsol token account to receive token out, pass false</span></span><br><span class="line">    <span class="comment">//   associatedOnly: true, // default: true, if you want to use ata only, pass true</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional: set up priority fee here</span></span><br><span class="line">    <span class="comment">// computeBudgetConfig: &#123;</span></span><br><span class="line">    <span class="comment">//   units: 600000,</span></span><br><span class="line">    <span class="comment">//   microLamports: 46591500,</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional: add transfer sol to tip account instruction. e.g sent tip to jito</span></span><br><span class="line">    <span class="comment">// txTipConfig: &#123;</span></span><br><span class="line">    <span class="comment">//   address: new PublicKey(&#x27;96gYZGLnJYVFmbjzopPSU6QiEV5fGqZNyN9nmNhvrZU5&#x27;),</span></span><br><span class="line">    <span class="comment">//   amount: new BN(10000000), // 0.01 sol</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">printSimulateInfo</span>()</span><br><span class="line">  <span class="comment">// don&#x27;t want to wait confirm, set sendAndConfirm to false or don&#x27;t pass any params to execute</span></span><br><span class="line">  <span class="keyword">const</span> &#123; txId &#125; = <span class="keyword">await</span> <span class="title function_">execute</span>(&#123; <span class="attr">sendAndConfirm</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`swap successfully in amm pool:`</span>, &#123; <span class="attr">txId</span>: <span class="string">`https://explorer.solana.com/tx/<span class="subst">$&#123;txId&#125;</span>`</span> &#125;)</span><br><span class="line"></span><br><span class="line">  process.<span class="title function_">exit</span>() <span class="comment">// if you don&#x27;t want to end up node execution, comment this line</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** uncomment code below to execute */</span></span><br><span class="line"><span class="title function_">swap</span>()</span><br></pre></td></tr></table></figure>

<h4 id="执行过程："><a href="#执行过程：" class="headerlink" title="执行过程："></a>执行过程：</h4><p>根据当前池子储备计算预期输出</p>
<p>应用滑点保护确定最小可接受量</p>
<p>通过Raydium的AMM V4程序执行链上交换</p>
<h4 id="常见问题排查"><a href="#常见问题排查" class="headerlink" title="常见问题排查"></a>常见问题排查</h4><h5 id="交易失败：计算资源不足"><a href="#交易失败：计算资源不足" class="headerlink" title="交易失败：计算资源不足"></a>交易失败：计算资源不足</h5><p>在swap函数中加上以下配置：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computeBudgetConfig</span>: &#123;</span><br><span class="line">  <span class="attr">units</span>: <span class="number">600000</span>,      <span class="comment">// 增加计算单元</span></span><br><span class="line">  <span class="attr">microLamports</span>: <span class="number">10000</span> <span class="comment">// 提高优先级费用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代币类型不匹配"><a href="#代币类型不匹配" class="headerlink" title="代币类型不匹配"></a>代币类型不匹配</h5><p>检查代币的programId是否为TOKEN_PROGRAM_ID</p>
<p>Token-2022代币需使用CPMM池类型</p>
<h5 id="流动性不足错误"><a href="#流动性不足错误" class="headerlink" title="流动性不足错误"></a>流动性不足错误</h5><p>确保初始流动性满足 baseAmount * quoteAmount ≥ (1e9)^2</p>
<p>顺利的话，执行完swap之后就可以观察到账户中 in 和 out token 在按照amm池计算出来的汇率变化了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2025/03/18/raydium/" data-id="cm8ejx85p00003wuyewb43pyv" data-title="在Solana Devnet上 对 raydium Swap功能的应用实践" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-nftmint" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/23/nftmint/" class="article-date">
  <time class="dt-published" datetime="2025-02-23T09:21:54.855Z" itemprop="datePublished">2025-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/23/nftmint/">本地开发DEX：nft创建与mint的两种方式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在本地开发这个功能的时候，对metaplex 官网以及其他博客的信息进行了调研和整合，最终发现以下两种方式：anchor_spl 的 create_master_edition_v3 和 create_metadata_accounts_v3，以及 mpl_token_metadata 的 CreateV1CpiBuilder 和 MintV1CpiBuilder。我们将从代码结构、功能实现、易用性和灵活性等方面进行分析，并结合代码示例详细讲解它们的实现过程。</p>
<p>这两种方式其实本质上非常相似，先看依赖关系：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> anchor_spl::&#123;</span><br><span class="line">    associated_token::AssociatedToken,</span><br><span class="line">    metadata::&#123;</span><br><span class="line">        create_master_edition_v3, create_metadata_accounts_v3,</span><br><span class="line">        mpl_token_metadata::&#123;</span><br><span class="line">            instructions::&#123;CreateV1CpiBuilder, MintV1CpiBuilder&#125;,</span><br><span class="line">            types::&#123;DataV2, PrintSupply&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        CreateMasterEditionV3, CreateMetadataAccountsV3, Metadata,</span><br><span class="line">    &#125;,</span><br><span class="line">    token::&#123;mint_to, Mint, MintTo, Token, TokenAccount&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-先看看代码示例"><a href="#1-先看看代码示例" class="headerlink" title="1. 先看看代码示例"></a><strong>1. 先看看代码示例</strong></h3><h4 id="第一种：anchor-spl-的-create-master-edition-v3-和-create-metadata-accounts-v3"><a href="#第一种：anchor-spl-的-create-master-edition-v3-和-create-metadata-accounts-v3" class="headerlink" title="第一种：anchor_spl 的 create_master_edition_v3 和 create_metadata_accounts_v3"></a>第一种：anchor_spl 的 create_master_edition_v3 和 create_metadata_accounts_v3</h4><p>主要有以下步骤：</p>
<h5 id="创建-Metadata-账户："><a href="#创建-Metadata-账户：" class="headerlink" title="创建 Metadata 账户："></a>创建 Metadata 账户：</h5><p>调用 create_metadata_accounts_v3，设置 NFT 的名称、符号、URI 等<strong>元数据</strong>。</p>
<p>需要手动传递 metadata_account、mint_account、payer 等账户信息。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">create_metadata_accounts_v3</span>(</span><br><span class="line">    CpiContext::<span class="title function_ invoke__">new_with_signer</span>(</span><br><span class="line">        ctx.accounts.token_metadata_program.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">        CreateMetadataAccountsV3 &#123;</span><br><span class="line">            metadata: ctx.accounts.metadata_account.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">            mint: ctx.accounts.nft_mint_account.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">            mint_authority: ctx.accounts.nft_mint_account.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">            update_authority: ctx.accounts.nft_mint_account.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">            payer: ctx.accounts.authority.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">            system_program: ctx.accounts.system_program.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">            rent: ctx.accounts.rent.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">        &#125;,</span><br><span class="line">        signer_seeds,</span><br><span class="line">    ),</span><br><span class="line">    DataV2 &#123;</span><br><span class="line">        name: <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125; #&#123;&#125;&quot;</span>, IbuidlNft::TOKEN_NAME.<span class="title function_ invoke__">to_string</span>(), nft_id),</span><br><span class="line">        symbol: IbuidlNft::TOKEN_SYMBOL.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        uri: IbuidlNft::TOKEN_URL.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        seller_fee_basis_points: <span class="number">0</span>,</span><br><span class="line">        creators: <span class="literal">None</span>,</span><br><span class="line">        collection: <span class="literal">None</span>,</span><br><span class="line">        uses: <span class="literal">None</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">false</span>, <span class="comment">// Is mutable</span></span><br><span class="line">    <span class="literal">true</span>,  <span class="comment">// Update authority is signer</span></span><br><span class="line">    <span class="literal">None</span>,  <span class="comment">// Collection details</span></span><br><span class="line">)?;</span><br></pre></td></tr></table></figure>

<p>代码讲解：</p>
<p>create_metadata_accounts_v3 用于创建 NFT 的 Metadata（元数据） 账户。</p>
<p>DataV2 结构体定义了 NFT 的元数据，包括名称、符号、URI 等。</p>
<h5 id="创建-Master-Edition："><a href="#创建-Master-Edition：" class="headerlink" title="创建 Master Edition："></a>创建 Master Edition：</h5><p>调用 create_master_edition_v3，设置 NFT 的 Master Edition。</p>
<p>需要传递 master_edition_account、metadata_account 和 mint_account。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">create_master_edition_v3</span>(</span><br><span class="line">    CpiContext::<span class="title function_ invoke__">new_with_signer</span>(</span><br><span class="line">        ctx.accounts.token_metadata_program.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">        CreateMasterEditionV3 &#123;</span><br><span class="line">            edition: ctx.accounts.master_edition_account.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">            payer: ctx.accounts.authority.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">            mint: ctx.accounts.nft_mint_account.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">            metadata: ctx.accounts.metadata_account.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">            mint_authority: ctx.accounts.nft_mint_account.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">            update_authority: ctx.accounts.nft_mint_account.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">            system_program: ctx.accounts.system_program.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">            token_program: ctx.accounts.token_program.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">            rent: ctx.accounts.rent.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">        &#125;,</span><br><span class="line">        signer_seeds,</span><br><span class="line">    ),</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="number">1</span>),</span><br><span class="line">)?;</span><br></pre></td></tr></table></figure>

<p>代码讲解：</p>
<p>create_master_edition_v3 用于创建 NFT 的 Master Edition（主账户）。</p>
<p>CpiContext::new_with_signer 用于创建 CPI 上下文，并传递签名者种子。</p>
<h5 id="Mint-Token："><a href="#Mint-Token：" class="headerlink" title="Mint Token："></a>Mint Token：</h5><p>调用 mint_to，将 NFT Mint 到指定的关联 Token 账户。</p>
<p>需要传递 mint_account、associated_token_account 和 authority。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">mint_to</span>(</span><br><span class="line">    CpiContext::<span class="title function_ invoke__">new_with_signer</span>(</span><br><span class="line">        ctx.accounts.token_program.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">        MintTo &#123;</span><br><span class="line">            mint: ctx.accounts.nft_mint_account.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">            to: ctx.accounts.nft_associated_token_account.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">            authority: ctx.accounts.nft_mint_account.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">        &#125;,</span><br><span class="line">        signer_seeds,</span><br><span class="line">    ),</span><br><span class="line">    <span class="number">1</span>, <span class="comment">// 1 token</span></span><br><span class="line">)?;</span><br></pre></td></tr></table></figure>

<p>代码讲解：</p>
<p>mint_to 用于将 NFT Mint 到指定的关联 Token 账户。</p>
<p>CpiContext::new_with_signer 用于创建 CPI 上下文，并传递签名者种子。</p>
<h4 id="第二种：anchor-spl-的-mpl-token-metadata-的-CreateV1CpiBuilder-和-MintV1CpiBuilder"><a href="#第二种：anchor-spl-的-mpl-token-metadata-的-CreateV1CpiBuilder-和-MintV1CpiBuilder" class="headerlink" title="第二种：anchor_spl 的 mpl_token_metadata 的 CreateV1CpiBuilder 和 MintV1CpiBuilder"></a>第二种：anchor_spl 的 mpl_token_metadata 的 CreateV1CpiBuilder 和 MintV1CpiBuilder</h4><p>主要有以下步骤：</p>
<h5 id="创建-Metadata-和-Master-Edition："><a href="#创建-Metadata-和-Master-Edition：" class="headerlink" title="创建 Metadata 和 Master Edition："></a>创建 Metadata 和 Master Edition：</h5><p>使用 CreateV1CpiBuilder，<strong>一次性创建 Metadata 和 Master Edition</strong>, 将第一种方法的步骤1，2结合了起来。</p>
<p>通过链式调用设置<strong>一次性设置</strong> NFT 的名称、符号、URI、打印供应量等参数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CreateV1CpiBuilder::<span class="title function_ invoke__">new</span>(ctx.accounts.token_metadata_program.<span class="title function_ invoke__">as_ref</span>())</span><br><span class="line">    .<span class="title function_ invoke__">mint</span>(ctx.accounts.nft_mint_account.<span class="title function_ invoke__">as_ref</span>(), <span class="literal">true</span>)</span><br><span class="line">    .<span class="title function_ invoke__">metadata</span>(ctx.accounts.metadata_account.<span class="title function_ invoke__">as_ref</span>())</span><br><span class="line">    .<span class="title function_ invoke__">master_edition</span>(<span class="title function_ invoke__">Some</span>(ctx.accounts.master_edition_account.<span class="title function_ invoke__">as_ref</span>()))</span><br><span class="line">    .<span class="title function_ invoke__">authority</span>(ctx.accounts.nft_mint_account.<span class="title function_ invoke__">as_ref</span>())</span><br><span class="line">    .<span class="title function_ invoke__">update_authority</span>(ctx.accounts.nft_mint_account.<span class="title function_ invoke__">as_ref</span>(), <span class="literal">true</span>)</span><br><span class="line">    .<span class="title function_ invoke__">payer</span>(ctx.accounts.authority.<span class="title function_ invoke__">as_ref</span>())</span><br><span class="line">    .<span class="title function_ invoke__">seller_fee_basis_points</span>(<span class="number">0</span>)</span><br><span class="line">    .<span class="title function_ invoke__">system_program</span>(ctx.accounts.system_program.<span class="title function_ invoke__">as_ref</span>())</span><br><span class="line">    .<span class="title function_ invoke__">sysvar_instructions</span>(ctx.accounts.rent.<span class="title function_ invoke__">as_ref</span>())</span><br><span class="line">    .<span class="title function_ invoke__">spl_token_program</span>(<span class="title function_ invoke__">Some</span>(ctx.accounts.token_program.<span class="title function_ invoke__">as_ref</span>()))</span><br><span class="line">    .<span class="title function_ invoke__">name</span>(IbuidlNft::TOKEN_NAME.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    .<span class="title function_ invoke__">symbol</span>(IbuidlNft::TOKEN_SYMBOL.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    .<span class="title function_ invoke__">uri</span>(IbuidlNft::TOKEN_URL.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    .<span class="title function_ invoke__">print_supply</span>(PrintSupply::Zero)</span><br><span class="line">    .<span class="title function_ invoke__">invoke_signed</span>(signer_seeds)?;</span><br></pre></td></tr></table></figure>

<p>代码讲解：</p>
<p>CreateV1CpiBuilder 用于创建 Metadata 和 Master Edition。</p>
<p>通过链式调用设置 NFT 的名称、符号、URI 等参数。</p>
<p>invoke_signed 用于执行 CPI 调用，并传递签名者种子。</p>
<h5 id="Mint-Token：-1"><a href="#Mint-Token：-1" class="headerlink" title="Mint Token："></a>Mint Token：</h5><p>使用 MintV1CpiBuilder，将 NFT Mint 到指定的关联 Token 账户。</p>
<p>通过链式调用设置 Mint 的数量、接收账户和权限。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MintV1CpiBuilder::<span class="title function_ invoke__">new</span>(ctx.accounts.token_metadata_program.<span class="title function_ invoke__">as_ref</span>())</span><br><span class="line">    .<span class="title function_ invoke__">mint</span>(ctx.accounts.nft_mint_account.<span class="title function_ invoke__">as_ref</span>())</span><br><span class="line">    .<span class="title function_ invoke__">metadata</span>(&amp;ctx.accounts.metadata_account.<span class="title function_ invoke__">to_account_info</span>())</span><br><span class="line">    .<span class="title function_ invoke__">master_edition</span>(<span class="title function_ invoke__">Some</span>(&amp;ctx.accounts.master_edition_account.<span class="title function_ invoke__">to_account_info</span>()))</span><br><span class="line">    .<span class="title function_ invoke__">token</span>(&amp;ctx.accounts.nft_associated_token_account.<span class="title function_ invoke__">to_account_info</span>())</span><br><span class="line">    .<span class="title function_ invoke__">token_owner</span>(<span class="title function_ invoke__">Some</span>(ctx.accounts.authority.<span class="title function_ invoke__">as_ref</span>()))</span><br><span class="line">    .<span class="title function_ invoke__">payer</span>(ctx.accounts.authority.<span class="title function_ invoke__">as_ref</span>())</span><br><span class="line">    .<span class="title function_ invoke__">authority</span>(ctx.accounts.nft_mint_account.<span class="title function_ invoke__">as_ref</span>())</span><br><span class="line">    .<span class="title function_ invoke__">system_program</span>(ctx.accounts.system_program.<span class="title function_ invoke__">as_ref</span>())</span><br><span class="line">    .<span class="title function_ invoke__">sysvar_instructions</span>(ctx.accounts.rent.<span class="title function_ invoke__">as_ref</span>())</span><br><span class="line">    .<span class="title function_ invoke__">spl_token_program</span>(ctx.accounts.token_program.<span class="title function_ invoke__">as_ref</span>())</span><br><span class="line">    .<span class="title function_ invoke__">spl_ata_program</span>(ctx.accounts.associated_token_program.<span class="title function_ invoke__">as_ref</span>())</span><br><span class="line">    .<span class="title function_ invoke__">amount</span>(<span class="number">1</span>)</span><br><span class="line">    .<span class="title function_ invoke__">invoke_signed</span>(signer_seeds)?;</span><br></pre></td></tr></table></figure>

<p>代码讲解：</p>
<p>MintV1CpiBuilder 用于将 NFT Mint 到指定的关联 Token 账户。</p>
<p>通过链式调用设置 Mint 的数量、接收账户和权限。</p>
<p>invoke_signed 用于执行 CPI 调用，并传递签名者种子。</p>
<h3 id="2-实践建议"><a href="#2-实践建议" class="headerlink" title="2. 实践建议."></a><strong>2. 实践建议</strong>.</h3><p>选择 <code>create_master_edition_v3</code> 和 <code>create_metadata_accounts_v3</code> 的场景：</p>
<p>如果你需要 完全控制 NFT 创建的每个步骤。</p>
<p>如果你对 Solana 的 CPI 和账户管理有较深的理解。</p>
<p>如果你的项目有 复杂的定制化需求。</p>
<p>举个例子：看似CreateV1CpiBuilder非常方便，但如果你需要动态调整 Metadata 或 Master Edition 的某些参数（例如根据用户输入动态设置 seller_fee_basis_points），Builder 的链式调用可能无法满足需求。相比之下，CreateMetadataAccountsV3 和 CreateMasterEditionV3 可以分别调用，灵活性更高。</p>
<p>选择 <code>CreateV1CpiBuilder</code> 和 <code>MintV1CpiBuilder</code> 的场景：</p>
<p>如果你希望 快速开发，并且流程较为标准化。</p>
<p>如果你需要 减少代码量，提高开发效率。</p>
<p>如果你的项目是 批量创建 NFT 或 原型设计。</p>
<ol start="5">
<li>总结</li>
</ol>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>方法一</strong></th>
<th><strong>方法二</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>代码结构</strong></td>
<td>分散，多个独立 CPI 调用</td>
<td>集中，使用 Builder 模式</td>
</tr>
<tr>
<td><strong>功能实现</strong></td>
<td>灵活，适合复杂场景</td>
<td>简洁，适合标准化流程</td>
</tr>
<tr>
<td><strong>易用性</strong></td>
<td>较低，需要手动管理多个步骤</td>
<td>较高，API 更直观</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>高，适合定制化需求</td>
<td>较低，依赖于 Builder 的功能</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>可能较高开销（多个 CPI 调用）</td>
<td>可能较低开销（优化后的 CPI 调用）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>复杂、定制化的 NFT 创建流程</td>
<td>快速开发的 NFT 创建流程</td>
</tr>
</tbody></table>
<p>注：二者性能的优劣不太确定：因为第二种：Builder 模式可能会生成额外的中间对象或调用，增加交易的开销。</p>
<p>综上所述，如果你需要 灵活性和精细控制，第一种方式 是更好的选择；如果你追求 开发效率和简洁性，第二种方式 则更为合适。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2025/02/23/nftmint/" data-id="cm7hghy0i0000icuy0w4i8obn" data-title="本地开发DEX：nft创建与mint的两种方式" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-dex" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/15/dex/" class="article-date">
  <time class="dt-published" datetime="2025-02-15T10:05:18.798Z" itemprop="datePublished">2025-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/15/dex/">本地开发DEX：购买ETF的两种策略</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="在-Solana-上实现-ETF-购买：两种-Token-存入方法的对比"><a href="#在-Solana-上实现-ETF-购买：两种-Token-存入方法的对比" class="headerlink" title="在 Solana 上实现 ETF 购买：两种 Token 存入方法的对比"></a><strong>在 Solana 上实现 ETF 购买：两种 Token 存入方法的对比</strong></h2><p>在 Solana 区块链上开发去中心化交易所（DEX）并实现 ETF（交易所交易基金）的购买功能的过程中，一个关键步骤是向合约账户存入指定种类的 Token。本文将重点介绍两种实现方法，并分析它们的优缺点。</p>
<hr>
<h3 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a><strong>1. 背景介绍</strong></h3><p>ETF 是一种包含多种资产的投资工具，用户可以通过购买 ETF 来间接持有多种代币。在 Solana 上实现 ETF 购买功能时，我们需要解决以下问题：</p>
<ul>
<li>如何将用户持有的多种代币存入合约账户？</li>
<li>如何确保交易的原子性和安全性？</li>
<li>如何高效地处理多种代币的转移？</li>
</ul>
<p>针对这些问题，我们提出了两种解决方案：</p>
<ol>
<li><strong>使用 <code>remaining_accounts</code> 将所有需要的账户一起传入</strong>。</li>
<li><strong>每次只进行一种代币的转移，将交易原子化</strong>。</li>
</ol>
<hr>
<h3 id="2-方法一：使用-remaining-accounts-将所有账户一起传入"><a href="#2-方法一：使用-remaining-accounts-将所有账户一起传入" class="headerlink" title="2. 方法一：使用 remaining_accounts 将所有账户一起传入"></a><strong>2. 方法一：使用 <code>remaining_accounts</code> 将所有账户一起传入</strong></h3><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a><strong>实现思路</strong></h4><ul>
<li>将所有需要转移的代币账户（包括用户的 Token 账户和合约的 Token 账户）通过 <code>remaining_accounts</code> 传入合约。在合约中遍历这些账户，逐一进行代币转移。</li>
</ul>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h4><ul>
<li>合约部分</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[program]</span></span><br><span class="line"><span class="meta">#[derive(Accounts)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">EtfTokenTransaction</span>&lt;<span class="symbol">&#x27;info</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// etf信息和控制token资产</span></span><br><span class="line">    <span class="meta">#[account(</span></span><br><span class="line"><span class="meta">        seeds = [</span></span><br><span class="line"><span class="meta">            EtfToken::SEED_PREFIX.as_bytes(),</span></span><br><span class="line"><span class="meta">            etf_token_mint_account.key().as_ref(),</span></span><br><span class="line"><span class="meta">        ]</span>,</span><br><span class="line">        bump,</span><br><span class="line">    )]</span><br><span class="line">    <span class="keyword">pub</span> etf_token_info: Account&lt;<span class="symbol">&#x27;info</span>, EtfToken&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[account(mut)]</span></span><br><span class="line">    <span class="keyword">pub</span> etf_token_mint_account: Account&lt;<span class="symbol">&#x27;info</span>, Mint&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[account(</span></span><br><span class="line"><span class="meta">        init_if_needed,</span></span><br><span class="line"><span class="meta">        payer = authority,</span></span><br><span class="line"><span class="meta">        associated_token::mint = etf_token_mint_account,</span></span><br><span class="line"><span class="meta">        associated_token::authority = authority,</span></span><br><span class="line"><span class="meta">    )]</span></span><br><span class="line">    <span class="keyword">pub</span> etf_token_ata: Account&lt;<span class="symbol">&#x27;info</span>, TokenAccount&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[account(mut)]</span></span><br><span class="line">    <span class="keyword">pub</span> authority: Signer&lt;<span class="symbol">&#x27;info</span>&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> token_program: Program&lt;<span class="symbol">&#x27;info</span>, Token&gt;,</span><br><span class="line">    <span class="keyword">pub</span> associated_token_program: Program&lt;<span class="symbol">&#x27;info</span>, AssociatedToken&gt;,</span><br><span class="line">    <span class="keyword">pub</span> system_program: Program&lt;<span class="symbol">&#x27;info</span>, System&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">etf_token_mint</span>&lt;<span class="symbol">&#x27;info</span>&gt;(</span><br><span class="line">    ctx: Context&lt;<span class="symbol">&#x27;_</span>, <span class="symbol">&#x27;_</span>, <span class="symbol">&#x27;_</span>, <span class="symbol">&#x27;info</span>, EtfTokenTransaction&lt;<span class="symbol">&#x27;info</span>&gt;&gt;,</span><br><span class="line">    lamports: <span class="type">u64</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// 使用remaining_accounts</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">accounts</span> = ctx</span><br><span class="line">        .remaining_accounts</span><br><span class="line">        .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|x| (x.<span class="title function_ invoke__">key</span>(), x.<span class="title function_ invoke__">to_owned</span>()))</span><br><span class="line">        .collect::&lt;HashMap&lt;_, _&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    msg!(<span class="string">&quot;accounts: &#123;:?&#125;&quot;</span>, accounts.<span class="title function_ invoke__">keys</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">x</span> <span class="keyword">in</span> &amp;ctx.accounts.etf_token_info.constitunent &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">from_ata</span> = accounts</span><br><span class="line">            .<span class="title function_ invoke__">get</span>(&amp;<span class="title function_ invoke__">get_associated_token_address</span>(</span><br><span class="line">                &amp;ctx.accounts.authority.<span class="title function_ invoke__">key</span>(),</span><br><span class="line">                &amp;x.token,</span><br><span class="line">            ))</span><br><span class="line">            .<span class="title function_ invoke__">ok_or</span>(TokenMintError::InvalidAccounts)?;</span><br><span class="line"></span><br><span class="line">        msg!(</span><br><span class="line">            <span class="string">&quot;transfer to: &#123;&#125;&quot;</span>,</span><br><span class="line">            &amp;<span class="title function_ invoke__">get_associated_token_address</span>(&amp;ctx.accounts.etf_token_info.<span class="title function_ invoke__">key</span>(), &amp;x.token,)</span><br><span class="line">                .<span class="title function_ invoke__">key</span>()</span><br><span class="line">                .<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">to_ata</span> = accounts</span><br><span class="line">            .<span class="title function_ invoke__">get</span>(&amp;<span class="title function_ invoke__">get_associated_token_address</span>(</span><br><span class="line">                &amp;ctx.accounts.etf_token_info.<span class="title function_ invoke__">key</span>(),</span><br><span class="line">                &amp;x.token,</span><br><span class="line">            ))</span><br><span class="line">            .<span class="title function_ invoke__">ok_or</span>(TokenMintError::InvalidAccounts)?;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">amount</span> = x.weight <span class="keyword">as</span> <span class="type">u64</span> * lamports / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">transfer</span>(</span><br><span class="line">            CpiContext::<span class="title function_ invoke__">new</span>(</span><br><span class="line">                ctx.accounts.token_program.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">                Transfer &#123;</span><br><span class="line">                    from: from_ata.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">                    to: to_ata.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">                    authority: ctx.accounts.authority.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">                &#125;,</span><br><span class="line">            ),</span><br><span class="line">            amount,</span><br><span class="line">        )?;</span><br><span class="line"></span><br><span class="line">        msg!(<span class="string">&quot;success transfer token: &#123;&#125;&quot;</span>, x.token.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PDA signer seeds</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = ctx.accounts.etf_token_mint_account.<span class="title function_ invoke__">key</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">signer_seeds</span>: &amp;[&amp;[&amp;[<span class="type">u8</span>]]] = &amp;[&amp;[</span><br><span class="line">        EtfToken::SEED_PREFIX.<span class="title function_ invoke__">as_bytes</span>(),</span><br><span class="line">        m.<span class="title function_ invoke__">as_ref</span>(),</span><br><span class="line">        &amp;[ctx.bumps.etf_token_info],</span><br><span class="line">    ]];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mint token</span></span><br><span class="line">    <span class="title function_ invoke__">mint_to</span>(</span><br><span class="line">        CpiContext::<span class="title function_ invoke__">new_with_signer</span>(</span><br><span class="line">            ctx.accounts.token_program.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">            MintTo &#123;</span><br><span class="line">                mint: ctx.accounts.etf_token_mint_account.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">                to: ctx.accounts.etf_token_ata.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">                authority: ctx.accounts.etf_token_info.<span class="title function_ invoke__">to_account_info</span>(), <span class="comment">// PDA mint authority, required as signer</span></span><br><span class="line">            &#125;,</span><br><span class="line">            signer_seeds,</span><br><span class="line">        ),</span><br><span class="line">        lamports,</span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    msg!(<span class="string">&quot;token minted successfully.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>前端部分</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#[program]</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">tokenMint</span>(<span class="params"><span class="attr">wallet</span>: anchor.<span class="title class_">Wallet</span>, <span class="attr">etfAddress</span>: <span class="title class_">PublicKey</span>, <span class="attr">lamports</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [etfCoreAddress] = <span class="title function_">deriveEtfokenInfoAccount</span>(etfAddress);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> etfInfo = <span class="keyword">await</span> program.<span class="property">account</span>.<span class="property">etfToken</span>.<span class="title function_">fetch</span>(etfCoreAddress);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> remainingAccounts = etfInfo.<span class="property">constitunent</span>.<span class="title function_">flatMap</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      <span class="title function_">getAssociatedTokenAddressSync</span>(item.<span class="property">token</span>, wallet.<span class="property">publicKey</span>),</span><br><span class="line">      <span class="title function_">getAssociatedTokenAddressSync</span>(item.<span class="property">token</span>, etfCoreAddress, <span class="literal">true</span>),</span><br><span class="line">    ];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// todo: 检查所有ata是否存在，并且用户余额充足</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(remainingAccounts);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ix = <span class="keyword">await</span> program.<span class="property">methods</span></span><br><span class="line">    .<span class="title function_">etfMint</span>(<span class="keyword">new</span> anchor.<span class="title function_">BN</span>(lamports))</span><br><span class="line">    .<span class="title function_">accounts</span>(&#123;</span><br><span class="line">      <span class="attr">etfTokenMintAccount</span>: etfAddress,</span><br><span class="line">      <span class="attr">authority</span>: wallet.<span class="property">publicKey</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">remainingAccounts</span>(</span><br><span class="line">      remainingAccounts.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> (&#123; <span class="attr">pubkey</span>: item, <span class="attr">isSigner</span>: <span class="literal">false</span>, <span class="attr">isWritable</span>: <span class="literal">true</span> &#125;)),</span><br><span class="line">    )</span><br><span class="line">    .<span class="title function_">transaction</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> modifyComputeUnits = anchor.<span class="property">web3</span>.<span class="property">ComputeBudgetProgram</span>.<span class="title function_">setComputeUnitLimit</span>(&#123;</span><br><span class="line">    <span class="attr">units</span>: <span class="number">400_000</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tx = <span class="keyword">new</span> anchor.<span class="property">web3</span>.<span class="title class_">Transaction</span>().<span class="title function_">add</span>(ix).<span class="title function_">add</span>(modifyComputeUnits);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> anchor.<span class="property">web3</span>.<span class="title function_">sendAndConfirmTransaction</span>(provider.<span class="property">connection</span>, tx, [wallet.<span class="property">payer</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们可以发现，在前端和合约中都执行了类似于getAssociatedTokenAddress的操作，在前端调用 getAssociatedTokenAddressSync 和在合约中调用 get_associated_token_address 的目的不同，但它们共同确保了代币转移的正确性和安全性。</p>
</li>
<li><p>在前端，使用 getAssociatedTokenAddressSync 可以快速生成这些账户的地址，而不需要与链上交互。在前端生成账户地址后，可以检查这些账户是否存在。如果不存在，可以提前创建（如使用 createAssociatedTokenAccount）。这样可以避免在合约中因为账户不存在而导致交易失败。</p>
</li>
<li><p>在合约中，我们需要确保传入的账户地址是正确的。使用 get_associated_token_address 重新计算账户地址，并与传入的地址进行比较，可以防止前端传入错误的账户。</p>
</li>
</ul>
<p>所以通过两次调用，可以确保前端和合约中的账户地址一致，避免因地址错误导致的交易失败。</p>
<ul>
<li>另外，由于购买该etf份额所需的所有token都在这次操作中完成了transfer,所以mint也可以在这个操作中一起完成</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul>
<li><strong>一次性完成所有代币转移</strong>：减少交易次数，降低 Gas 费用。</li>
<li><strong>代码简洁</strong>：逻辑集中在一个函数中，前端的代码更加简洁，易于维护。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul>
<li><strong>灵活性差</strong>：所有代币转移必须同时成功，否则整个交易失败。</li>
<li><strong>账户管理复杂</strong>：需要在前端准确构造 <code>remaining_accounts</code>，容易出错。</li>
</ul>
<hr>
<h3 id="3-方法二：每次只进行一种代币的转移"><a href="#3-方法二：每次只进行一种代币的转移" class="headerlink" title="3. 方法二：每次只进行一种代币的转移"></a><strong>3. 方法二：每次只进行一种代币的转移</strong></h3><h4 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a><strong>实现思路</strong></h4><ul>
<li>每次只转移一种代币，将交易原子化。</li>
<li>在前端分别调用这些交易，确保每次转移都经过 SPL Token 的校验。</li>
<li>在合约中根据代币的 Mint 地址生成关联账户（Associated Token Account）。</li>
</ul>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[program]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">buy_etf</span>(ctx: Context&lt;BuyEtf&gt;, amount: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">transfer</span>(</span><br><span class="line">        CpiContext::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            ctx.accounts.token_program.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">            Transfer &#123;</span><br><span class="line">                from: ctx.accounts.buyer_token_account.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">                to: ctx.accounts.etf_token_account.<span class="title function_ invoke__">to_account_info</span>(), </span><br><span class="line">                authority: ctx.accounts.buyer.<span class="title function_ invoke__">to_account_info</span>(),</span><br><span class="line">            &#125;,</span><br><span class="line">        ),</span><br><span class="line">        amount,</span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">order</span> = ctx.accounts.order.<span class="title function_ invoke__">clone</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index, token_transfer) <span class="keyword">in</span> order.tokens.<span class="title function_ invoke__">iter_mut</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> token_transfer.token_name == (ctx.accounts.token).<span class="title function_ invoke__">to_account_info</span>().<span class="title function_ invoke__">key</span>()</span><br><span class="line">            &amp;&amp; token_transfer.amount == amount</span><br><span class="line">        &#123;</span><br><span class="line">            token_transfer.transferred = <span class="literal">true</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.accounts.order.tokens = order.tokens.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Accounts)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">BuyEtf</span>&lt;<span class="symbol">&#x27;info</span>&gt; &#123;</span><br><span class="line">    <span class="meta">#[account(mut)]</span></span><br><span class="line">    <span class="keyword">pub</span> order: Account&lt;<span class="symbol">&#x27;info</span>, Order&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[account(mut)]</span></span><br><span class="line">    <span class="keyword">pub</span> author: Account&lt;<span class="symbol">&#x27;info</span>, User&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> token: <span class="type">Box</span>&lt;Account&lt;<span class="symbol">&#x27;info</span>, Mint&gt;&gt;,</span><br><span class="line">    <span class="meta">#[account(mut)]</span></span><br><span class="line">    <span class="keyword">pub</span> etf: Account&lt;<span class="symbol">&#x27;info</span>, Etf&gt;, </span><br><span class="line"></span><br><span class="line">    <span class="meta">#[account(mut)]</span></span><br><span class="line">    <span class="keyword">pub</span> buyer: Signer&lt;<span class="symbol">&#x27;info</span>&gt;, </span><br><span class="line"></span><br><span class="line">    <span class="meta">#[account(mut)]</span></span><br><span class="line">    <span class="keyword">pub</span> etf_creator: Signer&lt;<span class="symbol">&#x27;info</span>&gt;, </span><br><span class="line"></span><br><span class="line">    <span class="meta">#[account(</span></span><br><span class="line"><span class="meta">        init_if_needed,</span></span><br><span class="line"><span class="meta">        payer = buyer,</span></span><br><span class="line"><span class="meta">        associated_token::mint = token,</span></span><br><span class="line"><span class="meta">        associated_token::authority = buyer,</span></span><br><span class="line"><span class="meta">    )]</span></span><br><span class="line">    <span class="keyword">pub</span> buyer_token_account: Account&lt;<span class="symbol">&#x27;info</span>, TokenAccount&gt;, </span><br><span class="line"></span><br><span class="line">    <span class="comment">//associated</span></span><br><span class="line">    <span class="meta">#[account(</span></span><br><span class="line"><span class="meta">        init_if_needed,</span></span><br><span class="line"><span class="meta">        payer = etf_creator,</span></span><br><span class="line"><span class="meta">        associated_token::mint = token,</span></span><br><span class="line"><span class="meta">        associated_token::authority = etf_creator,</span></span><br><span class="line"><span class="meta">    )]</span></span><br><span class="line">    <span class="keyword">pub</span> etf_token_account: Account&lt;<span class="symbol">&#x27;info</span>, TokenAccount&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> system_program: Program&lt;<span class="symbol">&#x27;info</span>, System&gt;,</span><br><span class="line">    <span class="keyword">pub</span> token_program: Program&lt;<span class="symbol">&#x27;info</span>, Token&gt;,</span><br><span class="line">    <span class="keyword">pub</span> associated_token_program: Program&lt;<span class="symbol">&#x27;info</span>, AssociatedToken&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>将交易原子化后，单个方法的代码变得简洁，但是整个购买过程需要在前端多次调用该方法，最后单独调用mint方法。</p>
</li>
<li><p>在使用这种方法时需注意，由于 mint 方法被单独封装并在链上公开，存在被错误调用的风险。例如，恶意用户可能会直接调用 mint 方法，而无需完成所有代币的转移，从而导致系统状态不一致。</p>
</li>
</ul>
<p>为了解决这个问题，我们可以在创建购买申请时生成一个 order，用于记录每种资产的转移状态。具体步骤如下：</p>
<h4 id="创建-order："><a href="#创建-order：" class="headerlink" title="创建 order："></a>创建 order：</h4><p>在用户发起购买申请时，生成一个 order 账户，用于记录每种资产的转移状态（如 未转移 或 已转移）。</p>
<p>order 中存储每种资产的 Mint 地址、目标金额以及转移状态。</p>
<h4 id="更新转移状态："><a href="#更新转移状态：" class="headerlink" title="更新转移状态："></a>更新转移状态：</h4><p>每次完成一种资产的转移后，更新 order 中对应资产的转移状态。</p>
<p>确保每次转移都是原子操作，避免部分转移导致的状态不一致。</p>
<h4 id="检查-order："><a href="#检查-order：" class="headerlink" title="检查 order："></a>检查 order：</h4><p>在调用 mint 方法之前，检查 order 中所有资产的转移状态。</p>
<p>只有当所有资产都已成功转移时，才允许执行 mint 操作。</p>
<h4 id="通过这种方式，我们可以确保："><a href="#通过这种方式，我们可以确保：" class="headerlink" title="通过这种方式，我们可以确保："></a>通过这种方式，我们可以确保：</h4><p>交易的完整性：所有资产必须完成转移后才能进行 mint。</p>
<p>防止错误调用：恶意用户无法直接调用 mint，必须按照正确的流程完成所有步骤。</p>
<p>状态一致性：通过 order 记录转移状态，避免因部分转移导致的状态不一致。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul>
<li><strong>灵活性高</strong>：每次只转移一种代币，失败不会影响其他代币。</li>
<li><strong>安全性高</strong>：每次转移都经过 SPL Token 的校验，确保账户和金额的正确性。</li>
<li><strong>易于扩展</strong>：可以轻松支持新的代币类型。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul>
<li><strong>交易次数多</strong>：每种代币都需要单独调用一次交易，可能增加 Gas 费用。</li>
<li><strong>前端逻辑复杂</strong>：需要在前端管理多次交易的调用顺序和状态。</li>
</ul>
<hr>
<h3 id="4-两种方法的对比"><a href="#4-两种方法的对比" class="headerlink" title="4. 两种方法的对比"></a><strong>4. 两种方法的对比</strong></h3><table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>方法一：<code>remaining_accounts</code></strong></th>
<th><strong>方法二：原子化交易</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>交易次数</strong></td>
<td>一次交易完成所有代币转移</td>
<td>每种代币需要一次交易</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>低（所有代币转移必须同时成功）</td>
<td>高（每种代币转移独立）</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>依赖前端正确构造 <code>remaining_accounts</code></td>
<td>每次转移都经过 SPL Token 校验</td>
</tr>
<tr>
<td><strong>代码复杂度</strong></td>
<td>合约逻辑集中，前端逻辑简单</td>
<td>合约逻辑分散，前端逻辑复杂</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>代币种类固定且数量较少</td>
<td>代币种类动态或数量较多</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h3><p>在 Solana 上实现 ETF 购买功能时，向合约账户存入指定种类的 Token 是一个关键步骤。本文介绍了两种实现方法：</p>
<ol>
<li><strong>使用 <code>remaining_accounts</code> 将所有账户一起传入</strong>：适合代币种类固定且数量较少的场景。</li>
<li><strong>每次只进行一种代币的转移</strong>：适合代币种类动态或数量较多的场景，具有更高的灵活性和安全性。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2025/02/15/dex/" data-id="cm76gthk600006ouy12q0dvf6" data-title="本地开发DEX：购买ETF的两种策略" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-solana4" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/26/solana4/" class="article-date">
  <time class="dt-published" datetime="2024-11-25T17:04:27.157Z" itemprop="datePublished">2024-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/26/solana4/">solana 学习笔记四 Solana基础 - Token解析&amp;创建</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一-token解释"><a href="#一-token解释" class="headerlink" title="一. token解释"></a>一. token解释</h3><p>代币是代表对各种资产所有权的数字资产。代币化使得财产权的数字化成为可能,是管理可替代和不可替代资产的基本组成部分。</p>
<p>可替代代币代表同类型和同价值的可互换和可分割资产 (例如USDC)。</p>
<p>不可替代代币(NFT)代表不可分割资产的所有权(例如艺术品)。</p>
<h3 id="二-Solana的代币体系主要有以下部分组成："><a href="#二-Solana的代币体系主要有以下部分组成：" class="headerlink" title="二. Solana的代币体系主要有以下部分组成："></a>二. Solana的代币体系主要有以下部分组成：</h3><p>SPL (Solana Program Library)</p>
<p>Token Program(代币程序)</p>
<p>Mint Account(铸币账户) Mint Account是每个SPLToken的核心账户,负责代币的定义和管理。它包含了代币的全局属性,比如总供应量和小数位数。每个代币都由一个独立的Mint Account来表示。</p>
<p>Decimals(小数位数):定义代币的最小单位,通常是0到9。</p>
<p>Supply(供应量):代币的当前总供应量。</p>
<p>Mint Authority(铸币权限):可以铸造新的代币的账户。</p>
<p>Freeze Authority(冻结权限):可以冻结或解冻代币账)户的权限</p>
<h3 id="三-功能"><a href="#三-功能" class="headerlink" title="三. 功能:"></a>三. 功能:</h3><p>铸造代币:当Mint Authority执行铸币操作时,新的代币会增加到总供应量中,并分配给指定的Token Account。</p>
<p>销毁代币:减少总供应量。</p>
<h3 id="四-账户分类"><a href="#四-账户分类" class="headerlink" title="四. 账户分类"></a>四. 账户分类</h3><h4 id="1-Token-Account-代币账户"><a href="#1-Token-Account-代币账户" class="headerlink" title="1. Token Account(代币账户)"></a>1. Token Account(代币账户)</h4><p>Token Account是用于持有特定SPLToken的账户。每个用户或者合约如果想要持有某种SPL Token,必须有一个与该Token对应的Token Account。不同的代币有不同的Token Account,账户之间无法混用月。</p>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性:"></a>属性:</h5><p>Amount(余额):账户中持有的代币数量。<br>Owner(账户拥有者):控制该账户的用户或合约地址。<br>Mint(铸币账户关联):该账户与哪个Mint Account相关联。<br>Delegate(代理账户):可以被授权管理该账户的其他账)户(可选)。<br>State(状态):账户是否处于冻结状态。</p>
<h5 id="功能"><a href="#功能" class="headerlink" title="功能:"></a>功能:</h5><p>接收和发送代币:TokenAccount可以接受其他账户的代币,并通过转账指令将其发送给其他账户。</p>
<p>代理权限管理:可以设置Delegate来授权第三方管理该账户的币。</p>
<h4 id="2-Associated-Token-Account-关联代币账户"><a href="#2-Associated-Token-Account-关联代币账户" class="headerlink" title="2. Associated Token Account(关联代币账户)"></a>2. Associated Token Account(关联代币账户)</h4><p>Associated Token Account (ATA) 是 Token Account的一种特殊类型,简化了SPLToken的账户管理。ATA是自动与一个钱包地址绑定的账户,每个钱包地址和每个代币的Mint对应一个唯一的Token Account,因此该账户类型极大简化了代币管理。</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h5><p>唯一性:每个钱包地址只能有一个和某个Mint关联的ATA。</p>
<p>自动生成:Solana提供了工具来自动生成ATA,开发者不需要手动管理账户。</p>
<h5 id="功能-1"><a href="#功能-1" class="headerlink" title="功能:"></a>功能:</h5><p>自动处理钱包地址与代币账户之间的关联,方便用户管理不同的SPL Token。</p>
<h3 id="五-Token演示："><a href="#五-Token演示：" class="headerlink" title="五. Token演示："></a>五. Token演示：</h3><p>在本地创建一个新的公私钥对，然后在本地创建新的代币，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spl-token create-token</span><br></pre></td></tr></table></figure>

<p><img src="/../assets/img/29-1.jpg" alt="图29-1" title="29-1"></p>
<p>此时会得到mint account（程序地址），以及签名 和 铸币程序的id, 然后通过spl-token account-info –address <mint account> 可以得到程序更详细的信息（包含作者）</p>
<p><img src="/../assets/img/29-2.jpg" alt="图29-2" title="29-2"></p>
<p>接下来是创建账户，直接通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spl-token create-account &lt;mint account&gt;的方式可以创建与铸造账户相关联的ata账户</span><br></pre></td></tr></table></figure>

<p><img src="/../assets/img/29-3.jpg" alt="图29-3" title="29-3"></p>
<p>将创建出来的ata账户在solana explore上搜索，发现有一个owner属性指向mint authority</p>
<p>如果需要创建一个非ata账户，则需要新创建一个keypair对，将指令改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spl-token create-account &lt;mint account&gt; &lt;keypair_path&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/../assets/img/29-4.jpg" alt="图29-4" title="29-4"></p>
<p>这样就创建了一个非ata账户，在solana explore上搜索，发现owner也是指向mint authority, 此时也可以发现刚才创建的这两个账户余额都是0, 接下来为这两个账户铸造代币</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spl-token mint &lt;mint_account&gt; &lt;amount&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/../assets/img/29-5.jpg" alt="图29-5" title="29-5"></p>
<p>此时会默认为ata账户铸币，explore上查看发现余额已经为100, 如果需要为非ata账户铸币，需要指定receive account:</p>
<p><img src="/../assets/img/29-6.jpg" alt="图29-6" title="29-6"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/11/26/solana4/" data-id="cm3xa5z1h0000j4uyao7lgsp5" data-title="solana 学习笔记四 Solana基础 - Token解析&amp;创建" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-solana3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/21/solana3/" class="article-date">
  <time class="dt-published" datetime="2024-11-21T15:07:48.483Z" itemprop="datePublished">2024-11-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/21/solana3/">solana 学习笔记三 Solana基础，账户与简单交互</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一-solana中的账户主要分为以下几种："><a href="#一-solana中的账户主要分为以下几种：" class="headerlink" title="一. solana中的账户主要分为以下几种："></a>一. solana中的账户主要分为以下几种：</h3><ol>
<li><p>数据账户,用来存储数据</p>
</li>
<li><p>系统所有账户</p>
</li>
<li><p>程序派生账户(PDA)</p>
</li>
<li><p>程序账户,用来存储可执行程序</p>
</li>
<li><p>原生账户,指Solana上的原生程序,例如”System”,”Stake”,以及”Vote”</p>
</li>
</ol>
<h3 id="二-账户结构如下："><a href="#二-账户结构如下：" class="headerlink" title="二. 账户结构如下："></a>二. 账户结构如下：</h3><h4 id="1-Account"><a href="#1-Account" class="headerlink" title="1. Account"></a>1. Account</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Deserialize, PartialEq, Eq, Eq, Clone, Default)]</span><br><span class="line">#[serde(rename_all = &quot;camelCase&quot;)]</span><br><span class="line">pub struct Account &#123;</span><br><span class="line">/// lamports in the account</span><br><span class="line">pub lamports: u64,</span><br><span class="line">/// data held in this account</span><br><span class="line">#[serde(with = &quot;serde_bytes&quot;)]</span><br><span class="line">pub data: Vec&lt;u8&gt;,</span><br><span class="line">/// the program that owns this account. If executable, the program that loads this account.</span><br><span class="line">pub owner:Pubkey,</span><br><span class="line">/// this account&#x27;s data contains a loaded program (and is now read-only)</span><br><span class="line">executable: bool,</span><br><span class="line">///the epoch at which this account will next owe rent</span><br><span class="line">pub rent_epoch:Epoch,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Accountlnfo"><a href="#2-Accountlnfo" class="headerlink" title="2. Accountlnfo"></a>2. Accountlnfo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/// Account information</span><br><span class="line">#[derive(Clone)]</span><br><span class="line">#[repr(C)]</span><br><span class="line">pub struct AccountInfo&lt;&#x27;a&gt; &#123;</span><br><span class="line">/// Public key of the account</span><br><span class="line">pub key: &amp;&#x27;a Pubkey,</span><br><span class="line">/// The lamports in the account. Modifiable by programs.</span><br><span class="line">pub lamports:Rc&lt;RefCell&lt;&amp;&#x27;a mut u64&gt;&gt;,</span><br><span class="line">/// The data held in this account. Modifiable by programs.</span><br><span class="line">pub data: Rc&lt;RefCell&lt;&amp;&#x27;a mut [u8]&gt;&gt;,</span><br><span class="line">/// Program that owns this account</span><br><span class="line">pub owner: &amp; a Pubkey,</span><br><span class="line">/// The epoch at which this account will next owe rent</span><br><span class="line">pub rent_epoch:Epoch,</span><br><span class="line">/// Was the transaction signed by this account&#x27;s publikey?</span><br><span class="line">pub is_signer:bool,</span><br><span class="line">/// Is the account writable?</span><br><span class="line">pub is_writable: bool,</span><br><span class="line">/// This account&#x27;s data contains a loaded program (and is now read-only)</span><br><span class="line">pub executable: bool,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Account-AccountInfo对比"><a href="#3-Account-AccountInfo对比" class="headerlink" title="3. Account&amp;AccountInfo对比"></a>3. Account&amp;AccountInfo对比</h4><h5 id="Accountlnfo"><a href="#Accountlnfo" class="headerlink" title="Accountlnfo:"></a>Accountlnfo:</h5><p>更轻量级,包含对区块链上现有账户数据的引用。<br>用于在Solana程序(智能合约)内部处理账户。<br>适合在链上处理和操作账户数据。</p>
<h5 id="Account"><a href="#Account" class="headerlink" title="Account:"></a>Account:</h5><p>更完整的账户表示,包含账户的所有数据副本。<br>常用于客户端或测试环境中,用于模拟或获取完整的账户状态。<br>适合离线处理或全局管理账户数据。</p>
<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><p>账户是用来存放数据的<br>每个账户都有一个独一无二的地址<br>每个账户大小不能超过10MB<br>账户大小是静态的<br>账户数据存储需要付租金<br>默认的账户所有者是”系统程序</p>
<h3 id="三-程序派生账户"><a href="#三-程序派生账户" class="headerlink" title="三. 程序派生账户"></a>三. 程序派生账户</h3><h4 id="1-PDA特性"><a href="#1-PDA特性" class="headerlink" title="1. PDA特性"></a>1. PDA特性</h4><h5 id="a-不能直接签名交易"><a href="#a-不能直接签名交易" class="headerlink" title="a.不能直接签名交易"></a>a.不能直接签名交易</h5><p>限制:PDA账户<strong>没有私钥,因此无法像普通账户那样签名交易。</strong><br>影响:这意味着PDA无法自主发起交易,它<strong>只能被相关的智能合约程序用作数据存储或执行操作</strong>。这确保了PDA只能在程序的控制下使用。</p>
<h5 id="b-地址碰撞的可能性"><a href="#b-地址碰撞的可能性" class="headerlink" title="b.地址碰撞的可能性"></a>b.地址碰撞的可能性</h5><p>限制:在理论上,虽然非常罕见,使用相同的程序ID和相同的种子值可以生成相同的PDA地址。<br>影响:这意味着在设计智能合约时,开发者必须谨慎选择种子值,以确保不会产生地址碰撞。一般来说,通过使用唯一的种子(比如用户的公钥和其他独特的数据),可以避免这种问题。</p>
<h5 id="c-PDA地址的最大长度"><a href="#c-PDA地址的最大长度" class="headerlink" title="c.PDA地址的最大长度"></a>c.PDA地址的最大长度</h5><p>限制:PDA的种子值组合在一起不能超过32字节(bytes)。<br>影响:如果你的数据太大,可能无法直接作为种子使用。你可能需要对数据进行哈希处理或其他方式来适应这个限制。</p>
<h5 id="d-生成PDA的计算成本"><a href="#d-生成PDA的计算成本" class="headerlink" title="d.生成PDA的计算成本"></a>d.生成PDA的计算成本</h5><p>限制:PDA是通过哈希函数计算生成的,这个过程消耗计算资源源。<br>影响:在性能敏感的应用中,频繁生成PDA可能增加链上计算的成本,影响程序的执行效率。因此,在设计程序时需要平衡性能和安全性。</p>
<h5 id="e-单一程序的访问"><a href="#e-单一程序的访问" class="headerlink" title="e.单一程序的访问"></a>e.单一程序的访问</h5><p>限制:PDA账户是<strong>由一个特定的程序生成和控制的,只有这个程序可以操作该PDA账户。</strong><br>影响:虽然这提供了很强的安全性,但也意味着你不能轻易地跨移序共享PDA账户。如果多个程序需要访问相同的数据,可能需要复杂的设计或数据复制。</p>
<h5 id="f-内存账户的使用"><a href="#f-内存账户的使用" class="headerlink" title="f.内存账户的使用"></a>f.内存账户的使用</h5><p>限制:如果PDA被用作Solana上的内存账户(即需要存储较多的数据),这些账户的大小是有限制的,<strong>超过一定大小需要支付更高的费用来增加内存租金。</strong><br>影响:你需要考虑PDA账户的数据量,避免不必要的存储开销,或者拆分数据存储到多个PDA账户中。</p>
<h4 id="2-PDA应用场景"><a href="#2-PDA应用场景" class="headerlink" title="2. PDA应用场景"></a>2. PDA应用场景</h4><p>1.用户状态管理<br>2.去中心化金融(DeFi)协议<br>3.NFT元数据存储<br>4.DAO(去中心化自治组织)投票系统<br>5.时间锁合约<br>6.多签(Multisig)钱包<br>7.去中心化身份验证</p>
<h3 id="四-Rust开发solana"><a href="#四-Rust开发solana" class="headerlink" title="四. Rust开发solana:"></a>四. Rust开发solana:</h3><h4 id="1-以下三个库在开发中经常使用"><a href="#1-以下三个库在开发中经常使用" class="headerlink" title="1.以下三个库在开发中经常使用"></a>1.以下三个库在开发中经常使用</h4><p>Solana_client</p>
<p>Solana_sdk</p>
<p>Solane_program</p>
<h4 id="2-实战"><a href="#2-实战" class="headerlink" title="2.实战"></a>2.实战</h4><p>启动本地环境</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana-test-validator --reset</span><br></pre></td></tr></table></figure>

<p>更改solana配置,链接到本地开发环境</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana config set --url http://127.0.0.1:8899</span><br></pre></td></tr></table></figure>

<p>创建本地账户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana-keygen new -o ~/.config/solana/ad1.json</span><br></pre></td></tr></table></figure>

<p>此时公钥在：</p>
<p><img src="/../assets/img/28-1.jpg" alt="图28-1" title="28-1"></p>
<p>其中的pubkey</p>
<p>私钥：</p>
<p><img src="/../assets/img/28-4.jpg" alt="图28-4" title="28-4"></p>
<p>将本地账户切换到刚才创建的公钥：</p>
<p><img src="/../assets/img/28-2.jpg" alt="图28-2" title="28-2"></p>
<p>给新建账户空投sol</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Solana airdrop 10</span><br></pre></td></tr></table></figure>

<p>使用SDK</p>
<h5 id="a-空投sol"><a href="#a-空投sol" class="headerlink" title="a.空投sol"></a>a.空投sol</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let amount = 2_000_000_000;</span><br><span class="line">match client.request_airdrop(&amp;account_pubkey, amount) &#123;</span><br><span class="line">    Ok(signature)=&gt;println!(&quot;获取空投成功，交易签名：&#123;:?&#125;&quot;,signature),</span><br><span class="line">    Err(err) =&gt; println!(&quot;空投失败&#123;:?&#125;&quot;,err),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="b-获取账号信息"><a href="#b-获取账号信息" class="headerlink" title="b.获取账号信息"></a>b.获取账号信息</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let rpc_url = &quot;http://127.0.0.1:8899&quot;;</span><br><span class="line"></span><br><span class="line">let client = RpcClient::new(rpc_url);</span><br><span class="line"></span><br><span class="line">//指定要查询的账户公钥,from_str返回值是result</span><br><span class="line">let account_pubkey = Pubkey::from_str(&quot;AEjMNU9eDwEsDh35JWjXtyFdSRGCN4utDaMMQSbwz4v3&quot;).unwrap();</span><br><span class="line"></span><br><span class="line">match client.get_balance(&amp;account_pubkey) &#123;</span><br><span class="line">    Ok(balance) =&gt; println!(&quot;账户余额&#123;:?&#125;&quot;,balance),</span><br><span class="line">    Err(_) =&gt; todo!(), </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="c-转移sol"><a href="#c-转移sol" class="headerlink" title="c.转移sol"></a>c.转移sol</h5><p>用之前的指令创建一个新的账号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana-keygen new -o ~/.config/solana/ad1.json</span><br></pre></td></tr></table></figure>

<p>得到新的pubkey，作为转账操作的接收地址，先通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana config set –pubkey ./.config/solana/ad2.json</span><br></pre></td></tr></table></figure>

<p>查看余额发现当前余额为0,然后切回之前的账户，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let rpc_url = &quot;http://127.0.0.1:8899&quot;;</span><br><span class="line"></span><br><span class="line">    let client = RpcClient::new(rpc_url);</span><br><span class="line"></span><br><span class="line">    //指定要查询的账户公钥,from_str返回值是result</span><br><span class="line">    let sender = read_keypair_file(&quot;/home/lcz/.config/solana/ad2.json&quot;).expect(&quot;failed&quot;);</span><br><span class="line"></span><br><span class="line">    let receiver_pubkey =  Pubkey::from_str(&quot;AEjMNU9eDwEsDh35JWjXtyFdSRGCN4utDaMMQSbwz4v3&quot;).unwrap();</span><br><span class="line">    </span><br><span class="line">    //创建转账指令</span><br><span class="line">    let transaction_order = transfer(&amp;sender.pubkey(), &amp;receiver_pubkey, 1000000000);</span><br><span class="line">    </span><br><span class="line">    //创建交易</span><br><span class="line">    let recent_blockhash = client.get_latest_blockhash().unwrap();</span><br><span class="line"></span><br><span class="line">    let transaction = Transaction::new_signed_with_payer(&amp;[transaction_order],Some( &amp;sender.pubkey()), &amp;[&amp;sender], recent_blockhash);</span><br><span class="line">    </span><br><span class="line">    let result = client.send_and_confirm_transaction(&amp;transaction);</span><br><span class="line">    </span><br><span class="line">    match result&#123;</span><br><span class="line">        Ok(signature)=&gt;println!(&quot;转账成功，交易签名：&#123;:?&#125;&quot;,signature),</span><br><span class="line">        Err(err) =&gt; println!(&quot;转账失败&#123;:?&#125;&quot;,err),</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>执行显示转账成功，此时查看新账号的余额，发现为1sol</p>
<h4 id="e-通过JsonRpc获取账户信息"><a href="#e-通过JsonRpc获取账户信息" class="headerlink" title="e.通过JsonRpc获取账户信息"></a>e.通过JsonRpc获取账户信息</h4><p>可以直接在终端向指定的网络rpc发起请求, 在请求中说明你需要调用的方法和参数：</p>
<p><img src="/../assets/img/28-3.jpg" alt="图28-3" title="28-3"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/11/21/solana3/" data-id="cm3rgcatc0000lguyc2v6hptf" data-title="solana 学习笔记三 Solana基础，账户与简单交互" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-solana2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/17/solana2/" class="article-date">
  <time class="dt-published" datetime="2024-11-17T07:47:28.848Z" itemprop="datePublished">2024-11-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/17/solana2/">solana 学习笔记二 Solana开发入门</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>solana 的项目搭建可以使用以下三种方式：</p>
<ol>
<li><p>Native rust</p>
</li>
<li><p>Playground </p>
</li>
<li><p>Anchor</p>
</li>
</ol>
<p>下面分别对三种搭建方式进行阐述</p>
<h3 id="一-Native-rust"><a href="#一-Native-rust" class="headerlink" title="一. Native rust"></a>一. Native rust</h3><h4 id="1-首先通过以下指令初始化项目："><a href="#1-首先通过以下指令初始化项目：" class="headerlink" title="1. 首先通过以下指令初始化项目："></a>1. 首先通过以下指令初始化项目：</h4><p><code>cargo new --lib &lt;project_name&gt; # new project</code></p>
<p>进入项目目录执行:</p>
<p><code>cargo add solana-program # deps</code></p>
<p>此时wsl用户可能会发现toml文件依赖处有报错：Errors solana-program: Error: Failed to establish a socket connection to proxies: [“PROXY 127.0.0.1:xxxxx”],</p>
<p>这是因为由于我开启了系统代理，但是wsl并不能直接连接到我的系统代理IP地址，所以需要禁用。参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_63211230/article/details/140205627">https://blog.csdn.net/weixin_63211230/article/details/140205627</a></p>
<p>修改编译配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[lib]</span><br><span class="line"></span><br><span class="line">crate-type = [&quot;cdylib&quot;, &quot;lib&quot;]</span><br></pre></td></tr></table></figure>

<p>接下来对lib文件进行修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">use solana_program ::&#123;</span><br><span class="line">    account_info::AccountInfo, entrypoint, entrypoint::ProgramResult, msg, pubkey::Pubkey</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//声明程序入口</span><br><span class="line">entrypoint!(process_instruction);</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">fn process_instruction(</span><br><span class="line">    program_id: &amp;Pubkey,</span><br><span class="line">    _accounts: &amp;[AccountInfo],</span><br><span class="line">    _instruction_data: &amp;[u8],</span><br><span class="line">) -&gt; ProgramResult&#123;</span><br><span class="line">    msg!(&quot;Hello, Solana!&quot;);</span><br><span class="line">    msg!(&quot;Our program&#x27;s Program ID:&#123;&#125;&quot;, &amp;program_id);</span><br><span class="line">    msg!(&quot;program_id:&#123;:?&#125;&quot;,program_id);</span><br><span class="line">    msg!(&quot;accounts:&#123;:?&#125;&quot;,_accounts);</span><br><span class="line">    msg!(&quot;instruction_data: &#123;:?&#125;&quot;, _instruction_data);</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>process_instruction</code>函数被声明为程序入口，部署后所有对链上发起的交易信息都可以被这个函数读取</p>
<p>通过观察entrypoint!宏的源码可以得出：<br>入口函数的参数必须是：<code>program_id: &amp;Pubkey, _accounts: &amp;[AccountInfo], _instruction_data: &amp;[u8],</code>, 这三个参数，参数中_instruction_data参数包含了执行特定操作所需的所有信息，比如转账的代币数量、转账地址等。这些数据会作为字节码的形式，被包含在交易的指令中，当交易被提交到Solana网络时，相应的程序会解析这些数据，并根据这些指令在指定的账户上进行操作。 而函数返回值必须是<strong>Result</strong>类型的</p>
<p>在solana开发中，之前在rust中写的println!宏打印已经不再支持，最后将代码封装成一个在链上执行的动态链接库，只能通过msg!()的格式代替println!()进行输出</p>
<p>现在我们尝试将代码进行打包与部署：</p>
<h4 id="2-Build-Deploy"><a href="#2-Build-Deploy" class="headerlink" title="2.Build &amp; Deploy"></a>2.Build &amp; Deploy</h4><p>先查看当前网络</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana config get</span><br></pre></td></tr></table></figure>

<p>之后build</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build-sbf</span><br></pre></td></tr></table></figure>

<p>我是按照官方的教程操作的，但是在执行这一步时仍然报错：</p>
<p>error: package <code>solana-program v2.1.0</code> cannot be built because it requires rustc 1.79.0 or newer, while the currently active rustc version is 1.75.0-dev</p>
<p>看起来是外面安装的rust版本和程序中solana-program自带的rust版本不一样，且程序中使用的版本与当前的solana版本不兼容，将错误复制到官网上，发现有类似的问题，<a target="_blank" rel="noopener" href="https://solana.com/zh/developers/courses/onchain-development/local-setup#object-object-solana-program">https://solana.com/zh/developers/courses/onchain-development/local-setup#object-object-solana-program</a> v1.8.12</p>
<p>根据官网操作在程序中重新安装更新版本的solana-program得到解决</p>
<p>第一次执行可能需要较长时间，在这一步后，可以在target目录下发现多了sbf-solana-solana文件夹，其中有个release文件夹，其中so文件，这就是待我们部署的文件、</p>
<p>之后我们执行solana program deploy .&#x2F;target&#x2F;deploy&#x2F;your_program.so, 就可以将其部署到测试网上，执行后可以在终端看到输出的program id 和 signature</p>
<p><img src="/../assets/img/27-1.jpg" alt="图27-1" title="27-1"></p>
<p>在solana浏览器的对应网络中搜索这个id可以看到部署细节以及msg输出, 在这之后，如果想取消部署，收回已经分发的代币，可执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solana program close &lt;program_id&gt;#（此操作不可逆，需三思）</span><br></pre></td></tr></table></figure>

<h3 id="二-playground"><a href="#二-playground" class="headerlink" title="二. playground"></a>二. playground</h3><p>同样，以上操作可以放在<a target="_blank" rel="noopener" href="https://beta.solpg.io/">https://beta.solpg.io/</a> 执行，这是一个线上开发环境，也支持连接到测试网测试，直接点击左上角的+号，创建一个新项目，然后在下方终端输入connect,会自动帮你创建一个测试钱包，且里面带有5sol测试代币<br>之后界面大概如下所示：</p>
<p><img src="/../assets/img/27-2.jpg" alt="图27-2" title="27-2"></p>
<p>分为左边的菜单界面，中间的代码，下方的终端和右上角的钱包信息, 在修改完lib.rs中的内容后，可以点击左边菜单栏中的build.和 deploy,将其部署到测试网后，可以点击左下角在浏览器中查看，此时可以发现instruction中第一项为：</p>
<p>#1 BPF Upgradeable Loader: Upgrade</p>
<p><img src="/../assets/img/27-3.jpg" alt="图27-3" title="27-3"></p>
<p>这表示当前合约已经经过了第一次部署，现在是待升级状态，<code>BPF Upgradeable Loader</code>，这指的是一种机制，允许在不改变合约地址的情况下升级智能合约。这是通过使用一个代理合约（loader）来实现的，它指向实际的合约代码。当需要升级时，只需更新loader指向的新合约代码，而不需要替换整个合约。</p>
<p>而最后的Program Instruction Logs界面也显示了return success </p>
<p><img src="/../assets/img/27-4.jpg" alt="图27-4" title="27-4"></p>
<p>因为我们的代码中规定了最后返回时Result类型</p>
<p>在菜单中的client文件中，有一个client.ts文件，用于模拟前端与链上的合约进行交互，可以点击run运行，打印的交易细节或区块信息等可以在控制台看到</p>
<p><img src="/../assets/img/27-5.jpg" alt="图27-5" title="27-5"></p>
<h3 id="三-Anchor"><a href="#三-Anchor" class="headerlink" title="三. Anchor"></a>三. Anchor</h3><h4 id="1-首先通过-以下指令初始化Anchor项目"><a href="#1-首先通过-以下指令初始化Anchor项目" class="headerlink" title="1. 首先通过 以下指令初始化Anchor项目"></a>1. 首先通过 以下指令初始化Anchor项目</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anchor init &lt;project_name&gt;</span><br></pre></td></tr></table></figure>

<p>在执行这个之前，需要根据上面的环境配置教程，安装好node 和 yarn ,项目创建完后打开，观察目录发现这是一个前端与合约都有的项目：</p>
<p><img src="/../assets/img/27-6.jpg" alt="图27-6" title="27-6"></p>
<p>其中关于前端的部分，一目了然，不做过多赘述，合约的部分在programs文件夹中，在外层还有一个叫Anchor.tmol的文件，在里面可以修改Anchor的配置，也可以在其中指定部署的网络，在外层的tests文件夹中，是项目的测试文件，是用ts写的，在里面可以调取programs中写的智能合约中的方法，与链上进行交互测试</p>
<h4 id="2-此时先执行anchor-build"><a href="#2-此时先执行anchor-build" class="headerlink" title="2. 此时先执行anchor build"></a>2. 此时先执行anchor build</h4><p>这是anchor框架打包的方式，此时会将合约中写的方法集成输出到target文件夹中的types文件夹，供上面的测试文件调用</p>
<h4 id="3-anchor-test"><a href="#3-anchor-test" class="headerlink" title="3. anchor test"></a>3. anchor test</h4><p>可以发现终端已经输出了测试文件的执行结果</p>
<h4 id="4-anchor-deploy"><a href="#4-anchor-deploy" class="headerlink" title="4. anchor deploy"></a>4. anchor deploy</h4><p>最后调用deploy命令将其部署到Anchor.toml中指定的网络中，终端输出合约地址</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/11/17/solana2/" data-id="cm3laycby00001ouydzk97ihx" data-title="solana 学习笔记二 Solana开发入门" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-solana1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/13/solana1/" class="article-date">
  <time class="dt-published" datetime="2024-11-13T15:14:02.254Z" itemprop="datePublished">2024-11-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/13/solana1/">solana 学习笔记一 Solana基础与环境搭建</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一-区块链知识基础"><a href="#一-区块链知识基础" class="headerlink" title="一.区块链知识基础"></a>一.区块链知识基础</h3><h4 id="1-先看看区块链的定义"><a href="#1-先看看区块链的定义" class="headerlink" title="1.先看看区块链的定义"></a>1.先看看区块链的定义</h4><p>区块链是由一系列按时间顺序链接的”区块”组成的。每个区块包含三部分:</p>
<h5 id="a-区块头-Block-Header"><a href="#a-区块头-Block-Header" class="headerlink" title="a.区块头(Block Header)"></a>a.区块头(Block Header)</h5><p>前一个区块的哈希(Previous Block Hash):链接到链上前一个区区块的加密哈希值,确保数据不可篡改。</p>
<p>时间戳(Timestamp)记录创建区块的时间。</p>
<p>默克尔根(MerkleRoot):所有交易数据的哈希值,确保数据完整性。</p>
<h5 id="b-区块体-Block-Body"><a href="#b-区块体-Block-Body" class="headerlink" title="b.区块体(Block Body)"></a>b.区块体(Block Body)</h5><p>交易列表(Transactions):包含区块中所有的交易记录。</p>
<p>区块哈希(Block Hash):</p>
<p>当前区块的哈希值:通过对区块头数据进行哈希计算生成,作为下一个区块的”前一个区块哈希”。通过这些信息可以将多个区块连接成一条链表</p>
<p>结构如下所示：</p>
<p><img src="/../assets/img/26-1.jpg" alt="图26-1" title="26-1"></p>
<p>众所周知区块链的特性就是去中心化，那么是如何去中心化的存储数据的呢：</p>
<h4 id="2-去中心化网络-P2P"><a href="#2-去中心化网络-P2P" class="headerlink" title="2.去中心化网络(P2P)"></a>2.去中心化网络(P2P)</h4><p>区块链是由分布在全球的节点组成的去中心化网络,这些节点共同维护和更新区块链状态。每个节点都有一份完整的区块链副本。</p>
<p>区块链上的交易包含以下基础步骤：</p>
<p>a.交易创建:用户A创建一笔交易,将资金或数据发送给用户B。</p>
<p>b.交易广播:该交易被广播到区块链网络中,所有节点接收到交易信息。</p>
<p>c.交易验证:网络中的矿工或验证节点对交易进行验证,确保交易的合法性</p>
<p>d.交易打包:验证通过的交易被打包进区块中,并由矿工竞争挖矿（在Pow的情况下）</p>
<p>e.交易确认:新创建的区块被添加到区块链上,交易得到确认···</p>
<p>如下所示：</p>
<p><img src="/../assets/img/26-2.jpg" alt="图26-2" title="26-2"></p>
<p>在上面的流程中，最重要的一步就是交易验证，在去中心化的交易中，没有一个存储数据的中心数据库，所以不同的节点达成共识非常重要</p>
<h4 id="3-共识机制"><a href="#3-共识机制" class="headerlink" title="3.共识机制"></a>3.共识机制</h4><p>共识机制是区块链网络中所有节点就数据达成一致的方式。以常见的工作量证明(Proof of Work,PoW)为例:</p>
<p>工作量证明(PoW):矿工通过计算工作量来解决一个复杂的数学问题（寻找符合条件的hash）,第一个解出问题的矿工可以将其区块添加到区块链中。</p>
<p>这些交易的逻辑来源于部署在区块链上的智能合约：</p>
<h4 id="4-智能合约"><a href="#4-智能合约" class="headerlink" title="4.智能合约"></a>4.智能合约</h4><p>智能合约是部署在区块链上的自执行代码,能根据预定条件自动执行交易</p>
<p>如下所示：</p>
<p><img src="/../assets/img/26-3.jpg" alt="图26-3" title="26-3"></p>
<p>那么和其他的链相比，Solana有什么优势呢</p>
<h4 id="5-Solana八大特性："><a href="#5-Solana八大特性：" class="headerlink" title="5.Solana八大特性："></a>5.Solana八大特性：</h4><p>高性能solana</p>
<ol>
<li><p>Proof of History(POH)-a clock before consensus;</p>
</li>
<li><p>Tower BFT-a PoH-optimized version of PBFT;</p>
</li>
<li><p>Turbine-a block propagation protocol;</p>
</li>
<li><p>Gulf Stream-Mempool-less transaction forwarding protocol:</p>
</li>
<li><p>Sealevel–Parallel smart contracts run-time;</p>
</li>
<li><p>Pipelining-a Transaction Processing Unit for validation optimization</p>
</li>
<li><p>Cloudbreak-Horizontally-Scaled Accounts Database; and</p>
</li>
<li><p>Archivers-Distributed ledger store</p>
</li>
</ol>
<h4 id="二-开发环境搭建"><a href="#二-开发环境搭建" class="headerlink" title="二.开发环境搭建"></a>二.开发环境搭建</h4><p>关于solana本地开发环境的一切配置，参考<a target="_blank" rel="noopener" href="https://solana.com/zh/docs/intro/installation%EF%BC%8C%E9%9D%9E%E5%B8%B8%E8%AF%A6%E7%BB%86">https://solana.com/zh/docs/intro/installation，非常详细</a></p>
<p>一切准备就绪之后，可以尝试在测试网络上领取一些代币：</p>
<p>但是我目前总是会报错：<code>error: error sending request for url (https://api.devnet.solana.com/): operation timed out</code></p>
<p>所以直接访问了solana的水龙头网站领取：<a target="_blank" rel="noopener" href="https://faucet.solana.com/">https://faucet.solana.com/</a></p>
<p>然后在solana 浏览器上查看账户信息和交易记录（记得切换到测试网devnet）</p>
<p>此时我们可以看到网络选项中有一个叫custom RPC url 的选项，但是直接点击, 暂时无法切换到这个网络，Solana CLI 内置了测试验证器。运行本地验证器将允许您在本地部署和测试您的程序。</p>
<p>在单独的终端中，运行以下命令来启动本地验证器：<code>solana-test-validator</code>，之后再solana浏览器切换到custom rps url就可以看到网络变成localhost:8899</p>
<p>此时我们可以在本地终端进行测试代币的获取和转移，这是我在本地测试网通过<code>solana airdrop number</code>获取测试代币后，通过<code>solana transfer &lt;recipient_public_key&gt; &lt;amount&gt; --from&lt;sender_keypair_path&gt;</code>(<sender_keypair_path>表示你本地存储密钥对信息的id.json文件路径，可以通过ls ~&#x2F;.config&#x2F;solana&#x2F;id.json 获取)<br>进行的一笔交易:</p>
<p><a target="_blank" rel="noopener" href="https://explorer.solana.com/tx/4vFFbCAq4PCjXJH6oDdrBCfBDzRcpZhnZmWjjyvhfDx9pVMthNkqfUqAJhnBkvfph7KQhgatw44N5YMVYRHFMgzX?cluster=custom&customUrl=http://localhost:8899">https://explorer.solana.com/tx/4vFFbCAq4PCjXJH6oDdrBCfBDzRcpZhnZmWjjyvhfDx9pVMthNkqfUqAJhnBkvfph7KQhgatw44N5YMVYRHFMgzX?cluster=custom&amp;customUrl=http%3A%2F%2Flocalhost%3A8899</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/11/13/solana1/" data-id="cm3g0xx6x0000e4uy0283dv0t" data-title="solana 学习笔记一 Solana基础与环境搭建" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust25" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/09/rust25/" class="article-date">
  <time class="dt-published" datetime="2024-11-08T18:04:04.652Z" itemprop="datePublished">2024-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/09/rust25/">rust 学习笔记二十五 Rust中的共享内存</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Go语言的名言:不要用共享内存来通信,要用通信来共享内存</p>
<p>Rust支持通过共享状态来实现并发</p>
<p>Channel类似单所有权:一旦将值的所有权转移至Channel,就无法使用它了</p>
<p>共享内存并发类似多所有权:多个线程可以同时访问同一内存</p>
<h4 id="一-使用Mutex来每次只允许一个线程来访问数据"><a href="#一-使用Mutex来每次只允许一个线程来访问数据" class="headerlink" title="一.使用Mutex来每次只允许一个线程来访问数据"></a>一.使用Mutex来每次只允许一个线程来访问数据</h4><p>Mutex是mutualexclusion(互斥锁)的简写，在同一时刻,Mutex只允许一个线程来访问某些数据</p>
<p>想要访问数据:</p>
<ol>
<li><p>线程必须首先获取互斥锁(lock)</p>
</li>
<li><p>lock数据结构是mutex的一部分,它能跟踪谁对数据拥</p>
</li>
<li><p>有独立访问权</p>
</li>
<li><p>mutex通常被描述为:通过锁定系统来保护它所持有的数据</p>
</li>
</ol>
<h4 id="二-Mutex的两条规则"><a href="#二-Mutex的两条规则" class="headerlink" title="二.Mutex的两条规则"></a>二.Mutex的两条规则</h4><ol>
<li><p>在使用数据之前,必须尝试获取锁(lock)。</p>
</li>
<li><p>使用完mutex所保护的数据,必须对数据进行解锁,以便其它线程可以获取锁。</p>
</li>
</ol>
<h4 id="三-Mutex的API"><a href="#三-Mutex的API" class="headerlink" title="三.Mutex的API"></a>三.Mutex<T>的API</h4><p>通过Mutex::new(数据)来创建Mutex<T>, Mutex<T>是一个智能指针, 访问数据前,通过<code>lock</code>方法来获取锁,这会阻塞当前线程，lock可能会失败</p>
<p>返回的是MutexGuard(智能指针,实现了Deref和Drop))</p>
<p>如下所示：</p>
<p><img src="/../assets/img/25-1.jpg" alt="图25-1" title="25-1"></p>
<p>如果需要使用多个线程分别对上面的a值进行修改，在 创建线程进行修改后，对a值进行读取，不出所料，报错：</p>
<p><img src="/../assets/img/25-2.jpg" alt="图25-2" title="25-2"></p>
<p>根据以往的经验，使用Rc包裹变量可以通过引用计数，在修改变量后读取，但是报错显示：“Rx变量由于没实现Sent trait,无法在线程间共享“，</p>
<p>于是我们可以使用：</p>
<p>使用Arc<T>来进行原子引用记数，Arc<T>和RC<T>类似,它可以用于并发情景，Arc<T>和RC<T>的API是相同的：</p>
<p>如下所示：</p>
<p><img src="/../assets/img/25-3.jpg" alt="图25-3" title="25-3"></p>
<p>A:atomic,意为原子的，既然如此，为什么所有的基础类型都不是原子的,为什么标准库类型不默认使用Arc<T>呢，因为需要性能作为代价</p>
<h4 id="四-RefCell-Rc-vs-Mutex-Arc"><a href="#四-RefCell-Rc-vs-Mutex-Arc" class="headerlink" title="四.RefCell &#x2F; Rc vs Mutex &#x2F; Arc"></a>四.RefCell<T> &#x2F; Rc<T> vs Mutex<T> &#x2F; Arc<T></h4><p>Mutex<T>提供了内部可变性,和Cell家族一样,我们使用RefCell<T>来改变Rc<T>里面的内容,我们使用Mutex<T>来改变Arc<T>里面的内容</p>
<p>注意:Mutex<T>有死锁风险</p>
<h4 id="五-Send-和Sync-trait"><a href="#五-Send-和Sync-trait" class="headerlink" title="五.Send 和Sync trait"></a>五.Send 和Sync trait</h4><p>Rust语言的并发特性较少,目前讲的并发特新都来自标准库(而不是语言本身),但无需局限于标准库的并发,可以自己实现并发</p>
<p>但在Rust语言中有两个并发概念:</p>
<p>std::marker::Sync 和std::marker::Send 这两个 trait</p>
<h5 id="Send-允许线程间转移所有权"><a href="#Send-允许线程间转移所有权" class="headerlink" title="Send:允许线程间转移所有权"></a>Send:允许线程间转移所有权</h5><p>实现Send trait的类型可在线程间转移所有权，Rust中几乎所有的类型都实现了Send，但RC<T>没有实现Send,它<strong>只用于单线程情景</strong></p>
<p>任何完全由Send类型组成的类型也被标记为Send，除了原始指针之外,几乎所有的基础类型都是Send</p>
<h5 id="Sync-允许从多线程访问"><a href="#Sync-允许从多线程访问" class="headerlink" title="Sync:允许从多线程访问"></a>Sync:允许从多线程访问</h5><p>实现Sync的类型可以安全的被多个线程引用，也就是说:如果T是Sync,那么&amp;T就是Send，引用可以被安全的送往另一个线程</p>
<p>基础类型都是Sync，完全由Sync类型组成的类型也是Sync</p>
<p>但RC<T>不是Sync的，RefCell<T>和Cell<T>家族也不是Sync的，而Mutex<T>是Sync的</p>
<h4 id="六-实现一个多线程任务调度器"><a href="#六-实现一个多线程任务调度器" class="headerlink" title="六.实现一个多线程任务调度器"></a>六.实现一个多线程任务调度器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line">use std::thread::&#123;self, JoinHandle&#125;;</span><br><span class="line">use std::sync::mpsc;</span><br><span class="line">use std::time::Duration;</span><br><span class="line"></span><br><span class="line">struct Task &#123;</span><br><span class="line">    id: usize,</span><br><span class="line">    action: Arc&lt;Mutex&lt;Box&lt;dyn Fn() -&gt; String + Send + Sync&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Scheduler &#123;</span><br><span class="line">    task_queue: Vec&lt;Arc&lt;Task&gt;&gt;,</span><br><span class="line">    thread_pool: Vec&lt;JoinHandle&lt;()&gt;&gt;,</span><br><span class="line">    result_sender: mpsc::Sender&lt;String&gt;,</span><br><span class="line">    result_receiver: mpsc::Receiver&lt;String&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Scheduler &#123;</span><br><span class="line">    fn new() -&gt; Self &#123;</span><br><span class="line">        let (result_sender, result_receiver) = mpsc::channel();</span><br><span class="line">        Scheduler &#123;</span><br><span class="line">            task_queue: Vec::new(),</span><br><span class="line">            thread_pool: Vec::new(),</span><br><span class="line">            result_sender,</span><br><span class="line">            result_receiver</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn add_task&lt;F&gt;(&amp;mut self, id: usize, action: F)</span><br><span class="line">    where</span><br><span class="line">        F: Fn() -&gt; String +&#x27;static +Send + Sync,</span><br><span class="line">    &#123;</span><br><span class="line">        let task = Task &#123;</span><br><span class="line">            id,</span><br><span class="line">            action: Arc::new(Mutex::new(Box::new(action))),</span><br><span class="line">        &#125;;</span><br><span class="line">        self.task_queue.push(task.into());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn start(&amp;mut self, num_threads: usize) &#123;</span><br><span class="line">        let (sender, receiver) = mpsc::channel();</span><br><span class="line">        let receiver = Arc::new(Mutex::new(receiver));//Metux避免数据竞争，Arc实现引用计数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for task in self.task_queue.iter() &#123;</span><br><span class="line">            sender.send(Arc::clone(task)).unwrap(); // 发送任务</span><br><span class="line">            thread::sleep(Duration::from_millis(10)); // 模拟任务间隔</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">        for _ in 0..num_threads &#123;</span><br><span class="line">            let receiver_clone = Arc::clone(&amp;receiver);</span><br><span class="line">            let sender_clone = self.result_sender.clone();</span><br><span class="line">            let handle = thread::spawn(move || loop &#123;</span><br><span class="line">                match receiver_clone.lock().unwrap().recv() &#123;</span><br><span class="line">                    Ok(task) =&gt; &#123;</span><br><span class="line">                        let action_lock = task.action.lock().unwrap();</span><br><span class="line">                        let result:String = (action_lock)(); // 执行闭包</span><br><span class="line">                        sender_clone.send(result).unwrap();</span><br><span class="line">                    &#125;,</span><br><span class="line">                    Err(_) =&gt; break, // 通道已关闭</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            self.thread_pool.push(handle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn get_results(&amp;mut self)-&gt; Vec&lt;String&gt; &#123;</span><br><span class="line">        //等待所有任务执行完成</span><br><span class="line">        self.thread_pool.drain(..).for_each(|handle| &#123;</span><br><span class="line">            handle.join().unwrap(); // 等待每个线程完成</span><br><span class="line">        &#125;);</span><br><span class="line">        self.result_receiver.try_iter().collect()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut scheduler = Scheduler::new();</span><br><span class="line"></span><br><span class="line">    scheduler.add_task(1, || &quot;Hello&quot;.to_string());</span><br><span class="line">    scheduler.add_task(2, || &quot;World&quot;.to_string());</span><br><span class="line">    scheduler.add_task(3, || &quot;from Rust&quot;.to_string());</span><br><span class="line">    scheduler.add_task(4, || &quot;lcz&quot;.to_string());</span><br><span class="line"></span><br><span class="line">    scheduler.start(4);</span><br><span class="line"></span><br><span class="line">    thread::sleep(Duration::from_secs(1));</span><br><span class="line"></span><br><span class="line">    let results = scheduler.get_results();</span><br><span class="line">    for result in results &#123;</span><br><span class="line">        println!(&quot;Result: &#123;&#125;&quot;, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/11/09/rust25/" data-id="cm391q96u0000x4uyfuqgbv2i" data-title="rust 学习笔记二十五 Rust中的共享内存" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust24" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/03/rust24/" class="article-date">
  <time class="dt-published" datetime="2024-11-03T11:06:36.056Z" itemprop="datePublished">2024-11-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/03/rust24/">rust 学习笔记二十四 Rust的并发</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）先明确以下概念"><a href="#（一）先明确以下概念" class="headerlink" title="（一）先明确以下概念"></a>（一）先明确以下概念</h3><h4 id="1-并发与并行的区别："><a href="#1-并发与并行的区别：" class="headerlink" title="1.并发与并行的区别："></a>1.并发与并行的区别：</h4><p>并发(Concurrency):多个任务在时间上<strong>交替执行</strong></p>
<p>并行(Parallelism):多个任务<strong>同时执行</strong></p>
<h4 id="2-进程与线程"><a href="#2-进程与线程" class="headerlink" title="2.进程与线程"></a>2.进程与线程</h4><p>在大部分OS里,代码运行在进程(process)中,OS同时管理多个进程；</p>
<p>在你的程序里,各独立部分可以同时运行,运行这些独立部分的就是线程(thread)</p>
<h4 id="3-多线程运行"><a href="#3-多线程运行" class="headerlink" title="3.多线程运行"></a>3.多线程运行</h4><p>好处：提升性能表现</p>
<p>坏处：增加复杂性:无法保障各线程的执行顺序</p>
<p>多线程可导致的问题：竞争状态,线程死锁,两个线程彼此等待对方使用完所持有的资源,线程无法继续；只在某些情况下发生的Bug,很难可靠地复制现象和修复</p>
<h4 id="4-实现线程的方式"><a href="#4-实现线程的方式" class="headerlink" title="4.实现线程的方式"></a>4.实现线程的方式</h4><p>通过调用OS的API来创建线程:1:1模型,需要较小的运行时</p>
<p>语言自己实现的线程(绿色线程):M:N模型,需要更大的运行时</p>
<p>Rust:需要权衡运行时的支持</p>
<p>Rust标准库仅提供1:1模型的线程</p>
<h3 id="（二）Rust如何创建线程"><a href="#（二）Rust如何创建线程" class="headerlink" title="（二）Rust如何创建线程"></a>（二）Rust如何创建线程</h3><h4 id="1-创建新线程"><a href="#1-创建新线程" class="headerlink" title="1.创建新线程"></a>1.创建新线程</h4><p>通过 thread::spawn 函数可以创建新线程。参数:一个闭包(在新线程里运行的代码)</p>
<p><img src="/../assets/img/24-1.jpg" alt="图24-1" title="24-1"></p>
<p>由上面执行结果可以看出：</p>
<p>位于主线程和副线程的代码循环交替执行，且在主线程执行完之后，副线程虽然没有执行完，但是也很快结束了，如果希望在主线程执行完后，可以继续执行完副线程，可以</p>
<h4 id="2-通过join-Handle来等待所有线程完成"><a href="#2-通过join-Handle来等待所有线程完成" class="headerlink" title="2.通过join Handle来等待所有线程完成"></a>2.通过join Handle来等待所有线程完成</h4><p>thread::spawn函数的返回值类型是Join Handle，Join Handle持有值的所有权，调用其join方法,可以等待对应的其它线程的完成</p>
<p>join方法:调用handle的join方法会阻止当前运行线程的执行,直到handle所表示的这些线程终结。</p>
<p><img src="/../assets/img/24-2.jpg" alt="图24-2" title="24-2"></p>
<p>注：如果将handle.join().unwrap();副线程执行的代码写在了主线程执行之前，那么将会在副线程执行完之后再执行主线程，无法达到解决时间的效果</p>
<h4 id="3-使用move闭包"><a href="#3-使用move闭包" class="headerlink" title="3.使用move闭包"></a>3.使用move闭包</h4><p>move闭包通常和thread::spawn函数一起使用,它允许你使用其它线程的数据,创建线程时,把值的所有权从一个线程转移到另一个线程</p>
<p>如下所示：</p>
<p><img src="/../assets/img/24-3.jpg" alt="图24-3" title="24-3"></p>
<p>当闭包借用外界变量v时，提示：closure may outlive the current function, but it borrows <code>v</code>, which is owned by the current function<br>may outlive borrowed value <code>v</code>，为了确保外界变量的存活时间和闭包一样，需使用move:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let v = vec![1,2,3];</span><br><span class="line">let handle = thread::spawn(move ||&#123;</span><br><span class="line">    println!(&quot;here is a vector:&#123;:?&#125;&quot;,v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="（三）多线程通信"><a href="#（三）多线程通信" class="headerlink" title="（三）多线程通信"></a>（三）多线程通信</h3><h4 id="1-消息传递"><a href="#1-消息传递" class="headerlink" title="1.消息传递"></a>1.消息传递</h4><p>一种很流行且能保证安全并发的技术就是:消息传递。线程(或Actor)通过彼此发送消息(数据)来进行通信</p>
<p>Go语言的名言:不要用共享内存来通信,要用通信来共享内存。</p>
<p>Rust:Channel(标准库提供)</p>
<h4 id="2-Channel"><a href="#2-Channel" class="headerlink" title="2.Channel"></a>2.Channel</h4><p>Channel包含:发送端、接收端</p>
<p>调用发送端的方法,发送数据</p>
<p>接收端会检查和接收到达的数据</p>
<p>如果发送端、接收端中任意一端被丢弃了,那么Channel就”关闭”了</p>
<h4 id="3-创建channel"><a href="#3-创建channel" class="headerlink" title="3.创建channel"></a>3.创建channel</h4><p>使用mpsc::channel函数来创建Channel，mpsc表示multiple producer,single，consumer(多个生产者、一个消费者)</p>
<p>返回一个tuple(元组):里面元素分别是发送端、接收端</p>
<p>使用mpsc::sync_channel来创建带缓冲区的channel</p>
<p>入参为缓冲区大小,当缓冲区塞满时进行阻塞</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">use std::thread;</span><br><span class="line">use std::time::Duration;</span><br><span class="line">use std::sync::mpsc;</span><br><span class="line"></span><br><span class="line">fn main()&#123; </span><br><span class="line">    thread_study();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn thread_study () &#123;</span><br><span class="line">    let (tx, rx) = mpsc::channel();</span><br><span class="line">    let tx1 = mpsc::Sender::clone(&amp;tx);</span><br><span class="line">    </span><br><span class="line">    thread::spawn(move || &#123;</span><br><span class="line">        let vals = vec![</span><br><span class="line">            String::from(&quot;hi&quot;),</span><br><span class="line">            String::from(&quot;from&quot;),</span><br><span class="line">            String::from(&quot;the&quot;),</span><br><span class="line">            String::from(&quot;thread&quot;),</span><br><span class="line">        ];</span><br><span class="line">        for val in vals &#123;</span><br><span class="line">            tx.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_millis(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread::spawn(move || &#123;</span><br><span class="line">        let vals = vec![</span><br><span class="line">            String::from(&quot;hi&quot;),</span><br><span class="line">            String::from(&quot;from&quot;),</span><br><span class="line">            String::from(&quot;the&quot;),</span><br><span class="line">            String::from(&quot;thread&quot;),</span><br><span class="line">        ];</span><br><span class="line">        for val in vals &#123;</span><br><span class="line">            tx1.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_millis(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    for received in rx &#123;</span><br><span class="line">        println!(&quot;Got :&#123;&#125;&quot;,received);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h4><h5 id="发送端的方法"><a href="#发送端的方法" class="headerlink" title="发送端的方法"></a>发送端的方法</h5><p>send:</p>
<p>参数:想要发送的数据</p>
<p>返回:Result&lt;T,E&gt;，如果有问题(例如接收端已经被丢弃),就返回一个错误</p>
<h5 id="接收端的方法"><a href="#接收端的方法" class="headerlink" title="接收端的方法"></a>接收端的方法</h5><p>recv方法:</p>
<p><strong>阻止当前线程执行</strong>,直到Channel中有值被送来</p>
<p>·	 一旦有值收到,就返回Result&lt;T,E&gt;</p>
<p>·	 当发送端关闭,就会收到一个错误</p>
<p><img src="/../assets/img/24-4.jpg" alt="图24-4" title="24-4"></p>
<p>如图所示：虽然发送线程中设置了一秒钟的延时，但是接受线程中在第一次接受到内容并打印后，也在继续等待直到接收到下一个信息</p>
<p>try_recv方法:</p>
<p><strong>不会阻塞</strong></p>
<p>·   立即返回Result&lt;T,E&gt;:</p>
<p>·	有数据达到:返回Ok,里面包含着数据</p>
<p>·	否则,返回错误</p>
<p>·   通常会使用循环调用来检查try_recv的结果</p>
<p><img src="/../assets/img/24-5.jpg" alt="图24-5" title="24-5"></p>
<p>如图所示：使用loop循环来进行监听，而如果此处不进行循环，在执行一次 try_recv 操作后就会结束</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="1-单主线程多工作线程实现线程池处理文件"><a href="#1-单主线程多工作线程实现线程池处理文件" class="headerlink" title="1. 单主线程多工作线程实现线程池处理文件"></a>1. 单主线程多工作线程实现线程池处理文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">use crossbeam_channel::&#123;unbounded, Receiver, Sender&#125;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line"></span><br><span class="line">    let file_paths = vec![</span><br><span class="line">        &quot;file1.txt&quot;, &quot;file2.txt&quot;, &quot;file3.txt&quot;, &quot;file4.txt&quot;,</span><br><span class="line">        &quot;file5.txt&quot;, &quot;file6.txt&quot;, &quot;file7.txt&quot;, &quot;file8.txt&quot;,</span><br><span class="line">        &quot;file9.txt&quot;, &quot;file10.txt&quot;,</span><br><span class="line">        &quot;file11.txt&quot;, &quot;file12.txt&quot;, &quot;file13.txt&quot;, &quot;file14.txt&quot;,</span><br><span class="line">        &quot;file15.txt&quot;, &quot;file16.txt&quot;, &quot;file17.txt&quot;, &quot;file18.txt&quot;,</span><br><span class="line">        &quot;file19.txt&quot;, &quot;file20.txt&quot;,</span><br><span class="line">    ];</span><br><span class="line">    // 创建一个可以被多个消费者共享的通道</span><br><span class="line">    let (tx, rx) = unbounded();</span><br><span class="line"></span><br><span class="line">    // 创建一个向通道发送任务的生产者线程</span><br><span class="line">    let producer_handle = std::thread::spawn(move || &#123;</span><br><span class="line">        for i in 0..10&#123;</span><br><span class="line">            tx.send(file_paths[i]).unwrap();</span><br><span class="line">            // std::thread::sleep(std::time::Duration::from_millis(100));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 创建多个消费者线程</span><br><span class="line">    let num_consumers = 4;</span><br><span class="line"></span><br><span class="line">    let consumer_handles = (0..num_consumers).map(|i| &#123;</span><br><span class="line">        let rx = rx.clone(); // `crossbeam-channel` 的 Receiver 可以被克隆</span><br><span class="line">        thread::spawn(move || &#123;</span><br><span class="line">            while let Ok(task) = rx.recv() &#123;</span><br><span class="line">                println!(&quot;Consumer processed task: &#123;&#125;, &#123;&#125;&quot;, task, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).collect::&lt;Vec&lt;_&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 等待生产者线程结束</span><br><span class="line">    producer_handle.join().unwrap();</span><br><span class="line"></span><br><span class="line">    // 等待所有消费者线程结束</span><br><span class="line">    for handle in consumer_handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/11/03/rust24/" data-id="cm31qkqgp000058uy2rtsa7vx" data-title="rust 学习笔记二十四 Rust的并发" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/30/hardhat/">Hardhat持久化本地节点：保持合约状态的利器</a>
          </li>
        
          <li>
            <a href="/2025/03/18/raydium/">在Solana Devnet上 对 raydium Swap功能的应用实践</a>
          </li>
        
          <li>
            <a href="/2025/02/23/nftmint/">本地开发DEX：nft创建与mint的两种方式</a>
          </li>
        
          <li>
            <a href="/2025/02/15/dex/">本地开发DEX：购买ETF的两种策略</a>
          </li>
        
          <li>
            <a href="/2024/11/26/solana4/">solana 学习笔记四 Solana基础 - Token解析&amp;创建</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Liu Canzhu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>