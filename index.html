<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>canzhu&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="canzhu&#39;s blog">
<meta property="og:url" content="https://liucanzhu.github.io/index.html">
<meta property="og:site_name" content="canzhu&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liu Canzhu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="canzhu's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">canzhu&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://liucanzhu.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-rust25" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/09/rust25/" class="article-date">
  <time class="dt-published" datetime="2024-11-08T18:04:04.652Z" itemprop="datePublished">2024-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/09/rust25/">rust 学习笔记二十五 Rust中的共享内存</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Go语言的名言:不要用共享内存来通信,要用通信来共享内存</p>
<p>Rust支持通过共享状态来实现并发</p>
<p>Channel类似单所有权:一旦将值的所有权转移至Channel,就无法使用它了</p>
<p>共享内存并发类似多所有权:多个线程可以同时访问同一内存</p>
<h4 id="一-使用Mutex来每次只允许一个线程来访问数据"><a href="#一-使用Mutex来每次只允许一个线程来访问数据" class="headerlink" title="一.使用Mutex来每次只允许一个线程来访问数据"></a>一.使用Mutex来每次只允许一个线程来访问数据</h4><p>Mutex是mutualexclusion(互斥锁)的简写，在同一时刻,Mutex只允许一个线程来访问某些数据</p>
<p>想要访问数据:</p>
<ol>
<li><p>线程必须首先获取互斥锁(lock)</p>
</li>
<li><p>lock数据结构是mutex的一部分,它能跟踪谁对数据拥</p>
</li>
<li><p>有独立访问权</p>
</li>
<li><p>mutex通常被描述为:通过锁定系统来保护它所持有的数据</p>
</li>
</ol>
<h4 id="二-Mutex的两条规则"><a href="#二-Mutex的两条规则" class="headerlink" title="二.Mutex的两条规则"></a>二.Mutex的两条规则</h4><ol>
<li><p>在使用数据之前,必须尝试获取锁(lock)。</p>
</li>
<li><p>使用完mutex所保护的数据,必须对数据进行解锁,以便其它线程可以获取锁。</p>
</li>
</ol>
<h4 id="三-Mutex的API"><a href="#三-Mutex的API" class="headerlink" title="三.Mutex的API"></a>三.Mutex<T>的API</h4><p>通过Mutex::new(数据)来创建Mutex<T>, Mutex<T>是一个智能指针, 访问数据前,通过<code>lock</code>方法来获取锁,这会阻塞当前线程，lock可能会失败</p>
<p>返回的是MutexGuard(智能指针,实现了Deref和Drop))</p>
<p>如下所示：</p>
<p><img src="/../assets/img/25-1.jpg" alt="图25-1" title="25-1"></p>
<p>如果需要使用多个线程分别对上面的a值进行修改，在 创建线程进行修改后，对a值进行读取，不出所料，报错：</p>
<p><img src="/../assets/img/25-2.jpg" alt="图25-2" title="25-2"></p>
<p>根据以往的经验，使用Rc包裹变量可以通过引用计数，在修改变量后读取，但是报错显示：“Rx变量由于没实现Sent trait,无法在线程间共享“，</p>
<p>于是我们可以使用：</p>
<p>使用Arc<T>来进行原子引用记数，Arc<T>和RC<T>类似,它可以用于并发情景，Arc<T>和RC<T>的API是相同的：</p>
<p>如下所示：</p>
<p><img src="/../assets/img/25-3.jpg" alt="图25-3" title="25-3"></p>
<p>A:atomic,意为原子的，既然如此，为什么所有的基础类型都不是原子的,为什么标准库类型不默认使用Arc<T>呢，因为需要性能作为代价</p>
<h4 id="四-RefCell-Rc-vs-Mutex-Arc"><a href="#四-RefCell-Rc-vs-Mutex-Arc" class="headerlink" title="四.RefCell &#x2F; Rc vs Mutex &#x2F; Arc"></a>四.RefCell<T> &#x2F; Rc<T> vs Mutex<T> &#x2F; Arc<T></h4><p>Mutex<T>提供了内部可变性,和Cell家族一样,我们使用RefCell<T>来改变Rc<T>里面的内容,我们使用Mutex<T>来改变Arc<T>里面的内容</p>
<p>注意:Mutex<T>有死锁风险</p>
<h4 id="五-Send-和Sync-trait"><a href="#五-Send-和Sync-trait" class="headerlink" title="五.Send 和Sync trait"></a>五.Send 和Sync trait</h4><p>Rust语言的并发特性较少,目前讲的并发特新都来自标准库(而不是语言本身),但无需局限于标准库的并发,可以自己实现并发</p>
<p>但在Rust语言中有两个并发概念:</p>
<p>std::marker::Sync 和std::marker::Send 这两个 trait</p>
<h5 id="Send-允许线程间转移所有权"><a href="#Send-允许线程间转移所有权" class="headerlink" title="Send:允许线程间转移所有权"></a>Send:允许线程间转移所有权</h5><p>实现Send trait的类型可在线程间转移所有权，Rust中几乎所有的类型都实现了Send，但RC<T>没有实现Send,它<strong>只用于单线程情景</strong></p>
<p>任何完全由Send类型组成的类型也被标记为Send，除了原始指针之外,几乎所有的基础类型都是Send</p>
<h5 id="Sync-允许从多线程访问"><a href="#Sync-允许从多线程访问" class="headerlink" title="Sync:允许从多线程访问"></a>Sync:允许从多线程访问</h5><p>实现Sync的类型可以安全的被多个线程引用，也就是说:如果T是Sync,那么&amp;T就是Send，引用可以被安全的送往另一个线程</p>
<p>基础类型都是Sync，完全由Sync类型组成的类型也是Sync</p>
<p>但RC<T>不是Sync的，RefCell<T>和Cell<T>家族也不是Sync的，而Mutex<T>是Sync的</p>
<h4 id="六-实现一个多线程任务调度器"><a href="#六-实现一个多线程任务调度器" class="headerlink" title="六.实现一个多线程任务调度器"></a>六.实现一个多线程任务调度器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line">use std::thread::&#123;self, sleep, JoinHandle&#125;;</span><br><span class="line">use std::sync::mpsc;</span><br><span class="line">use std::time::Duration;</span><br><span class="line"></span><br><span class="line">struct Task &#123;</span><br><span class="line">    id: usize,</span><br><span class="line">    action: Arc&lt;Mutex&lt;Box&lt;dyn Fn() + Send +Sync&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Scheduler &#123;</span><br><span class="line">    task_queue: Arc&lt;Mutex&lt;Vec&lt;Arc&lt;Task&gt;&gt;&gt;&gt;,</span><br><span class="line">    thread_pool: Vec&lt;JoinHandle&lt;()&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Scheduler &#123;</span><br><span class="line">    fn new() -&gt; Self &#123;</span><br><span class="line">        Scheduler &#123;</span><br><span class="line">            task_queue: Arc::new(Mutex::new(Vec::new())),</span><br><span class="line">            thread_pool: Vec::new(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn add_task&lt;F&gt;(&amp;mut self, id: usize, action: F)</span><br><span class="line">    where</span><br><span class="line">        F: Fn() +&#x27;static +Send + Sync,</span><br><span class="line">    &#123;</span><br><span class="line">        let task = Task &#123;</span><br><span class="line">            id,</span><br><span class="line">            action: Arc::new(Mutex::new(Box::new(action))),</span><br><span class="line">        &#125;;</span><br><span class="line">        self.task_queue.lock().unwrap().push(task.into());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn start(&amp;mut self, num_threads: usize) &#123;</span><br><span class="line">        let (sender, receiver) = mpsc::channel();</span><br><span class="line">        let receiver = Arc::new(Mutex::new(receiver));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for task in self.task_queue.lock().unwrap().iter() &#123;</span><br><span class="line">            sender.send(Arc::clone(task)).unwrap(); // 发送任务</span><br><span class="line">            thread::sleep(Duration::from_millis(10)); // 模拟任务间隔</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for _ in 0..num_threads &#123;</span><br><span class="line">            let receiver_clone = Arc::clone(&amp;receiver);</span><br><span class="line">            let handle = thread::spawn(move || loop &#123;</span><br><span class="line">                match receiver_clone.lock().unwrap().recv() &#123;</span><br><span class="line">                    Ok(task) =&gt; &#123;</span><br><span class="line">                        let action_lock = task.action.lock().unwrap();</span><br><span class="line">                        (action_lock)(); // 执行闭包</span><br><span class="line">                    &#125;,</span><br><span class="line">                    Err(_) =&gt; break, // 通道已关闭</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            self.thread_pool.push(handle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn get_results(&amp;mut self) &#123;</span><br><span class="line">        for handle in self.thread_pool.drain(..) &#123;</span><br><span class="line">            handle.join().unwrap(); // 等待每个线程完成</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut scheduler = Scheduler::new();</span><br><span class="line"></span><br><span class="line">    scheduler.add_task(1, || &#123;println!(&quot;111&quot;);&#125;);</span><br><span class="line">    scheduler.add_task(2, || &#123;println!(&quot;222&quot;);&#125;);</span><br><span class="line">    scheduler.add_task(3, || &#123;println!(&quot;333&quot;);&#125;);</span><br><span class="line">    scheduler.add_task(4, || &#123;println!(&quot;444&quot;);&#125;);</span><br><span class="line"></span><br><span class="line">    scheduler.start(4);</span><br><span class="line"></span><br><span class="line">    thread::sleep(Duration::from_secs(1));</span><br><span class="line"></span><br><span class="line">    scheduler.get_results();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/11/09/rust25/" data-id="cm391q96u0000x4uyfuqgbv2i" data-title="rust 学习笔记二十五 Rust中的共享内存" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust24" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/03/rust24/" class="article-date">
  <time class="dt-published" datetime="2024-11-03T11:06:36.056Z" itemprop="datePublished">2024-11-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/03/rust24/">rust 学习笔记二十四 Rust的并发</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）先明确以下概念"><a href="#（一）先明确以下概念" class="headerlink" title="（一）先明确以下概念"></a>（一）先明确以下概念</h3><h4 id="1-并发与并行的区别："><a href="#1-并发与并行的区别：" class="headerlink" title="1.并发与并行的区别："></a>1.并发与并行的区别：</h4><p>并发(Concurrency):多个任务在时间上<strong>交替执行</strong></p>
<p>并行(Parallelism):多个任务<strong>同时执行</strong></p>
<h4 id="2-进程与线程"><a href="#2-进程与线程" class="headerlink" title="2.进程与线程"></a>2.进程与线程</h4><p>在大部分OS里,代码运行在进程(process)中,OS同时管理多个进程；</p>
<p>在你的程序里,各独立部分可以同时运行,运行这些独立部分的就是线程(thread)</p>
<h4 id="3-多线程运行"><a href="#3-多线程运行" class="headerlink" title="3.多线程运行"></a>3.多线程运行</h4><p>好处：提升性能表现</p>
<p>坏处：增加复杂性:无法保障各线程的执行顺序</p>
<p>多线程可导致的问题：竞争状态,线程死锁,两个线程彼此等待对方使用完所持有的资源,线程无法继续；只在某些情况下发生的Bug,很难可靠地复制现象和修复</p>
<h4 id="4-实现线程的方式"><a href="#4-实现线程的方式" class="headerlink" title="4.实现线程的方式"></a>4.实现线程的方式</h4><p>通过调用OS的API来创建线程:1:1模型,需要较小的运行时</p>
<p>语言自己实现的线程(绿色线程):M:N模型,需要更大的运行时</p>
<p>Rust:需要权衡运行时的支持</p>
<p>Rust标准库仅提供1:1模型的线程</p>
<h3 id="（二）Rust如何创建线程"><a href="#（二）Rust如何创建线程" class="headerlink" title="（二）Rust如何创建线程"></a>（二）Rust如何创建线程</h3><h4 id="1-创建新线程"><a href="#1-创建新线程" class="headerlink" title="1.创建新线程"></a>1.创建新线程</h4><p>通过 thread::spawn 函数可以创建新线程。参数:一个闭包(在新线程里运行的代码)</p>
<p><img src="/../assets/img/24-1.jpg" alt="图24-1" title="24-1"></p>
<p>由上面执行结果可以看出：</p>
<p>位于主线程和副线程的代码循环交替执行，且在主线程执行完之后，副线程虽然没有执行完，但是也很快结束了，如果希望在主线程执行完后，可以继续执行完副线程，可以</p>
<h4 id="2-通过join-Handle来等待所有线程完成"><a href="#2-通过join-Handle来等待所有线程完成" class="headerlink" title="2.通过join Handle来等待所有线程完成"></a>2.通过join Handle来等待所有线程完成</h4><p>thread::spawn函数的返回值类型是Join Handle，Join Handle持有值的所有权，调用其join方法,可以等待对应的其它线程的完成</p>
<p>join方法:调用handle的join方法会阻止当前运行线程的执行,直到handle所表示的这些线程终结。</p>
<p><img src="/../assets/img/24-2.jpg" alt="图24-2" title="24-2"></p>
<p>注：如果将handle.join().unwrap();副线程执行的代码写在了主线程执行之前，那么将会在副线程执行完之后再执行主线程，无法达到解决时间的效果</p>
<h4 id="3-使用move闭包"><a href="#3-使用move闭包" class="headerlink" title="3.使用move闭包"></a>3.使用move闭包</h4><p>move闭包通常和thread::spawn函数一起使用,它允许你使用其它线程的数据,创建线程时,把值的所有权从一个线程转移到另一个线程</p>
<p>如下所示：</p>
<p><img src="/../assets/img/24-3.jpg" alt="图24-3" title="24-3"></p>
<p>当闭包借用外界变量v时，提示：closure may outlive the current function, but it borrows <code>v</code>, which is owned by the current function<br>may outlive borrowed value <code>v</code>，为了确保外界变量的存活时间和闭包一样，需使用move:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let v = vec![1,2,3];</span><br><span class="line">let handle = thread::spawn(move ||&#123;</span><br><span class="line">    println!(&quot;here is a vector:&#123;:?&#125;&quot;,v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="（三）多线程通信"><a href="#（三）多线程通信" class="headerlink" title="（三）多线程通信"></a>（三）多线程通信</h3><h4 id="1-消息传递"><a href="#1-消息传递" class="headerlink" title="1.消息传递"></a>1.消息传递</h4><p>一种很流行且能保证安全并发的技术就是:消息传递。线程(或Actor)通过彼此发送消息(数据)来进行通信</p>
<p>Go语言的名言:不要用共享内存来通信,要用通信来共享内存。</p>
<p>Rust:Channel(标准库提供)</p>
<h4 id="2-Channel"><a href="#2-Channel" class="headerlink" title="2.Channel"></a>2.Channel</h4><p>Channel包含:发送端、接收端</p>
<p>调用发送端的方法,发送数据</p>
<p>接收端会检查和接收到达的数据</p>
<p>如果发送端、接收端中任意一端被丢弃了,那么Channel就”关闭”了</p>
<h4 id="3-创建channel"><a href="#3-创建channel" class="headerlink" title="3.创建channel"></a>3.创建channel</h4><p>使用mpsc::channel函数来创建Channel，mpsc表示multiple producer,single，consumer(多个生产者、一个消费者)</p>
<p>返回一个tuple(元组):里面元素分别是发送端、接收端</p>
<p>使用mpsc::sync_channel来创建带缓冲区的channel</p>
<p>入参为缓冲区大小,当缓冲区塞满时进行阻塞</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">use std::thread;</span><br><span class="line">use std::time::Duration;</span><br><span class="line">use std::sync::mpsc;</span><br><span class="line"></span><br><span class="line">fn main()&#123; </span><br><span class="line">    thread_study();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn thread_study () &#123;</span><br><span class="line">    let (tx, rx) = mpsc::channel();</span><br><span class="line">    let tx1 = mpsc::Sender::clone(&amp;tx);</span><br><span class="line">    </span><br><span class="line">    thread::spawn(move || &#123;</span><br><span class="line">        let vals = vec![</span><br><span class="line">            String::from(&quot;hi&quot;),</span><br><span class="line">            String::from(&quot;from&quot;),</span><br><span class="line">            String::from(&quot;the&quot;),</span><br><span class="line">            String::from(&quot;thread&quot;),</span><br><span class="line">        ];</span><br><span class="line">        for val in vals &#123;</span><br><span class="line">            tx.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_millis(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread::spawn(move || &#123;</span><br><span class="line">        let vals = vec![</span><br><span class="line">            String::from(&quot;hi&quot;),</span><br><span class="line">            String::from(&quot;from&quot;),</span><br><span class="line">            String::from(&quot;the&quot;),</span><br><span class="line">            String::from(&quot;thread&quot;),</span><br><span class="line">        ];</span><br><span class="line">        for val in vals &#123;</span><br><span class="line">            tx1.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_millis(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    for received in rx &#123;</span><br><span class="line">        println!(&quot;Got :&#123;&#125;&quot;,received);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h4><h5 id="发送端的方法"><a href="#发送端的方法" class="headerlink" title="发送端的方法"></a>发送端的方法</h5><p>send:</p>
<p>参数:想要发送的数据</p>
<p>返回:Result&lt;T,E&gt;，如果有问题(例如接收端已经被丢弃),就返回一个错误</p>
<h5 id="接收端的方法"><a href="#接收端的方法" class="headerlink" title="接收端的方法"></a>接收端的方法</h5><p>recv方法:</p>
<p><strong>阻止当前线程执行</strong>,直到Channel中有值被送来</p>
<p>·	 一旦有值收到,就返回Result&lt;T,E&gt;</p>
<p>·	 当发送端关闭,就会收到一个错误</p>
<p><img src="/../assets/img/24-4.jpg" alt="图24-4" title="24-4"></p>
<p>如图所示：虽然发送线程中设置了一秒钟的延时，但是接受线程中在第一次接受到内容并打印后，也在继续等待直到接收到下一个信息</p>
<p>try_recv方法:</p>
<p><strong>不会阻塞</strong></p>
<p>·   立即返回Result&lt;T,E&gt;:</p>
<p>·	有数据达到:返回Ok,里面包含着数据</p>
<p>·	否则,返回错误</p>
<p>·   通常会使用循环调用来检查try_recv的结果</p>
<p><img src="/../assets/img/24-5.jpg" alt="图24-5" title="24-5"></p>
<p>如图所示：使用loop循环来进行监听，而如果此处不进行循环，在执行一次 try_recv 操作后就会结束</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="1-单主线程多工作线程实现线程池处理文件"><a href="#1-单主线程多工作线程实现线程池处理文件" class="headerlink" title="1. 单主线程多工作线程实现线程池处理文件"></a>1. 单主线程多工作线程实现线程池处理文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">use crossbeam_channel::&#123;unbounded, Receiver, Sender&#125;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line"></span><br><span class="line">    let file_paths = vec![</span><br><span class="line">        &quot;file1.txt&quot;, &quot;file2.txt&quot;, &quot;file3.txt&quot;, &quot;file4.txt&quot;,</span><br><span class="line">        &quot;file5.txt&quot;, &quot;file6.txt&quot;, &quot;file7.txt&quot;, &quot;file8.txt&quot;,</span><br><span class="line">        &quot;file9.txt&quot;, &quot;file10.txt&quot;,</span><br><span class="line">        &quot;file11.txt&quot;, &quot;file12.txt&quot;, &quot;file13.txt&quot;, &quot;file14.txt&quot;,</span><br><span class="line">        &quot;file15.txt&quot;, &quot;file16.txt&quot;, &quot;file17.txt&quot;, &quot;file18.txt&quot;,</span><br><span class="line">        &quot;file19.txt&quot;, &quot;file20.txt&quot;,</span><br><span class="line">    ];</span><br><span class="line">    // 创建一个可以被多个消费者共享的通道</span><br><span class="line">    let (tx, rx) = unbounded();</span><br><span class="line"></span><br><span class="line">    // 创建一个向通道发送任务的生产者线程</span><br><span class="line">    let producer_handle = std::thread::spawn(move || &#123;</span><br><span class="line">        for i in 0..10&#123;</span><br><span class="line">            tx.send(file_paths[i]).unwrap();</span><br><span class="line">            // std::thread::sleep(std::time::Duration::from_millis(100));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 创建多个消费者线程</span><br><span class="line">    let num_consumers = 4;</span><br><span class="line"></span><br><span class="line">    let consumer_handles = (0..num_consumers).map(|i| &#123;</span><br><span class="line">        let rx = rx.clone(); // `crossbeam-channel` 的 Receiver 可以被克隆</span><br><span class="line">        thread::spawn(move || &#123;</span><br><span class="line">            while let Ok(task) = rx.recv() &#123;</span><br><span class="line">                println!(&quot;Consumer processed task: &#123;&#125;, &#123;&#125;&quot;, task, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).collect::&lt;Vec&lt;_&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 等待生产者线程结束</span><br><span class="line">    producer_handle.join().unwrap();</span><br><span class="line"></span><br><span class="line">    // 等待所有消费者线程结束</span><br><span class="line">    for handle in consumer_handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/11/03/rust24/" data-id="cm31qkqgp000058uy2rtsa7vx" data-title="rust 学习笔记二十四 Rust的并发" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust23" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/31/rust23/" class="article-date">
  <time class="dt-published" datetime="2024-10-31T15:29:54.176Z" itemprop="datePublished">2024-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/31/rust23/">rust 学习笔记二十三 Rust测试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Rust支持以下测试：</p>
<h3 id="（一）Unit"><a href="#（一）Unit" class="headerlink" title="（一）Unit"></a>（一）Unit</h3><p>单元测试实例如下：</p>
<p><img src="/../assets/img/23-1.jpg" alt="图23-1" title="23-1"></p>
<p>直接点击每一个mod上方的运行符号即可执行这个测试mod并在终端查看运行结果,在mod中每一个测试函数上方，都用一个属性宏#[test]来表示这是一个单元测试，在函数中，除了用assert_eq!()来判断是否执行成功以外，也可以通过返回Result类型，如下所示：</p>
<p><img src="/../assets/img/23-2.jpg" alt="图23-2" title="23-2"></p>
<p>当我们在这个函数中手动抛出一个Err()时，运行结果显示测试结果失败</p>
<p>已知暂未开发完的函数，不希望发生panic的情况下，需要在函数中调用todo!宏，并在函数上方注明    #[should_panic]，即可跳过报错，如果需要跳过整个单元测试，则需要在函数上方注明：    #[ignore]</p>
<h3 id="（二）Integration"><a href="#（二）Integration" class="headerlink" title="（二）Integration"></a>（二）Integration</h3><p>在根目录下新建tests文件夹，创建集成测试文件，可以在这里调用src 中lib文件中的单元测试函数，然后在控制台中执行cargo test，会先挨个进行单元测试，再进行集成测试，如果只需要执行集成测试，则在cargo test后加上—test 集成文件名，因为cargo 会将tests目录下的每一个文件都识别为一个crate，也可以通过cargo test 函数名来执行争对lib文件中某一个函数的单元测试，如果不同的单元测试中有一些共同的操作，可以将这些操作封装成函数，在tests目录下再新建子目录，在其中新建mod.rs文件，将函数封装在此处，因为直接在tests中新建文件的话也会被识别为测试文件</p>
<h3 id="（三）Docs"><a href="#（三）Docs" class="headerlink" title="（三）Docs"></a>（三）Docs</h3><p>文档测试写法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">///Add to number</span><br><span class="line">/// #Example</span><br><span class="line">/// ```rust</span><br><span class="line">/// assert_eq!(rust_lib::add(1,1),2)</span><br><span class="line">/// ```</span><br><span class="line">/// # Panic</span><br><span class="line">/// # Errors</span><br><span class="line">/// # Safety</span><br></pre></td></tr></table></figure>

<p>在终端通过<code>cargo test –doc</code>执行文档测试</p>
<h3 id="（四）Examples"><a href="#（四）Examples" class="headerlink" title="（四）Examples"></a>（四）Examples</h3><p>当大型项目开发完后，需要写一些demo示范如何使用：在根目录下创建example目录，可以创建一个文件，在其中调用写好的方法，也可以创建一些测试用例：<br>此时可以在控制台输入<code>cargo test – example crate名</code>执行其中的测试用例，也可以通过<code>cargo test – examples</code>执行examples目录下所有测试</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>创建一个带各种测试的crate并通过ci yaml推送到crates.io并同步更新</p>
<p><a target="_blank" rel="noopener" href="https://github.com/liucanzhu/rust-test">https://github.com/liucanzhu/rust-test</a></p>
<p><a target="_blank" rel="noopener" href="https://crates.io/crates/lcz-rust-test">https://crates.io/crates/lcz-rust-test</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/10/31/rust23/" data-id="cm2yv4hkr00002suyakob2tf2" data-title="rust 学习笔记二十三 Rust测试" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust22" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/29/rust22/" class="article-date">
  <time class="dt-published" datetime="2024-10-29T14:51:01.745Z" itemprop="datePublished">2024-10-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/29/rust22/">rust 学习笔记二十二 Rust中的迭代器&amp;关联类型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）什么是迭代器"><a href="#（一）什么是迭代器" class="headerlink" title="（一）什么是迭代器"></a>（一）什么是迭代器</h3><p>迭代器模式:对一系列项执行某些任务</p>
<p>迭代器负责遍历每个项,确定序列(遍历)何时完成</p>
<p>Rust的迭代器是懒惰的，除非调用<strong>消费迭代器</strong>的方法,否则迭代器本身没有有任何效果</p>
<h3 id="（二）迭代器的实现"><a href="#（二）迭代器的实现" class="headerlink" title="（二）迭代器的实现"></a>（二）迭代器的实现</h3><p>迭代器是一个能够逐一生成元素的对象。它提供了一个统一的接口,用于遍历容器中的元素,同时保证了类型安全和内存安全。在Rust中,迭代器是实现了Iterator trait的对象。该trait定义了一个<strong>next方法,用于返回下一个元素</strong>。所有迭代器都实现了Iterator Trait,Iterator Trait定义于标准库,定义大致如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pub trait Iterator&#123;</span><br><span class="line">    type Item;</span><br><span class="line">    fn next(&amp;mut self)-&gt; Option&lt;Self::Item&gt;;</span><br><span class="line">    //methods with default inplementations elided</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>type item和Self::item定义了与此该trait关联的类型。</p>
<p>实现Iterator trait需要你定义一个Item类型,它用于<strong>next方法的返回类型(迭代器的返回类型)</strong></p>
<h3 id="（三）关联类型"><a href="#（三）关联类型" class="headerlink" title="（三）关联类型"></a>（三）关联类型</h3><p>关联类型是Trait中的类型占位符,它可以用于Trait的方法签名中，可以定义出包含某些类型的Trait,而在实现前无需知道这些类型是什么</p>
<h4 id="关联类型与泛型的区别"><a href="#关联类型与泛型的区别" class="headerlink" title="关联类型与泛型的区别"></a>关联类型与泛型的区别</h4><p>范型</p>
<p>每次实现Trait时标注类型<br>可以为一个类型多次实现某个Trait(不同的泛型参数)</p>
<p>关联类型</p>
<p>无需标注类型<br>无法为单个类型多次实现某个Trait</p>
<h3 id="（四）简单迭代器"><a href="#（四）简单迭代器" class="headerlink" title="（四）简单迭代器"></a>（四）简单迭代器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let numbers=vec![1,2,3,4,5];</span><br><span class="line">let mut iter=numbers.iter();//创建迭代器</span><br><span class="line">while let Some(num)=iter.next()&#123;//使用迭代器逐一获取元素</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let v1 = vec![1,2,3];</span><br><span class="line">let v1_iter = v1.iter();</span><br><span class="line">for val in v1_iter&#123;</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;,val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释:<br>numbers.iter()创建了一个迭代器,该迭代器按顺序返回 numbers向量中的每个元素。<br>iter.next()返回迭代器中的下一个元素。如果没有更更多元素,返回None</p>
<p>在上面的两种遍历方法中，如果是使用 while let Some(xxx)&#x3D;iter.next()的语法遍历，要求iter必须声明为mut,而for…in iter的语法遍历，却不用将其声明为mut,可以理解为，在第一种遍历方式中，每一次next，都会消耗迭代器中的一个元素，会<strong>使迭代器发生变化</strong>，所以需要将其声明为mut,而是用for in时，是通过引用获取到其中每一个变量的所有权，而不改变迭代器本身</p>
<h3 id="（五）几个迭代的方法"><a href="#（五）几个迭代的方法" class="headerlink" title="（五）几个迭代的方法"></a>（五）几个迭代的方法</h3><p>iter方法:在不可变引用上创建迭代器</p>
<p>into_iter方法:创建的迭代器会获得所有权</p>
<p>iter_mut方法:迭代可变的引用</p>
<h3 id="（六）消耗迭代器的方法"><a href="#（六）消耗迭代器的方法" class="headerlink" title="（六）消耗迭代器的方法"></a>（六）消耗迭代器的方法</h3><p>在标准库中,Iterator trait有一些带默认实现的方法，其中有一些方法会调用next方法，这也是实现Iterator trait时必须实现next方法的原因之一</p>
<p><strong>调用next的方法叫做”消耗型适配器”，因为调用它们会把迭代器消耗尽</strong></p>
<p>例如:sum方法(就会耗尽迭代器)<br>。取得迭代器的所有权<br>。通过反复调用next,遍历所有元素<br>。每次迭代,把当前元素添加到一个总和里,迭代结束,返回总和</p>
<h3 id="（七）产生其他迭代器的方法"><a href="#（七）产生其他迭代器的方法" class="headerlink" title="（七）产生其他迭代器的方法"></a>（七）产生其他迭代器的方法</h3><p>定义在Iterator trait上的另外一些方法叫做”迭代器适配器”，把迭代器转换为不同种类的迭代器，可以通过链式调用使用多个迭代器适配器来执行复杂的操作,这种调用可读性较高。</p>
<p>比如：</p>
<h4 id="1-map方法"><a href="#1-map方法" class="headerlink" title="1.map方法"></a>1.map方法</h4><p>map方法允许我们对迭代器中的每个元素应用一个函数,并返回一个新的迭代器。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let numbers=vec![1,2,3,4,5];</span><br><span class="line">    let squares:Vec&lt;i32&gt;=numbers.iter()</span><br><span class="line">    .map(|x|x*x)//每个元素平方</span><br><span class="line">    .collect();//收集结果</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;,squares);//输出[1,4,9,16,25]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释:</p>
<p>map将一个闭包应用于每个元素,这里是计算平方。</p>
<p>collect消耗型适配器,将迭代器的结果收集到一个容器中,这里是Vec<i32>。</p>
<h4 id="2-filter-方法"><a href="#2-filter-方法" class="headerlink" title="2.filter 方法"></a>2.filter 方法</h4><p>filter方法允许我们根据条件筛选元素,并返回满足条件的元素的迭代器</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let numbers=vec![1,2,3,4,5];</span><br><span class="line">    let even_numbers:Vec&lt;_&gt;=numbers.iter()</span><br><span class="line">    .filter(|&amp;x|x % 2==0)//筛选偶数</span><br><span class="line">    .collect();</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;,even_numbers);//输出[2,4]</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>解释:</p>
<p>filter筛选出所有满足闭包条件(偶数)的元素。</p>
<h3 id="（八）自定义迭代器"><a href="#（八）自定义迭代器" class="headerlink" title="（八）自定义迭代器"></a>（八）自定义迭代器</h3><p>即实现 Iterator trait</p>
<p>可以通过实现Iterator trait来创建自己的迭代器。<strong>必须实现next方法</strong>,该方法定义了迭代器如何产生下一个元素。</p>
<p>示例:自定义计数迭代器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct Counter &#123;</span><br><span class="line">    count: u32,</span><br><span class="line">&#125;</span><br><span class="line">impl Counter&#123;</span><br><span class="line">    fn new() -&gt; Counter &#123;</span><br><span class="line">        Counter&#123;count:0&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">impl Iterator for Counter&#123;</span><br><span class="line">    type Item=u32;</span><br><span class="line">    </span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;</span><br><span class="line">        self.count += 1;</span><br><span class="line">        if self.count &lt;= 5 &#123;</span><br><span class="line">            Some(self.count)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            None</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut counter = Counter::new();</span><br><span class="line">    while let Some(count)= counter.next()&#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;,count)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释:</p>
<p>Counter结构体实现了Iterator trait,其中next方法每次返回下一个计数值,直到达到5为止.</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>用自定义迭代器生成斐波那契数列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">struct Fibonacci &#123;</span><br><span class="line">    curr: u32,</span><br><span class="line">    next: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Fibonacci &#123;</span><br><span class="line">    fn new() -&gt; Self &#123;</span><br><span class="line">        Fibonacci &#123;</span><br><span class="line">            curr: 0,</span><br><span class="line">            next: 1,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn into_vec(&amp;mut self, count: usize) -&gt; Vec&lt;u64&gt; &#123;</span><br><span class="line">        let mut vec:Vec&lt;u64&gt; = Vec::new();</span><br><span class="line">        for _ in 0..count &#123;</span><br><span class="line">            vec.push(self.next().unwrap().into());</span><br><span class="line">        &#125;</span><br><span class="line">        vec</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Implement `Iterator` for `Fibonacci`.</span><br><span class="line">// The `Iterator` trait only requires a method to be defined for the `next` element.</span><br><span class="line">impl Iterator for Fibonacci &#123;</span><br><span class="line">    // We can refer to this type using Self::Item</span><br><span class="line">    type Item = u32;</span><br><span class="line">    </span><br><span class="line">    /* Implement next method */</span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;&#123;</span><br><span class="line">       if self.curr &gt; self.next &#123;</span><br><span class="line">            self.next = self.next + self.curr;</span><br><span class="line">            Some(self.curr)</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            self.curr = self.next + self.curr;</span><br><span class="line">            Some(self.next)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let  fib = Fibonacci::new();</span><br><span class="line">    </span><br><span class="line">    for number in fib.take(10) &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, number);</span><br><span class="line">    &#125;</span><br><span class="line">    let mut fib = Fibonacci::new();</span><br><span class="line">    let vec = fib.into_vec(5);</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/10/29/rust22/" data-id="cm2w1xdy3000028uy5t66aqa4" data-title="rust 学习笔记二十二 Rust中的迭代器&amp;关联类型" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust21" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/27/rust21/" class="article-date">
  <time class="dt-published" datetime="2024-10-27T10:46:54.547Z" itemprop="datePublished">2024-10-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/27/rust21/">rust 学习笔记二十一 Rust中的闭包</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）概念"><a href="#（一）概念" class="headerlink" title="（一）概念"></a>（一）概念</h3><p>闭包是一个可以捕获所在环境中的变量的匿名函数，在Rust中,闭包通过||符号定义,可以像普通函数一样调用,但与函数不同,闭包可以访问外部作用域的变量。</p>
<h3 id="（二）特点"><a href="#（二）特点" class="headerlink" title="（二）特点"></a>（二）特点</h3><ol>
<li><p>可以捕获周围作用域的变量。</p>
</li>
<li><p>支持作为参数传递给其他函数。</p>
</li>
<li><p>可以返回闭包作为函数的返回值。</p>
</li>
<li><p>类型推断:闭包通常通过类型推断来确定参数和返回值的类型。</p>
</li>
</ol>
<h3 id="三-定义"><a href="#三-定义" class="headerlink" title="(三)定义"></a>(三)定义</h3><h4 id="1-闭包的语法"><a href="#1-闭包的语法" class="headerlink" title="1.闭包的语法"></a>1.闭包的语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Let closure_name=|参数列表|-&gt;返回类型&#123;  </span><br><span class="line">    代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-简单示例"><a href="#2-简单示例" class="headerlink" title="2.简单示例"></a>2.简单示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let add_one = |x:i32|-&gt; i32&#123;x+1&#125;;</span><br><span class="line">println!(&quot;&#123;&#125;&quot;, add_one(5));//输出:6</span><br></pre></td></tr></table></figure>

<h4 id="3-省略类型的闭包"><a href="#3-省略类型的闭包" class="headerlink" title="3.省略类型的闭包"></a>3.省略类型的闭包</h4><p>Rust可以推断闭包的参数和返回值类型,因此在很多情况下可以省略类型声明。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let add_one = |x| |x|+1;</span><br><span class="line">println!(&quot;&#123;&#125;&quot;,add_one(5));//输出:6</span><br></pre></td></tr></table></figure>

<h3 id="（四）使用"><a href="#（四）使用" class="headerlink" title="（四）使用"></a>（四）使用</h3><h4 id="1-作为函数参数"><a href="#1-作为函数参数" class="headerlink" title="1.作为函数参数"></a>1.作为函数参数</h4><p>闭包可以作为函数的参数传递,从而实现更灵活的代码结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn apply_to_3&lt;F&gt;(f: F) -&gt; i32&#123;</span><br><span class="line">where</span><br><span class="line">F:Fn(i32)-&gt;i32,</span><br><span class="line">&#123;</span><br><span class="line">f(3)</span><br><span class="line">&#125;</span><br><span class="line">let double= |x| x * 2;</span><br><span class="line">println!(&quot;&#123;&#125;&quot;,apply_to_3(double));//输出:6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-捕获环境变量"><a href="#2-捕获环境变量" class="headerlink" title="2. 捕获环境变量"></a>2. 捕获环境变量</h4><p>闭包可以捕获并使用其定义所在环境中的变量</p>
<p><img src="/../assets/img/21-1.jpg" alt="图21-1" title="21-1"></p>
<p>从图中可以看出，当闭包尝试访问外界变量x时，代码正常执行，当函数尝试访问x时，报错<code>：can&#39;t capture dynamic environment in a fn item</code></p>
<h4 id="3-闭包的三种捕获方式"><a href="#3-闭包的三种捕获方式" class="headerlink" title="3. 闭包的三种捕获方式"></a>3. 闭包的三种捕获方式</h4><p>按值捕获:将环境变量的所有权移入闭包。</p>
<p>按引用捕获:通过引用捕获环境变量。</p>
<p>按可变引用捕获:通过可变引用捕获环境变量。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let mut num = 5;</span><br><span class="line">// 按引用捕获</span><br><span class="line">let add_num =  |x: i32|x + num;</span><br><span class="line">println!(&quot;&#123;&#125;&quot;,add_num(3));//输出:8</span><br><span class="line">//按可变引用捕获</span><br><span class="line">let mut change_num = |x: i32|num += x;</span><br><span class="line">change_num(5);</span><br><span class="line">println!&#123;&quot;&#123;&#125;&quot;,num&#125;;//输出:10</span><br></pre></td></tr></table></figure>

<h3 id="（四）闭包原理"><a href="#（四）闭包原理" class="headerlink" title="（四）闭包原理"></a>（四）闭包原理</h3><h4 id="1-自动实现的函数类型"><a href="#1-自动实现的函数类型" class="headerlink" title="1.自动实现的函数类型"></a>1.自动实现的函数类型</h4><p>Fn、FnMut和FnOnce是Rust提供的三种函数闭包类型,分别表示按引用捕获、按可变引用捕获和按值捕获。</p>
<h4 id="2-闭包的类型推断"><a href="#2-闭包的类型推断" class="headerlink" title="2.闭包的类型推断"></a>2.闭包的类型推断</h4><p>Rust能够根据闭包的使用上下文推断出闭包的具体类型。</p>
<p>Fn、FnMut和FnOnce是闭包在不同情况下自动实现的为trait</p>
<h4 id="3-生命周期与闭包"><a href="#3-生命周期与闭包" class="headerlink" title="3.生命周期与闭包"></a>3.生命周期与闭包</h4><p>闭包可以捕获引用,但需要保证引用的生命周期超过闭包的生命周期</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s=String::from(&quot;hello&quot;);</span><br><span class="line">let closure=|| println!(&quot;&#123;&#125;&quot;,s);</span><br><span class="line">closure();//正常运行,因为s在closure之前有效</span><br></pre></td></tr></table></figure>

<p>创建闭包时,通过闭包对环境值的使用,Rust推断出具体使用哪个trait</p>
<p>·所有的闭包都实现了FnOnce</p>
<p>·没有移动捕获变量的实现了FnMut</p>
<p>·无需可变访问频获变量的闭包实现了Fn</p>
<h3 id="（五）move关键字"><a href="#（五）move关键字" class="headerlink" title="（五）move关键字"></a>（五）move关键字</h3><p>在参数列表前使用move关键字,可以强制闭包取得它所使用的环境值的所有权，当将闭包传递给新线程以移动数据使其归新线程所有时,此技术最为有用。</p>
<p>例子</p>
<p><img src="/../assets/img/21-2.jpg" alt="图21-2" title="21-2"></p>
<p>如图所示，闭包获取了外界值x和y的所有权，之后二者都不能在打印</p>
<h3 id="六-实践"><a href="#六-实践" class="headerlink" title="(六) 实践"></a>(六) 实践</h3><p>实现PageCache结构体:<br>该结构体应缓存根据用户ID和文章ID渲染的页面。<br>你需要为该结构体实现一个get_page方法,该方法接受用户ID和文章ID,并返回演染后的页面内容。<br>如果相同的用户ID和文章ID已经渲染过,则get_page应直接返回缓存的页面,而不是重新渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">// 定义 PageCache 结构体</span><br><span class="line">struct PageCache&lt;F&gt;</span><br><span class="line">where</span><br><span class="line">    F: Fn(&amp;str, &amp;u32) -&gt; String,</span><br><span class="line">&#123;</span><br><span class="line">    render_page: F,</span><br><span class="line">    cache: HashMap&lt;(String, u32), String&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;F&gt; PageCache&lt;F&gt;</span><br><span class="line">where</span><br><span class="line">    F: Fn(&amp;str, &amp;u32) -&gt; String,</span><br><span class="line">&#123;</span><br><span class="line">    // 实现构造器方法</span><br><span class="line">    fn new(render_page: F) -&gt; Self &#123;</span><br><span class="line">        PageCache &#123;</span><br><span class="line">            render_page,</span><br><span class="line">            cache: HashMap::new(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现 get_page 方法</span><br><span class="line">    fn get_page(&amp;mut self, user_id: &amp;str, article_id: u32) -&gt; String &#123;</span><br><span class="line">        let key = (user_id.to_string(), article_id);</span><br><span class="line">        if !self.cache.contains_key(&amp;key) &#123;</span><br><span class="line">            let rendered_page = (self.render_page)(user_id, &amp;article_id);</span><br><span class="line">            self.cache.insert(key.clone(), rendered_page);</span><br><span class="line">        &#125;</span><br><span class="line">        self.cache.get(&amp;key).unwrap().to_string()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut page_cache = PageCache::new(|user_id, article_id| &#123;</span><br><span class="line">        println!(&quot;Rendering page for user &#123;&#125; and article &#123;&#125;&quot;, user_id, article_id);</span><br><span class="line">        format!(&quot;Rendered HTML content for user &#123;&#125; and article &#123;&#125;&quot;, user_id, article_id)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 第一次调用，会执行页面渲染</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, page_cache.get_page(&quot;user1&quot;, 42)); // 输出 &quot;Rendering page for user user1 and article 42&quot; 和 &quot;Rendered HTML content for user user1 and article 42&quot;</span><br><span class="line">    // 第二次调用，直接返回缓存结果</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, page_cache.get_page(&quot;user1&quot;, 42)); // 仅输出 &quot;Rendered HTML content for user user1 and article 42&quot;，不再渲染</span><br><span class="line">    // 不同用户查看同一文章，会重新渲染</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, page_cache.get_page(&quot;user2&quot;, 42)); // 输出 &quot;Rendering page for user user2 and article 42&quot; 和 &quot;Rendered HTML content for user user2 and article 42&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/10/27/rust21/" data-id="cm2rh3xgq0000y4uygydsgx14" data-title="rust 学习笔记二十一 Rust中的闭包" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust20" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/26/rust20/" class="article-date">
  <time class="dt-published" datetime="2024-10-25T16:02:23.857Z" itemprop="datePublished">2024-10-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/26/rust20/">rust 学习笔记二十 Rust中的宏</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Rust中的宏主要分为两种：</p>
<h3 id="（一）声明式宏"><a href="#（一）声明式宏" class="headerlink" title="（一）声明式宏"></a>（一）声明式宏</h3><p>声明宏(Declarative Macros),也称为”macro_rules!”,是最常见的宏类型。它们允许你通过模式匹配来生成代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    say_hello!();</span><br><span class="line">    say_hello! &#123;&#125;;</span><br><span class="line">    let var_name = say_hello![];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个简单的宏来打印消息</span><br><span class="line"></span><br><span class="line">#[macro_export]</span><br><span class="line">macro_rules! say_hello &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        println!(&quot;Hello, world!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和函数相比，声明宏在调用时候需要加！，且可以传入变参,并且从上面的代码可以发现，调用时可以用[], {}, ()三种方式</p>
<p>Rust中常见的声明式宏主要有：println format等</p>
<h3 id="（二）过程宏"><a href="#（二）过程宏" class="headerlink" title="（二）过程宏"></a>（二）过程宏</h3><p>过程宏(Procedural Macros)允许你使用函数生成代码。它们分为三种类型:</p>
<h4 id="1-派生宏"><a href="#1-派生宏" class="headerlink" title="1.派生宏"></a>1.派生宏</h4><p>常用的derive 主要用在struct和enum中</p>
<p>创建：</p>
<p>创建一个新项目，在toml中声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lib]</span><br><span class="line">proc-macro = true</span><br></pre></td></tr></table></figure>

<p>表示这是一个扩展宏, 然后再依赖中添加 quote 和 syn 用于将我们的代码与AST树之间相互转换</p>
<p>举例:</p>
<p>创建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">use proc_macro:: TokenStream;</span><br><span class="line">use quote::quote;</span><br><span class="line">#[proc_macro_derive(HelloMacro)]</span><br><span class="line">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line">    let ast=syn::parse(input).unwrap();</span><br><span class="line">    let name = &amp;ast.ident;</span><br><span class="line">    let gen = quote!&#123;</span><br><span class="line">        impl HelloMacro for #name &#123;</span><br><span class="line">            fn hello_macro()&#123;</span><br><span class="line">                println!(&quot;Hello, Macro! My name is &#123;&#125;!&quot;, stringify!(#name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    gen.into()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：导入之后通过derive衍生</p>
<h4 id="2-属性宏-Attribute-like-macro"><a href="#2-属性宏-Attribute-like-macro" class="headerlink" title="2.属性宏(Attribute-like macro)"></a>2.属性宏(Attribute-like macro)</h4><p>比如：在测试前面声明的#[test]，指定一个条件编译的配置选项:<code>#![cfg(target_arch)]</code>， 用于抑制编译器对未使用代码的警告:#![allow(dead_code)]<br>声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#[route(GET, &quot;/&quot;)]</span><br><span class="line">fn index()</span><br><span class="line">#[proc_macro_attribute]</span><br><span class="line">pub fn route(attr:TokenStream,item:TokenStream) -&gt; TokenStream &#123;</span><br></pre></td></tr></table></figure>

<h4 id="3-函数宏-Function-like-macro"><a href="#3-函数宏-Function-like-macro" class="headerlink" title="3.函数宏(Function-like macro)"></a>3.函数宏(Function-like macro)</h4><p>比如 dbg!：	assert! 和 assert_eq!等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#[proc_macro]</span><br><span class="line">pub fn sql(input: TokenStream) -&gt;TokenStream&#123;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>创建声明宏:使用 macro_rules!定义宏,通过模式匹配生成代码。<br>创建过程宏:使用过程宏函数<code>(#[proc_macro])</code>、派生宏<code>(#[proc_macro_derive])</code>和属性宏<code>(#[proc_macro_attribute])</code>生成代码。</p>
<p>宏的应用场景<br>1.减少重复代码:通过宏生成重复的代码。<br>2.编译期计算:在<strong>编译期</strong>进行计算并生成代码,提高运行时性能。<br>3.DSL(领域特定语言):使用宏定义领域特定语言,提高代码的表达力和可读性。</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>使用通过<code>macro_rules!</code>实现对应的macro</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//定义宏</span><br><span class="line">macro_rules! repeat &#123;</span><br><span class="line">    ($string:expr, $n:expr) =&gt; &#123;&#123;</span><br><span class="line">        let mut result = String::new();</span><br><span class="line">        for _ in 0..$n &#123;</span><br><span class="line">            result.push_str($string);</span><br><span class="line">        &#125;</span><br><span class="line">        result</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">macro_rules! sum &#123;</span><br><span class="line">    ($($val:expr),+) =&gt; &#123;&#123;</span><br><span class="line">        let mut total = 0;</span><br><span class="line">        $(</span><br><span class="line">            total += $val;</span><br><span class="line">        )+</span><br><span class="line">        total</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">macro_rules! max_value &#123;</span><br><span class="line"></span><br><span class="line">    ($x:expr) =&gt; &#123; $x &#125;;</span><br><span class="line"></span><br><span class="line">    ($x:expr, $($rest:expr),+) =&gt; &#123;</span><br><span class="line">        if $x &gt; max_value!($($rest),+) &#123;</span><br><span class="line">            $x</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            max_value!($($rest),+)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // 使用宏</span><br><span class="line">    assert_eq!(repeat!(&quot;x&quot;, 3), &quot;xxx&quot;);</span><br><span class="line">    assert_eq!(sum!(1, 2, 3, 4, 5), 15);</span><br><span class="line">    assert_eq!(max_value!(1, 8, 9), 9);</span><br><span class="line">    </span><br><span class="line">    println!(&quot;All tests passed!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/10/26/rust20/" data-id="cm2oxbt5z00003guyeo4qappl" data-title="rust 学习笔记二十 Rust中的宏" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust19" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/22/rust19/" class="article-date">
  <time class="dt-published" datetime="2024-10-22T15:33:34.843Z" itemprop="datePublished">2024-10-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/22/rust19/">rust 学习笔记十九 Rust中的trait</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）概念"><a href="#（一）概念" class="headerlink" title="（一）概念"></a>（一）概念</h3><p>trait定义了某个特定类型拥有可能与其他类型共享的功能， 类似于其他语言中的常被称为接口(interfaces)的功能,!虽然有一些不同。</p>
<h3 id="（二）实现"><a href="#（二）实现" class="headerlink" title="（二）实现"></a>（二）实现</h3><p>使用trait关键字来声明一个特征， Summary是特征名， 在大括号中定义了该特征的所有方法， 只定义特征方法的签名,而不进行实现,此时方法签名结尾是;而不是一个{}。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pub trait Summary&#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt;String;</span><br><span class="line">&#125;</span><br><span class="line">为类型实现特征</span><br><span class="line">pub trait Summary&#123;</span><br><span class="line">fn summarize(&amp;self) -&gt;String;</span><br><span class="line">&#125;</span><br><span class="line">pub struct Post&#123;</span><br><span class="line">    pub title:String,//标题</span><br><span class="line">    pub author:String,//作者</span><br><span class="line">    pub content:String,//内容</span><br><span class="line">&#125;</span><br><span class="line">impl Summary for Post&#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String&#123;</span><br><span class="line">        format!(&quot;文章&#123;&#125;,作者是&#123;&#125;&quot;,self.title,self.author)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">pub struct Weibo&#123;</span><br><span class="line">    pub username:String,</span><br><span class="line">    pub content: String</span><br><span class="line">&#125;</span><br><span class="line">impl Summary for Weibo &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt;String&#123;</span><br><span class="line">        format!(&quot;&#123;&#125;发表了微博&#123;&#125;&quot;,self.username,self.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（三）特征定义与实现的位置-孤儿规则"><a href="#（三）特征定义与实现的位置-孤儿规则" class="headerlink" title="（三）特征定义与实现的位置(孤儿规则)"></a>（三）特征定义与实现的位置(孤儿规则)</h3><p>如果你想要为结构体 A 实现特征 T,那么A或者 T 至少有一个是在当前作用域中定义的!（即不要为标准库中的类型实现标准库中的特征）</p>
<p>Trait中也可以直接对函数进行实现，这种情况下在为结构体实现trait时候就可以跳过已实现的方法，也可以对其进行重载</p>
<h3 id="（四）带泛型的trait"><a href="#（四）带泛型的trait" class="headerlink" title="（四）带泛型的trait"></a>（四）带泛型的trait</h3><p>在具体方法调用的时候,必须加以类型标注以明确使用的:是哪一个具体的实现</p>
<p>可以对同一个目标类型,多次impl此trait,每次提供不同的泛型参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">trait Converter&lt;T&gt; &#123;</span><br><span class="line">fn convert(&amp;self) -&gt; T;</span><br><span class="line">&#125;</span><br><span class="line">struct MyInt(i32);</span><br><span class="line">impl Converter&lt;String&gt;for MyInt &#123;</span><br><span class="line">    fn convert(&amp;self) -&gt;String &#123;</span><br><span class="line">        self.0.to_string()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">impl Converter&lt;f32&gt; for MyInt &#123;</span><br><span class="line">    fn convert(&amp;self) -&gt; f32 &#123;</span><br><span class="line">        self.0 as f32</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let my_int = MyInt(42);</span><br><span class="line">    let output:String=my_int.convert();</span><br><span class="line">    println!(&quot;outputis:&#123;&#125;&quot;,output);</span><br><span class="line">    let output:f32 = my_int.convert();</span><br><span class="line">    println!(&quot;output is:&#123;&#125;&quot;, output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，由于编译器不知道你需要的是针对哪种类型的同名方法convert，所以需要在变量output处显式的声明一下类型</p>
<h3 id="（五）关联类型"><a href="#（五）关联类型" class="headerlink" title="（五）关联类型"></a>（五）关联类型</h3><p>关联类型是trait定义中的类型占位符。定义的时候,并不定义它的具体的类型是什么。在impl这个trait的时候,才为这个关联类型赋予确定的类型。也就是说,在实现的时候,才知道它的具体类型是什么。<br>·关联类型方式<strong>只允许对目标类型实现一次</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">trait Converter&#123;</span><br><span class="line">    type Output;</span><br><span class="line">    fn convert(&amp;self) -&gt;Self::Output;</span><br><span class="line">&#125;</span><br><span class="line">impl Converter for MyInt&#123;</span><br><span class="line">    type Output=String;</span><br><span class="line">    fn convert(&amp;self) -&gt;Self::Output &#123;</span><br><span class="line">        self.0.to_string()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（六）默认泛型类型参数"><a href="#（六）默认泛型类型参数" class="headerlink" title="（六）默认泛型类型参数"></a>（六）默认泛型类型参数</h3><p>实现Add trait(也是一种关联类型的trait)时不指定Rhs的具体类型,Rhs的类型将是默认的Self类型,也就是在其上实现Add的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">trait Add&lt;Rhs=Self&gt; &#123;</span><br><span class="line">    type Output;</span><br><span class="line">    fn add(self,rhs:Rhs)-&gt;Self::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以如果需要实现两种不同类型相加，需要在实现trait时声明另一种加数的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Millimeters(u32);</span><br><span class="line"></span><br><span class="line">struct Meters(u32);</span><br><span class="line"></span><br><span class="line">impl Add&lt;Meters&gt; for Millimeters &#123;</span><br><span class="line">    type Output = Millimeters;</span><br><span class="line"></span><br><span class="line">    fn add(self, rhs: Meters) -&gt; Millimeters &#123;</span><br><span class="line">        Millimeters(self.0 + rhs.0 * 1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（七）使用特征作为函数参数"><a href="#（七）使用特征作为函数参数" class="headerlink" title="（七）使用特征作为函数参数"></a>（七）使用特征作为函数参数</h3><h4 id="1-impl-Trait语法"><a href="#1-impl-Trait语法" class="headerlink" title="1.impl Trait语法"></a>1.impl Trait语法</h4><p>你可以使用任何实现了Summary特征的类型作为该函数的参数，除了单个约束条件,我们还可以通过+语法指定多个约束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pub fn notify(item: &amp;impl Summary) &#123;</span><br><span class="line">    println!(&quot;Brenking news!&#123;&#125;&quot;, item.summarize());</span><br><span class="line">&#125;</span><br><span class="line">pub fn notify(item: &amp;(impl Summary + Display)) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Trait-Bound语法"><a href="#2-Trait-Bound语法" class="headerlink" title="2.Trait Bound语法"></a>2.Trait Bound语法</h4><p>impl Trait 适用于短小的例子,它trait bound语法糖, 更长的trait bound则适用于更复杂的场景,除了单个约束条件,我们还可以通过+语法指定多个约束条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pub fn notify&lt;T:Summary&gt;(ikem:&amp;T)&#123;</span><br><span class="line">println!(&quot;Breaking news!&#123;&#125;&quot;, item.summarize());</span><br><span class="line">&#125;</span><br><span class="line">pub fn notify&lt;T:Summary + Display&gt;(item:&amp;T)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>也可以改为如下写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn notify&lt;T, U&gt;(item1: &amp;T, item2: &amp;U) </span><br><span class="line">where T:Summary + Display,</span><br><span class="line">      U:Summary + Display + Debug,</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将泛型的类型声明写在后面增强代码易读性</p>
<h3 id="（八）实现方法"><a href="#（八）实现方法" class="headerlink" title="（八）实现方法"></a>（八）实现方法</h3><p>可以有条件地只为那些实现了特定trait的类型实现方法，只有那些为T类型实现了Partialord trait(来允许比较)和Display trait(来启用打印)的Pair<T>才会实现cmp_display 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">use std::fmt::Display;</span><br><span class="line">struct Pair&lt;T&gt;&#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T</span><br><span class="line">&#125;</span><br><span class="line">impl&lt;T&gt; Pair&lt;T&gt;&#123;</span><br><span class="line">    fn new(x:T,y:T)-&gt;Self&#123;</span><br><span class="line">        Self&#123;x,y&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">impl&lt;T:Display + Partialord&gt; Pair&lt;T&gt;&#123;</span><br><span class="line">    fn cmp_display(&amp;self)&#123;</span><br><span class="line">        if self.x&gt;=self.y&#123;</span><br><span class="line">        println!(&quot;The largest member is x=&#123;&#125;&quot;,self.x);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        println!(&quot;The largest member is y=&#123;&#125;&quot;,self.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（九）impl-Trait-语法"><a href="#（九）impl-Trait-语法" class="headerlink" title="（九）impl Trait 语法"></a>（九）impl Trait 语法</h3><p>在返回值中使用impl Trait语法,来返回实现了某个trait的类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn returns_summarizable() -&gt; impl Summary &#123;</span><br><span class="line">    Tweet&#123;</span><br><span class="line">        username:String::from(&quot;horse_ebooks&quot;),</span><br><span class="line">        content:String::from(</span><br><span class="line">        &quot;of course, as you probably already know, people&quot;,</span><br><span class="line">        ),</span><br><span class="line">        reply: false,</span><br><span class="line">        retweet: false,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果根据不同情况返回值是实现了该特征的不同结构，直接在返回类型写impl trait会报错，需要使用impl<code>&lt;dyn trait&gt;</code>的格式来运行时判断返回类型</p>
<h3 id="trait-实践"><a href="#trait-实践" class="headerlink" title="trait 实践"></a>trait 实践</h3><p>应用了<strong>关联类型</strong>和<strong>动态分发</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">use std::fmt::Display;</span><br><span class="line"></span><br><span class="line">trait Item&lt;T = String&gt;&#123;</span><br><span class="line">    type Output:Display;</span><br><span class="line">    fn summarize(&amp;self) -&gt; Self::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Apple&#123;</span><br><span class="line">    name: String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Item for Apple&#123;</span><br><span class="line">    type Output = String;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String&#123;</span><br><span class="line">        self.name.to_string()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Weibo&#123;</span><br><span class="line">    author:String,</span><br><span class="line">    content:String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Item for Weibo&#123;</span><br><span class="line">    type Output = String;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String&#123;</span><br><span class="line">        format!(&quot;@&#123;&#125;:&#123;&#125;&quot;,self.author,self.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct Container&#123;</span><br><span class="line">    items:Vec&lt;Box&lt;dyn Item&lt;Output = String&gt;&gt;&gt; ,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Container&#123;</span><br><span class="line">    pub fn iterator(&amp;self)&#123;</span><br><span class="line">        for item in self.items.iter()&#123;</span><br><span class="line">            println!(&quot;&#123;&#125;&quot;,item.summarize());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let apple=Apple &#123;</span><br><span class="line">        name:&quot;Apple&quot;.to_string(),</span><br><span class="line">    &#125;;</span><br><span class="line">    let w=Weibo&#123;</span><br><span class="line">        author:&quot;weibo&quot;.to_string(),</span><br><span class="line">        content:&quot;hello&quot;.to_string(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    let container = Container &#123;</span><br><span class="line">        items:vec![Box::new(apple), Box::new(w)],</span><br><span class="line">    &#125;;</span><br><span class="line">    container.iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/10/22/rust19/" data-id="cm2klvmdr0000l0uy2n369t0y" data-title="rust 学习笔记十九 Rust中的trait" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust18" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/15/rust18/" class="article-date">
  <time class="dt-published" datetime="2024-10-15T13:45:07.177Z" itemprop="datePublished">2024-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/15/rust18/">rust 学习笔记十八 Rust中的生命周期</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>生命周期在rust中用于<strong>内存安全，帮助编译器处理悬垂指针的问题</strong></p>
<h3 id="（一）创建"><a href="#（一）创建" class="headerlink" title="（一）	创建"></a>（一）	创建</h3><p>在Rust中,生命周期主要通过生命周期注解来创建和使用。生命周期注解是一种显式声明引用有效时间的方式,通常用’a、’b这样的符号表示。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;</span><br><span class="line">    if x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        У</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中,longest函数接受两个字符串切片参数,并过返回其中一个更长的字符串切片。’a生命周期注解表明<strong>返回的生命周期与输入参数的生命周期相同</strong></p>
<h3 id="（二）分类"><a href="#（二）分类" class="headerlink" title="（二）	分类"></a>（二）	分类</h3><h4 id="1-fn"><a href="#1-fn" class="headerlink" title="1.fn:"></a>1.fn:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn example&lt;&#x27;a&gt;(input: &amp;&#x27;a str)-&gt; &amp;&#x27;a str&#123;</span><br><span class="line">    input</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-struct"><a href="#2-struct" class="headerlink" title="2.struct"></a>2.struct</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct: struct Example&lt;&#x27;a&gt; &#123;</span><br><span class="line">    part: &amp;&#x27;a str,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-enum"><a href="#3-enum" class="headerlink" title="3.enum"></a>3.enum</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum: enum StringOption&lt;&#x27;a&gt; &#123;</span><br><span class="line">    Some(&amp;&#x27;a str),</span><br><span class="line">    None</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（三）使用场景"><a href="#（三）使用场景" class="headerlink" title="（三）	使用场景"></a>（三）	使用场景</h3><p>在rust开发中，什么时候需要显式的添加生命周期呢，理论上，当牵涉到值的引用传递时，我们都需要声明生命周期，因为其他类型的数据，rust能检测到数据的存活周期，能自动识别什么时候应该释放这些数据<br>但也不是所有包含了引用值传递的情况修需要声明生命周期：</p>
<p>看下面这个例子：</p>
<p><img src="/../assets/img/18-1.jpg" alt="图18-1" title="18-1"></p>
<p>在这种情况下，没有声明，但是也没有任何报错,实际上，在上面代码编译过程中，rust自动帮我们完成了这部分工作，那么什么情况下rust会自动帮我们完成这部分工作呢：</p>
<h4 id="生命周期消除-LifetimeElision"><a href="#生命周期消除-LifetimeElision" class="headerlink" title="生命周期消除(LifetimeElision)"></a>生命周期消除(LifetimeElision)</h4><p>rust编译器自动推理,无需手动重复添加</p>
<p>1.每个引用参数都有自己的生命周期参数。所以当参数为单个引用的时候不会报错：</p>
<p><img src="/../assets/img/18-2.jpg" alt="图18-2" title="18-2"></p>
<p>2.如果只有一个输入引用参数,那么它的生命周期会被赋予所有输出引用。</p>
<p><img src="/../assets/img/18-3.jpg" alt="图18-3" title="18-3"></p>
<p>因为函数执行完后所有变量都将被drop,所以唯一可以作为参考的就是入参的生命周期了</p>
<p>3.如果有多个输入生命周期参数,但其中一个是&amp;self或&amp;mut self,那么 self的生命周期会被赋予所有输出引用。</p>
<h4 id="特殊生命周期标注"><a href="#特殊生命周期标注" class="headerlink" title="特殊生命周期标注"></a>特殊生命周期标注</h4><p>‘static生命周期表示整个程序运行期间都有效的生命周期。这通常用于全局变量或字符串字面量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s: &amp;&#x27;static str = &quot;hello&quot;;</span><br><span class="line">const SOME_COORDINATE: (i32, i32) = (7, 4);</span><br><span class="line">let static_reference: &amp;&#x27;static (i32, i32) = &amp;SOME_COORDINATE;</span><br></pre></td></tr></table></figure>

<p>如果在一个impl中，并不关注每个函数中的生命周期（默认和结构体实例的生命周期相同），则可以在最开始声明时用一个占位符代替,</p>
<p>如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Counter&lt;&#x27;a&gt; &#123;</span><br><span class="line">    counter: &amp;&#x27;a mut i32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl  Counter&lt;&#x27;_&gt; &#123;</span><br><span class="line">    fn increment(&amp;mut self) &#123;</span><br><span class="line">        *self.counter += 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生命周期约束"><a href="#生命周期约束" class="headerlink" title="生命周期约束"></a>生命周期约束</h4><p>生命周期注解可以用来约束多个引用之间的关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn example&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;b str) -&gt; &amp;&#x27;a str</span><br><span class="line">where</span><br><span class="line">    &#x27;b:&#x27;a,</span><br><span class="line">&#123;</span><br><span class="line">    X</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中,’b:’a表示生命周期 ‘b必须不短于a</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/10/15/rust18/" data-id="cm2ai0wj50000o4uy31ok0g0p" data-title="rust 学习笔记十八 Rust中的生命周期" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust17" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/13/rust17/" class="article-date">
  <time class="dt-published" datetime="2024-10-13T09:03:48.873Z" itemprop="datePublished">2024-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/13/rust17/">rust 学习笔记十七 Rust 泛型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）概念"><a href="#（一）概念" class="headerlink" title="（一）	概念"></a>（一）	概念</h3><p>当使用泛型定义函数时,本来在函数签名中指定参数和返回值的类型的地方,会改用泛型来表示。采用这种技术,使得代码适应性更强,从而为函数的调用者提供更多的功能,同时也避免了代码的重复。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn add&lt;T&gt;(a:T,b:T) -&gt;T &#123;</span><br><span class="line">    a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的T就是泛型参数<br>不是所有T类型都能进行相加操作,因此我们需要用std::ops::Add&lt;Output&#x3D;T&gt;对T进行限制:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn add&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a: T, b: T) -&gt; T&#123;</span><br><span class="line">    a+b</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    println!(&quot;add i8:&#123;&#125;&quot;, add(2i8, 3i8));</span><br><span class="line">    println!(&quot;add i32:&#123;&#125;&quot;, add(20, 30));</span><br><span class="line">    println!(&quot;add f64:&#123;&#125;&quot;, add(1.32, 1.32));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，比较大小的泛型函数也需要声明，传入的T都是支持大小符号比较的</p>
<h3 id="（二）结构体定义中的泛型"><a href="#（二）结构体定义中的泛型" class="headerlink" title="（二）结构体定义中的泛型"></a>（二）结构体定义中的泛型</h3><p>声明结构体名称后面的<strong>尖括号中声明泛型参数的名称</strong>,结构体定义中可以指定具体数据类型的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Point &lt;T&gt;&#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let integer=Point&#123;x:5,y:10&#125;;</span><br><span class="line">    let float=Point&#123;x:1.0,y:4.0&#125;;</span><br><span class="line">    let wont_work=Point&#123;x:5,y:4&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（三）枚举中使用泛型"><a href="#（三）枚举中使用泛型" class="headerlink" title="（三）枚举中使用泛型"></a>（三）枚举中使用泛型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> enum Option&lt;T&gt; &#123;</span><br><span class="line">    Some(T),</span><br><span class="line">    None</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Result&lt;T, E&gt; &#123;</span><br><span class="line">    Ok(T),</span><br><span class="line">    Err(E)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="（四）方法中使用泛型"><a href="#（四）方法中使用泛型" class="headerlink" title="（四）方法中使用泛型"></a>（四）方法中使用泛型</h3><p><img src="/../assets/img/17-1.jpg" alt="图17-1" title="17-1"></p>
<p>如图所示：两个结构体实例的参数类型完全不相同，通过泛型完成了二者参数的组合，形成了另一类新的结构体实例</p>
<h3 id="（五）const泛型-Rust1-51版本引入的重要特性"><a href="#（五）const泛型-Rust1-51版本引入的重要特性" class="headerlink" title="（五）	const泛型(Rust1.51版本引入的重要特性)"></a>（五）	const泛型(Rust1.51版本引入的重要特性)</h3><p>[i32;3]和[i32;2]是两个完全不同的类型,因此无法用同一个函数调用。</p>
<p><img src="/../assets/img/17-3.jpg" alt="图17-3" title="17-3"></p>
<p>如图所示：当规定了传入的数组长度时，就必须传入固定长度的数组，否则会报错，如果我们希望争对不同长度的数组复用这个函数时，可以改为泛型传入，并将参数改为引用</p>
<p><img src="/../assets/img/17-2.jpg" alt="图17-2" title="17-2"></p>
<p>也可以不传入引用，增加一个表示长度的参数：</p>
<p>此时需要用到const泛型，此处定义的N限制了传入必须是已经确定长度的数组</p>
<p><img src="/../assets/img/17-4.jpg" alt="图17-4" title="17-4"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/10/13/rust17/" data-id="cm27d26zx000024uyggri8lkl" data-title="rust 学习笔记十七 Rust 泛型" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust16" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/12/rust16/" class="article-date">
  <time class="dt-published" datetime="2024-10-11T16:37:11.423Z" itemprop="datePublished">2024-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/12/rust16/">rust 学习笔记十六 Rust 智能指针</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）概念"><a href="#（一）概念" class="headerlink" title="（一）	概念"></a>（一）	概念</h3><p>智能指针(Smart Pointers)是一类数据结构,它不仅包含一个指针,还附带一些额外的元数据和功能。与普通指针不同,智能指针在Rust中实现了<strong>Deref和Drop两个trait</strong>,这使得它们可以像指针一样解引用并在离开作用域时自动清理资源</p>
<h3 id="（二）作用"><a href="#（二）作用" class="headerlink" title="（二）	作用"></a>（二）	作用</h3><h4 id="1-资源管理"><a href="#1-资源管理" class="headerlink" title="1 资源管理"></a>1 资源管理</h4><p>自动管理资源的分配和释放,避免内存泄漏</p>
<h4 id="2-所有权与借用"><a href="#2-所有权与借用" class="headerlink" title="2 所有权与借用"></a>2 所有权与借用</h4><p>Rust的所有权系统通过智能指针来确保内存安全,避免数据竞争和悬垂指针</p>
<h4 id="3-复杂数据结构"><a href="#3-复杂数据结构" class="headerlink" title="3 复杂数据结构"></a>3 复杂数据结构</h4><p>通过智能指针可以构建复杂的数据结构,如递归结构、共享数据等</p>
<h3 id="（三）特性"><a href="#（三）特性" class="headerlink" title="（三）	特性"></a>（三）	特性</h3><h4 id="1-Deref-Trait"><a href="#1-Deref-Trait" class="headerlink" title="1 Deref Trait"></a>1 Deref Trait</h4><p>实现了Dereftrait的类型可以像常规引用一样使用*运算符解引用</p>
<p>例如:Box<T>实现了Deref,所以可以通过*解引用获取其内部数据</p>
<h4 id="2-Drop-Trait"><a href="#2-Drop-Trait" class="headerlink" title="2 Drop Trait"></a>2 Drop Trait</h4><p>实现了Droptrait的类型在离开作用域时会自动调用其drop方法,用于释放资源</p>
<p>例如:Box<T>在超出作用域时会自动释放堆内存</p>
<h3 id="（四）Box"><a href="#（四）Box" class="headerlink" title="（四）	Box"></a>（四）	Box<T></h3><h4 id="1-概念："><a href="#1-概念：" class="headerlink" title="1. 概念："></a>1. 概念：</h4><p>Box<T>将类型T的值分配在堆上,而不是栈上（堆容量大得多，大型数据放在栈上会存在栈溢出）。当Box被销毁时,堆上的数据也会被销毁。</p>
<h4 id="2-底层实现"><a href="#2-底层实现" class="headerlink" title="2.	底层实现"></a>2.	底层实现</h4><h5 id="a-Box的底层原理"><a href="#a-Box的底层原理" class="headerlink" title="a. Box的底层原理"></a>a. Box的底层原理</h5><p>Box<T>指针实际上是一个智能指针,内部包含一个指向堆上分配内存的裸指针, 当Box<T>被销毁时,其Drop trait会被调用,释放堆上的内存。</p>
<h5 id="b-内存分配"><a href="#b-内存分配" class="headerlink" title="b. 内存分配"></a>b. 内存分配</h5><p>Rust使用系统的全局分配器(如malloc和free)来管理堆内存, Box::new分配内存,Drop释放内存。</p>
<h5 id="c-安全性"><a href="#c-安全性" class="headerlink" title="c. 安全性"></a>c. 安全性</h5><p>Rust的所有权系统确保Box<T>的内存安全。所有权转移多时,堆内存的生命周期也会随之变化。</p>
<h4 id="3-Box的应用场景"><a href="#3-Box的应用场景" class="headerlink" title="3.	 Box的应用场景"></a>3.	 Box的应用场景</h4><h6 id="a-堆分配"><a href="#a-堆分配" class="headerlink" title="a.堆分配"></a>a.堆分配</h6><p>Box最常见的用途是将数据分配在堆上,而不是栈上。这在处理较大数据结构或数据结构的大小在编译时不确定时尤为重要。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let b=Box::new(5);</span><br><span class="line">    println!(&quot;b=&#123;&#125;&quot;,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="b-动态大小类型-DST"><a href="#b-动态大小类型-DST" class="headerlink" title="b. 动态大小类型(DST)"></a>b. 动态大小类型(DST)</h5><p>Box允许处理动态大小类型,如str和[T]</p>
<p><img src="/../assets/img/16-1.jpg" alt="图16-1" title="16-1"></p>
<h5 id="c-递归数据结构"><a href="#c-递归数据结构" class="headerlink" title="c. 递归数据结构"></a>c. 递归数据结构</h5><p>递归数据结构需要指针类型来引用自身,而Box提供了这一功能。</p>
<p><img src="/../assets/img/16-2.jpg" alt="图16-2" title="16-2"></p>
<h5 id="d-类型擦除"><a href="#d-类型擦除" class="headerlink" title="d. 类型擦除"></a>d. 类型擦除</h5><p>Box<dyn Trait>用于类型擦除,允许<strong>在运行时决定类型</strong></p>
<p><img src="/../assets/img/16-3.jpg" alt="图16-3" title="16-3"></p>
<p>如图所示，动态数组中包含了Dog和Cat两种结构的智能指针，他们都实现了trait中的方法，只需要将vec声明为<dyn trait>即可（dyn 关键字用于表示动态分发的 trait）</p>
<h5 id="e-内存管理和性能优化"><a href="#e-内存管理和性能优化" class="headerlink" title="e. 内存管理和性能优化"></a>e. 内存管理和性能优化</h5><p>通过使用Box,可以控制内存的分配和释放,从而优化性能能和内存使用。例如,将大型数据结构放在堆上,而不是栈上,可以减少栈的使用量,从而避免栈溢出。</p>
<p>声明到堆上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let start = Instant::now(); </span><br><span class="line"></span><br><span class="line">let large_array = Box::new([0u8; 1_000_000]);</span><br><span class="line"></span><br><span class="line">let duration = start.elapsed();</span><br></pre></td></tr></table></figure>
<p>打印duration得到：363.2µs,</p>
<p>而直接声明到栈上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let large_array = [0u8; 1_000_000]);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let start = Instant::now(); </span><br><span class="line"></span><br><span class="line">let large_array = [0u8; 1_000_000];</span><br><span class="line"></span><br><span class="line">let duration = start.elapsed();</span><br></pre></td></tr></table></figure>
<p>打印duration得到：30µs</p>
<p>由此可见，创建一个堆上的 Box 数组（large_array）比直接在栈上创建数组（large_array2）要花费更多的时间，这是因为 Box::new 涉及到堆内存分配</p>
<h4 id="4-Box的优缺点"><a href="#4-Box的优缺点" class="headerlink" title="4.	Box的优缺点"></a>4.	Box的优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>提供堆内存分配,支持复杂数据结构，与Rust的所有权系统完美集成,确保<strong>内存安全</strong>。动态分配对象,实现类型擦除。</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>需要<strong>堆内存分配和释放,可能带来性能开销</strong>。不适合需要频繁分配和释放的场景。</p>
<h3 id="（五）Drop、Deref和DerefMut"><a href="#（五）Drop、Deref和DerefMut" class="headerlink" title="（五）Drop、Deref和DerefMut"></a>（五）Drop、Deref和DerefMut</h3><h4 id="1-Drop-Trait"><a href="#1-Drop-Trait" class="headerlink" title="1. Drop Trait"></a>1. Drop Trait</h4><p>Dropt rait定义了当一个值离开作用域时应该执行的操作。</p>
<p>例如:Box<T>在超出作用域时会自动调用其Drop trait,释放堆上的内存。</p>
<p>Drop trait用于自定义当值离开作用域时执行的代码,通常用于释放资源(例如内存、文件句柄、网络连接等)。</p>
<p><img src="/../assets/img/16-4.jpg" alt="图16-4" title="16-4"></p>
<p>如图所示，在两个变量依次离开当前作用域时，drop函数均被自动触发</p>
<h4 id="2-Deref-Trait"><a href="#2-Deref-Trait" class="headerlink" title="2. Deref Trait"></a>2. Deref Trait</h4><p>Deref trait定义了如何将一个类型转换为引用。</p>
<p>例如:Box<T>实现了Deref,所以可以通过*运算符解引用获取其内部数据。</p>
<p>Deref trait定义了一个deref方法,该方法返回指向目标类型的引用。</p>
<p><img src="/../assets/img/16-5.jpg" alt="图16-5" title="16-5"></p>
<h4 id="3-DerefMut-Trait"><a href="#3-DerefMut-Trait" class="headerlink" title="3. DerefMut Trait"></a>3. DerefMut Trait</h4><p>与Deref类似,Deref Mut用于重载可变解引用运算符(*),允许对自定义类型进行可变解引用。</p>
<p>将变量声明为mut后，为其实现Deref</p>
<p>特性中的deref方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">impl&lt;T&gt; Deref for MyBox&lt;T&gt; &#123;</span><br><span class="line">    type Target = T;</span><br><span class="line">    fn deref(&amp;self)-&gt;&amp;T &#123;</span><br><span class="line">        println!(&quot;deref called&quot;);</span><br><span class="line">        &amp;self.0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即可通过*获取并修改变量</p>
<h3 id="六-Rc"><a href="#六-Rc" class="headerlink" title="(六) Rc"></a>(六) Rc<T></h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>Rc是Reference Counted的缩写</p>
<p>允许<strong>多所有者的共享所有权</strong>模型</p>
<p>使用Box<T>定义conslist的例子。这一次,我们希望创建两个共享第三个列表所有权的列表,其概念将会看起来如下图所示</p>
<p><img src="/../assets/img/16-7.jpg" alt="图16-6" title="16-6"></p>
<h4 id="2-实践"><a href="#2-实践" class="headerlink" title="2.实践"></a>2.实践</h4><p>首先看下面代码：</p>
<p><img src="/../assets/img/16-8.jpg" alt="图16-7" title="16-7"></p>
<p>当用Box实现这个递归的结构时，发现报错当a元素的所有权已经在第一次传入Box时发生了移动，所以这时候我们可以使用引用而非Box的方式来创建递归List</p>
<p><img src="/../assets/img/16-9.jpg" alt="图16-8" title="16-8"></p>
<p>需要在声明struct结构时声明生命周期，表示所有被引用的List生命周期都和引用者相同</p>
<p>也可以通过Rc<T>智能指针实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">enum List&#123;</span><br><span class="line">    Cons(i32, Rc&lt;List&gt;),</span><br><span class="line">    Nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use std::rc::Rc;</span><br><span class="line"></span><br><span class="line">use crate::List::*;</span><br><span class="line"></span><br><span class="line">fn study() &#123;</span><br><span class="line">    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));</span><br><span class="line">    let b = Cons(3, Rc::clone(&amp;a)); </span><br><span class="line">    let c = Cons(4, Rc::clone(&amp;a));</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;,a);</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;,b);</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在b和c中，Rc智能指针实现了引用的共享,如图所示，在三行声明之后分别打印对a的引用个数，依次增加一</p>
<p><img src="/../assets/img/16-9.jpg" alt="图16-9" title="16-9"></p>
<h3 id="七-Refcell"><a href="#七-Refcell" class="headerlink" title="(七) Refcell"></a>(七) Refcell<T></h3><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1.概念"></a>1.概念</h4><p>有时候我们需要一个可以在运行时改变其值的变量，即使这个变量本身被声明为不可变的, RefCell<T>是Rust标准库中的一个智能指针类型,它提供了内部可变性,即允许<strong>在不可变引用的情况下修改数据</strong>。这种特性使得你可以在编译时保证安全的情况下动态地借用和修改数据。</p>
<h4 id="2-主要特征"><a href="#2-主要特征" class="headerlink" title="2.主要特征"></a>2.主要特征</h4><h5 id="a-内部可变性"><a href="#a-内部可变性" class="headerlink" title="a. 内部可变性:"></a>a. 内部可变性:</h5><p>RefCell<T>允许你在其拥有的T内部进行修改,即使RefCell本身是不可变的。这是通过在运行时进行借用检查实现的。</p>
<h5 id="b-运行时借用检查"><a href="#b-运行时借用检查" class="headerlink" title="b.运行时借用检查:"></a>b.运行时借用检查:</h5><p>RefCell 使用动态借用检查,确保在运行时遵循Rust的借用规则。即在任何时刻,RefCell只能有一个可变借用或多个不可变借用,<strong>但不能同时存在。</strong></p>
<h4 id="3-borrow和borrow-mut方法"><a href="#3-borrow和borrow-mut方法" class="headerlink" title="3.borrow和borrow mut方法:"></a>3.borrow和borrow mut方法:</h4><p>RefCell提供了两个方法来获取对内部数据的借用:</p>
<h5 id="a-borrow"><a href="#a-borrow" class="headerlink" title="a.borrow()"></a>a.borrow()</h5><p>获取不可变借用(Ref<T>),可以同时有多个个.</p>
<h5 id="b-borrow-mut"><a href="#b-borrow-mut" class="headerlink" title="b.borrow_mut()"></a>b.borrow_mut()</h5><p>获取可变借用(RefMut<T>),在同一时间只能有一个.</p>
<h4 id="4-关键点"><a href="#4-关键点" class="headerlink" title="4.关键点"></a>4.关键点</h4><h5 id="a-借用规则"><a href="#a-借用规则" class="headerlink" title="a.借用规则:"></a>a.借用规则:</h5><p>RefCell在运行时检查借用规则,以防止数据竞争和未定义行为。编详器不进行这些检查,而是依赖RefCell在运行时进行。</p>
<h5 id="b-运行时开销"><a href="#b-运行时开销" class="headerlink" title="b.运行时开销:"></a>b.运行时开销:</h5><p>因为RefCell 需要在运行时检查借用规则,所以它会引入一一定的性能开销。这在需要在编译时确定所有借用规则的场景中不可替代。</p>
<h5 id="c-错误处理"><a href="#c-错误处理" class="headerlink" title="c.错误处理:"></a>c.错误处理:</h5><p>如果违反了借用规则(例如,尝试同时获取多个可变借用),RefCell会在运行时引发panic</p>
<h5 id="d-使用场景"><a href="#d-使用场景" class="headerlink" title="d.使用场景"></a>d.使用场景</h5><p>数据结构:</p>
<p>在需要可变性但又受限于Rust的所有权系统时,RefCell允许在数数据结构中使用内部可变性。例如,实现需要共享但修改的数据结构(如图、树)</p>
<p>单线程环境:</p>
<p>RefCell主要用于单线程环境。如果你需要在多线程环境中处理内部可变性,应该使用Mutex或RwLock这类类型。</p>
<p><img src="/../assets/img/16-10.jpg" alt="图16-10" title="16-10"></p>
<h3 id="八-Weak"><a href="#八-Weak" class="headerlink" title="(八) Weak"></a>(八) Weak<T></h3><p>首先看下<strong>引用循环与内存泄漏</strong>的问题</p>
<p>在Rust中,引用计数(RC<T>)和原子引用计数(Arc<T>)可以让多个所有者共享同一个数据。然而,这种共享机制如果不当使用,可能会导致引用循环(reference cycle),从而造成内存泄漏。</p>
<p>如下所示：当first与second之间互相引用时，直接打印引用数量发现两者的强引用个数都是2，而当我们只打印first或者second时，出现了堆栈溢出：</p>
<p><img src="/../assets/img/16-11.jpg" alt="图16-11" title="16-11"></p>
<p>如果我们需要互相引用又不希望出现这种问题，需要用到Weak指针：</p>
<h4 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1.概念"></a>1.概念</h4><p>什么是Weak<T>?</p>
<p>弱引用</p>
<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h4><h5 id="a-非所有权引用"><a href="#a-非所有权引用" class="headerlink" title="a.非所有权引用:"></a>a.非所有权引用:</h5><p>Weak<T>并不拥有数据的所有权,因此它不会影响 RC<T>的引用计数。</p>
<h5 id="b-不会引发内存泄漏"><a href="#b-不会引发内存泄漏" class="headerlink" title="b.不会引发内存泄漏:"></a>b.不会引发内存泄漏:</h5><p>由于Weak<T><strong>不增加引用计数,可以以避免引用循环问题,从而避免内存泄漏。</strong></p>
<h5 id="c-必须升级"><a href="#c-必须升级" class="headerlink" title="c.必须升级:"></a>c.必须升级:</h5><p>Weak<T>是一个非所有权引用,因此在使用数据之前,需要通过upgrade()方法将其升级为Rc<T>,如果数据已经被释放,upgrade()会返回 None</p>
<p><img src="/../assets/img/16-12.jpg" alt="图16-12" title="16-12"></p>
<p>如上所示：在struct中添加了弱引用, 并通过强弱引用将二者相互关联，最终打印时发现，first存在一个弱引用, 此时再打印first,发现next指向了second,second的prev是弱指针</p>
<h4 id="3-强引用与弱引用的主要区别"><a href="#3-强引用与弱引用的主要区别" class="headerlink" title="3.强引用与弱引用的主要区别"></a>3.强引用与弱引用的主要区别</h4><h5 id="a-所有权"><a href="#a-所有权" class="headerlink" title="a.所有权:"></a>a.所有权:</h5><p>强引用(RC<T>):持有数据的所有权,保证数据在作用内不会被释放</p>
<p>弱引用(Weak<T>):不持有数据的所有权,不影响数据的生命周期。</p>
<h5 id="b-引用计数"><a href="#b-引用计数" class="headerlink" title="b.引用计数:"></a>b.引用计数:</h5><p>强引用:增加引用计数,数据被多个所有者共享。</p>
<p>弱引用:不增加引用计数,不干扰RC<T>的生命周期管理。</p>
<h5 id="c-内存管理"><a href="#c-内存管理" class="headerlink" title="c.内存管理:"></a>c.内存管理:</h5><p>强引用:只有当所有强引用都被丢弃时,数据才会被释放.</p>
<p>弱引用:只能通过升级<code>upgrade()</code>来访问数据,如果数数据已经被释放,则升级会失败.</p>
<h5 id="d-适用场景"><a href="#d-适用场景" class="headerlink" title="d.适用场景:"></a>d.适用场景:</h5><p>强引用:当你希望共享数据并确保数据在至少一个强引用存在时不会被释放。</p>
<p>弱引用:当你需要避免引用循环或只需要偶尔访问数据,不想持有其所有权时.</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><h4 id="1-实现一个简单的文件系统模拟-其中包含文件和文件夹的根念。支持创建和罗列"><a href="#1-实现一个简单的文件系统模拟-其中包含文件和文件夹的根念。支持创建和罗列" class="headerlink" title="1. 实现一个简单的文件系统模拟,其中包含文件和文件夹的根念。支持创建和罗列"></a>1. 实现一个简单的文件系统模拟,其中包含文件和文件夹的根念。支持创建和罗列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">struct File &#123;</span><br><span class="line">    name: String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Dir &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    contents: Vec&lt;(String, Box&lt;FileNode&gt;)&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum FileNode &#123;</span><br><span class="line">    File(File),</span><br><span class="line">    Dir(Dir),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Dir &#123;</span><br><span class="line">    fn new(name: String) -&gt; Dir &#123;</span><br><span class="line">        Dir &#123;</span><br><span class="line">            name,</span><br><span class="line">            contents: Vec::new(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn add_file(&amp;mut self, name: String) &#123;</span><br><span class="line">        let file = File &#123;</span><br><span class="line">            name: name.clone(),</span><br><span class="line">        &#125;;</span><br><span class="line">        self.contents.push((name, Box::new(FileNode::File(file))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn add_dir(&amp;mut self, name: String) -&gt; &amp;mut Dir &#123;</span><br><span class="line">        let dir = Dir::new(name.clone());</span><br><span class="line">        self.contents.push((name.clone(), Box::new(FileNode::Dir(dir))));</span><br><span class="line">        self.get_dir_mut(&amp;name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn get_dir_mut(&amp;mut self, name: &amp;str) -&gt; &amp;mut Dir &#123;</span><br><span class="line">        for (ref mut n, ref mut node) in &amp;mut self.contents &#123;</span><br><span class="line">            if n == name &#123;</span><br><span class="line">                if let FileNode::Dir(ref mut dir) = node.as_mut() &#123;</span><br><span class="line">                    return dir;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        panic!(&quot;Directory not found&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut root = Dir::new(&quot;root&quot;.to_string());</span><br><span class="line"></span><br><span class="line">    let mut dir1 = root.add_dir(&quot;dir1&quot;.to_string());</span><br><span class="line">    dir1.add_file(&quot;file1.txt&quot;.to_string());</span><br><span class="line"></span><br><span class="line">    let mut subdir1 = dir1.add_dir(&quot;subdir1&quot;.to_string());</span><br><span class="line">    subdir1.add_file(&quot;file2.txt&quot;.to_string());</span><br><span class="line"></span><br><span class="line">    // 打印目录结构以验证结果</span><br><span class="line">    fn print_dir(dir: &amp;Dir, indent: usize) &#123;</span><br><span class="line">        for (name, node) in &amp;dir.contents &#123;</span><br><span class="line">            println!(&quot;&#123;&#125;&#123;name&#125;&quot;, &quot; &quot;.repeat(indent));</span><br><span class="line">            match node.as_ref() &#123;</span><br><span class="line">                FileNode::File(_) =&gt; println!(&quot;&#123;&#125; (file)&quot;, name),</span><br><span class="line">                FileNode::Dir(subdir) =&gt; &#123;</span><br><span class="line">                    println!(&quot;&#123;&#125; (dir)&quot;, name);</span><br><span class="line">                    print_dir(&amp;subdir, indent + 4);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print_dir(&amp;root, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-实现一个简单的社交网络系统-包含用户和朋友关系。使用Rc-RefCell-Weak来处理"><a href="#2-实现一个简单的社交网络系统-包含用户和朋友关系。使用Rc-RefCell-Weak来处理" class="headerlink" title="2.实现一个简单的社交网络系统,包含用户和朋友关系。使用Rc,RefCell,Weak来处理"></a>2.实现一个简单的社交网络系统,包含用户和朋友关系。使用Rc<T>,RefCell<T>,Weak<T>来处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">use std::cell::RefCell;</span><br><span class="line">use std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"></span><br><span class="line">#[derive(Debug, Clone)]</span><br><span class="line">struct User &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    friends: RefCell&lt;Vec&lt;Weak&lt;User&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl User &#123;</span><br><span class="line">    fn new(name: &amp;str) -&gt; Rc&lt;User&gt; &#123;</span><br><span class="line">        Rc::new(User &#123;</span><br><span class="line">            name: name.to_string(),</span><br><span class="line">            friends: RefCell::new(vec![]),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn add_friend(&amp;self, other: Rc&lt;User&gt;) &#123;</span><br><span class="line">        // if !other.friends.borrow().contains(&amp;Rc::downgrade(&amp;Rc::new(self.clone()))) &#123;</span><br><span class="line">            self.friends.borrow_mut().push(Rc::downgrade(&amp;other));</span><br><span class="line">            other.friends.borrow_mut().push(Rc::downgrade(&amp;Rc::new(self.clone())));</span><br><span class="line">        // &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn show_friends(&amp;self) &#123;</span><br><span class="line">        let friends_list = self.friends.borrow().iter().filter_map(|weak| &#123;</span><br><span class="line">            weak.upgrade()</span><br><span class="line">        &#125;).collect::&lt;Vec&lt;_&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        println!(&quot;&#123;&#125;&#x27;s friends:&quot;, self.name);</span><br><span class="line">        for friend in friends_list.iter() &#123;</span><br><span class="line">            println!(&quot;&#123;&#125;&quot;, friend.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let user1 = User::new(&quot;Alice&quot;);</span><br><span class="line">    let user2 = User::new(&quot;Bob&quot;);</span><br><span class="line">    let user3 = User::new(&quot;Charlie&quot;);</span><br><span class="line"></span><br><span class="line">    user1.add_friend(user2.clone());</span><br><span class="line">    user2.add_friend(user3.clone());</span><br><span class="line">    user3.add_friend(user1.clone()); // This will create a cycle, but we handle it.</span><br><span class="line"></span><br><span class="line">    user1.show_friends();</span><br><span class="line">    user2.show_friends();</span><br><span class="line">    user3.show_friends();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>















      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/10/12/rust16/" data-id="cm26g9orz000058uyhmah69ik" data-title="rust 学习笔记十六 Rust 智能指针" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/11/09/rust25/">rust 学习笔记二十五 Rust中的共享内存</a>
          </li>
        
          <li>
            <a href="/2024/11/03/rust24/">rust 学习笔记二十四 Rust的并发</a>
          </li>
        
          <li>
            <a href="/2024/10/31/rust23/">rust 学习笔记二十三 Rust测试</a>
          </li>
        
          <li>
            <a href="/2024/10/29/rust22/">rust 学习笔记二十二 Rust中的迭代器&amp;关联类型</a>
          </li>
        
          <li>
            <a href="/2024/10/27/rust21/">rust 学习笔记二十一 Rust中的闭包</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Liu Canzhu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>