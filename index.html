<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>canzhu&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="canzhu&#39;s blog">
<meta property="og:url" content="https://liucanzhu.github.io/index.html">
<meta property="og:site_name" content="canzhu&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liu Canzhu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="canzhu's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">canzhu&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://liucanzhu.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-rust10" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/15/rust10/" class="article-date">
  <time class="dt-published" datetime="2024-09-15T14:24:06.288Z" itemprop="datePublished">2024-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/15/rust10/">rust 学习笔记十 Rust 中的ENUM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）概览"><a href="#（一）概览" class="headerlink" title="（一）概览"></a>（一）概览</h3><p>rust中创建字符串主要有以下两种方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    enum Pets&#123;</span><br><span class="line">        Bird,</span><br><span class="line">        Cat(String),</span><br><span class="line">        Dog&#123; name:String, age:usize&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">let</span> bird= Pets::Bird;</span><br><span class="line">    <span class="built_in">let</span> <span class="built_in">cat</span> = Pets::Cat(<span class="string">&quot;jack&quot;</span>.to_string());</span><br><span class="line">    <span class="built_in">let</span> dog = Pets::Dog &#123; name: <span class="string">&quot;tom&quot;</span>.to_string(), age: 18 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Enum中的元素可以没有任何参数，可以是带有一个参数的变体，也可以是有多个name声明的结构体</p>
<p>如果直接对初始化出来的元素进行打印：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println!(<span class="string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,bird, <span class="built_in">cat</span>, dog);</span><br></pre></td></tr></table></figure>

<p>会发现报错：没有实现debug trait，此时我们可以通过在代码上方直接添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[derive(Debug)]</span></span><br></pre></td></tr></table></figure>

<p>这样相当于在枚举中自动补全了debug trait.</p>
<p>可以为枚举实现一些方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">impl Pets &#123;</span><br><span class="line">    fn speak(&amp;self) &#123;</span><br><span class="line">        println!(<span class="string">&quot;speak&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的speak就叫做<strong>methods（方法）</strong>,其中第一个参数&amp;self是<strong>对当前这个枚举实例的引用</strong>, 然后枚举中的元素的实例可以调用这个方法：<code>dog.speak();</code></p>
<p>此外还有一种关联函数，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">impl Pets &#123;</span><br><span class="line">    fn <span class="function"><span class="title">log</span></span>() &#123;</span><br><span class="line">        println!(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这类函数参数中将不会再有枚举实例的引用，调用方法也和methods有区别，不再是通过枚举中元素的，而是直接通过<strong>枚举名称::静态方法</strong>名来调用：<code> Pets::log();</code></p>
<h3 id="二-用法"><a href="#二-用法" class="headerlink" title="(二) 用法"></a>(二) 用法</h3><p>1，比较</p>
<p>先看下面这个例子：</p>
<p><img src="/../assets/img/10-1.jpg" alt="图10-1" title="10-1"></p>
<p>bird 和 cat 是同一个枚举 Pets 的不同变体的实例，如果直接将这两个实例进行对比，会报错：<code>binary operation `==` cannot be applied to type `Pets</code>,在rust中，是不支持直接用等号来比较两个变体实例的，根据提示，<br><code>an implementation of `PartialEq` might be missing for `Pets`,consider annotating `Pets` with `#[derive(PartialEq)]`: </code>, 和刚才一样，在最前面添加一个<code>#[derive(PartialEq)]</code>进行补全，即可使用等号比较.</p>
<ol start="2">
<li>Match vs if let</li>
</ol>
<p>对于创建出来的变体实例，可以通过match判断其类型</p>
<p>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">match <span class="built_in">cat</span> &#123;</span><br><span class="line">    Pets::Cat(e) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Pets::Dog&#123;name, age&#125; =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Pets::Bird =&gt; todo!(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在匹配到对应类型时，可以直接访问其中的变量</p>
<p>同时match也适用于rust中的普通变量，比如可以用来匹配i32常数:</p>
<p><img src="/../assets/img/10-2.jpg" alt="图10-2" title="10-2"></p>
<p>但此时发现有报错：因为match要求列举完可能的所有情况，但我们无法将i32的所有可能值全部列举，所以可以在下面再加一种可能：</p>
<p>用<strong>下划线</strong>代替其余的所有可能</p>
<p><img src="/../assets/img/10-3.jpg" alt="图10-3" title="10-3"></p>
<p>而如果觉得每次都进行模糊匹配有点复杂，可以选择使用if let，便可以只关注需要匹配的类型：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">let</span> <span class="built_in">cat</span> = Pets::Cat &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是if let无法像match一样获取到匹配的参数.</p>
<h3 id="三-rust中的两大枚举"><a href="#三-rust中的两大枚举" class="headerlink" title="(三) rust中的两大枚举"></a>(三) rust中的两大枚举</h3><ol>
<li>Option</li>
</ol>
<p>示例如下：</p>
<p><img src="/../assets/img/10-4.jpg" alt="图10-4" title="10-4"></p>
<p>被分为<strong>some和none</strong>两种情况</p>
<p>如果存在一个map,如下:</p>
<p><img src="/../assets/img/10-5.jpg" alt="图10-5" title="10-5"></p>
<p>通过get获取其中的某个key,此时获得的是一个<strong>option</strong>类型的元素,我们将其进行match匹配:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">match a &#123;</span><br><span class="line">    Some(val)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    None =&gt;&#123; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，对于一个动态数组，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = vec![1,2,3,4];</span><br><span class="line"><span class="built_in">let</span> a = arr.iter().last();</span><br></pre></td></tr></table></figure>

<p>我们取出它的最后一个元素，根据提示，也是option类型，故也可以用match进行匹配</p>
<ol start="2">
<li>Result</li>
</ol>
<p>先看示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> num:Result&lt;usize, ()&gt; = Ok(1);</span><br><span class="line">match num &#123;</span><br><span class="line">    Ok(val)=&gt;&#123;&#125;,</span><br><span class="line">    Err(_)=&gt;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果同样使用match进行匹配，只不过其中的匹配项变成了<strong>Ok()和 Err()</strong></p>
<p>在Rust当中，可以声明函数的返回值为Result类型,比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() -&gt; Result&lt;(), ()&gt;&#123;</span><br><span class="line">    <span class="built_in">let</span> num: Result&lt;usize, ()&gt; = Ok(1);</span><br><span class="line">    match num &#123;</span><br><span class="line">        Ok(val)=&gt;&#123;&#125;</span><br><span class="line">        Err(_)=&gt;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而将&amp;str类型进行反序列化的parse函数返回值也是Result类型</p>
<ol start="3">
<li>Option  和  Result 的相互转换</li>
</ol>
<p>a.Option转result:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> opt = Some(42);</span><br><span class="line"><span class="built_in">let</span> result:Result&lt;i32, &amp;str&gt; = opt.ok_or(<span class="string">&quot;err&quot;</span>);</span><br><span class="line">assert_eq!(result, Ok(42));</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> none:Option&lt;i32&gt; = None;</span><br><span class="line"><span class="built_in">let</span> result:Result&lt;i32, &amp;str&gt; = none.ok_or(<span class="string">&quot;err&quot;</span>);</span><br><span class="line">assert_eq!(result, Err(<span class="string">&quot;err&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>其中第一个result走的是ok，所以得到的是Ok(42),第二个和or相匹配，得到的是Err(“err”)</p>
<p>b.Result转option</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> res:Result&lt;i32, &amp;str&gt; = Ok(1);</span><br><span class="line"><span class="built_in">let</span> option = res.ok();</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> res:Result&lt;i32, &amp;str&gt; = Err(<span class="string">&quot;err&quot;</span>);</span><br><span class="line"><span class="built_in">let</span> option = res.ok();</span><br></pre></td></tr></table></figure>

<p>如果是第二种情况，会转换成None,正常情况则是Some</p>
<p>4.常见api</p>
<p>a.可以通过map来遍历option:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> option = Some(1);</span><br><span class="line"><span class="built_in">let</span> b = option.map(|num| num + 1);</span><br></pre></td></tr></table></figure>

<p>b.如果需要多层match层层嵌套，会导致代码繁琐，易读性不高，所以有语法糖，可以直接取出值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> option = Some(1);</span><br><span class="line"><span class="built_in">let</span> a= option.unwrap();</span><br></pre></td></tr></table></figure>

<p>但如果值是None,会panic，也可以使用expect:<code>let a = option.expect(“msg”);</code>可以传入默认值</p>
<p>c.or_else</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> option = Some(1);</span><br><span class="line"><span class="built_in">let</span> a = option.or_else(|| Some((<span class="number">3</span>)));</span><br></pre></td></tr></table></figure>

<p>返回值也是一个Some，用于优雅的处理可能为None的值，给一个默认值</p>
<p>d.mem::size_of::<T>() </p>
<p>mem::size_of::<T>() 函数返回类型 T 在当前平台上的内存大小（以字节为单位）</p>
<p>示例如下：</p>
<p><img src="/../assets/img/10-6.jpg" alt="图10-6" title="10-6"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/15/rust10/" data-id="cm13ta5d30000xsuy91ri6psf" data-title="rust 学习笔记十 Rust 中的ENUM" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust9" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/13/rust9/" class="article-date">
  <time class="dt-published" datetime="2024-09-13T14:48:45.404Z" itemprop="datePublished">2024-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/13/rust9/">rust 学习笔记九 Rust 中的字符串</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）创建字符串的方式"><a href="#（一）创建字符串的方式" class="headerlink" title="（一）	创建字符串的方式"></a>（一）	创建字符串的方式</h3><p>rust中创建字符串主要有以下两种方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> s = String::from(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> s = <span class="string">&quot;hello world2&quot;</span>;</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br></pre></td></tr></table></figure>

<p>其中，第二种直接引号创建的方式，叫<strong>字符串字面值</strong>,我们在编译时就知道其内容,最终字面值文本被直接硬编码进可执行文件，字符串字面量”hello world”就是<strong>str类型</strong>,它被硬编码进可执行程序的数据部分</p>
<p>既然我们已经存储了这个字符串,就需要一种方法来访问它:这就是<strong>切片引用</strong>&amp;str的意义所在，&amp;str是一种<strong>不可变引用</strong>,所以它没有所有权，str类型是硬编码进可执行文件,也<strong>无法被修改</strong>.</p>
<p>但如果我们需要对这种数据进行修改的时候，就需要用到第一种创建方法，String在rust中是一个复合数据类型,存储在<strong>堆上</strong>,定义如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pub struct String&#123;</span><br><span class="line">vec: Vec&lt;u8&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>意味string可改变的、并且<strong>拥有所有权</strong>的</p>
<p>总结一下二者区别:</p>
<p><strong>&amp;str</strong>:这是一个字符串切片,它是固定大小的,并且不能改变</p>
<p><strong>&amp;string</strong>:这是一个可增长的、可改变的、拥有所有权的、UTF-8编码的字符串类型。它通常用于需要改变或者增长字符串的情况</p>
<h3 id="（二）类型转换"><a href="#（二）类型转换" class="headerlink" title="（二）	类型转换"></a>（二）	类型转换</h3><p><img src="/../assets/img/9-1.jpg" alt="图9-1" title="9-1"></p>
<p>这其中发生了从u8数组到str的转换，但将数组的定义改为vec定义也可以：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> b = vec!(104, 101, 108, 108, 111);</span><br></pre></td></tr></table></figure>

<p>这是因为vector对其进行了隐式的类型转换，同样，也可以进行从str到utf8数组的转换</p>
<p><img src="/../assets/img/9-2.jpg" alt="图9-2" title="9-2"></p>
<p>如果需要进行str 和 string的相互转换：</p>
<p>从String类型转变为&amp;str是非常便捷的,而且<strong>无损的</strong>(性能无损,不会造成重写malloc或者数据移动),另外,由于Rust实现了自动解引用,那么&amp;String在必要的时候可以自动转换为&amp;str,因此在很多函数中,如果接收参数是字符串的引用,通常会采用&amp;str作为入参,以获取更好的数据兼容性<br>,字符串是UTF-8编码,因此需要保证索引的字节刚好落在<strong>字符的边界</strong></p>
<p><img src="/../assets/img/9-3.jpg" alt="图9-3" title="9-3"></p>
<p>如果需要从&amp;str转为string则需要用 String::from进行包裹：</p>
<p><img src="/../assets/img/9-4.jpg" alt="图9-4" title="9-4"></p>
<p>但是这样做对内存消耗较大，因为&amp;str类型的数据是被硬编码在可执行文件中的，但是转换为string类型需要<strong>重新到堆上申请内存</strong></p>
<h3 id="（三）常见修改String的方法"><a href="#（三）常见修改String的方法" class="headerlink" title="（三）	常见修改String的方法"></a>（三）	常见修改String的方法</h3><ol>
<li>追加</li>
</ol>
<p>a.使用<strong>push()<strong>方法追加字符char<br>b.使用</strong>push_str()<strong>方法追加字符串字面量<br>两个方法都是在原有的字符串上追加,并</strong>不会返回新的字符串</strong><br>字符串追加操作要修改原来的字符串,则该字符串必须是可变的,即字符串变量必须由<strong>mut</strong>关键字修饰</p>
<p><img src="/../assets/img/9-5.jpg" alt="图9-5" title="9-5"></p>
<ol start="2">
<li>插入</li>
</ol>
<p>a.使用<strong>insert()<strong>方法插入单个字符char<br>b.使用</strong>insert_str()<strong>方法插入字符串字面量<br>这俩方法需要传入两个参数,第一个参数是字符(串)插入位置的索引,索引从0开始计数;第二个参数是要插入的字符<br>如果越界则会发生错误<br>如果参数所给的位置不是</strong>合法的字符边界</strong>,也会发生错误<br>由于字符串插入操作要修改原来的字符串,则该字符串必须是可变的,即字符串变量必须由<strong>mut</strong>关键字修饰</p>
<p><img src="/../assets/img/9-6.jpg" alt="图9-6" title="9-6"></p>
<ol start="3">
<li>替换</li>
</ol>
<p>a. <strong>replace()<strong>方法接收两个参数,第一个参数是要被替换的字符串,第二个参数是新的字符串<br>该方法会替换所有匹配到的字符串<br>该方法是返回一个新的字符串,而不是操作原来的字符串,故不会修改原字符串，</strong>不需要mut修饰</strong></p>
<p><img src="/../assets/img/9-7.jpg" alt="图9-7" title="9-7"></p>
<p>b. <strong>replace_range()<strong>接收两个参数,第一个参数是要替换字符串的范围(Range),第二个参数是新的字符串<br>该方法是直接操作原来的字符串,不会返回新的字符串。该方去需要使用</strong>mut</strong>关键字修饰<br>如果range的范围大于&#x2F;小于新字符串的长度会因为不在<strong>合法边界</strong>而报错</p>
<p><img src="/../assets/img/9-8.jpg" alt="图9-8" title="9-8"></p>
<p>4.删除</p>
<p>a.pop<br><strong>删除并返回</strong>字符串的最后一个字符<br>其返回值是一个<strong>Option类型</strong>,如果字符串为空,则返回<br>该方法是直接操作原来的字符串</p>
<p><img src="/../assets/img/9-9.jpg" alt="图9-9" title="9-9"></p>
<p>b.remove<br>该方法是直接操作原来的字符串<br>其返回值是<strong>删除位置的字符串</strong><br>只接收一个参数,表示该字符<strong>起始索引位置</strong><br>方法是按照字节来处理字符串的,如果参数所给的位置不是<strong>合法的的字符边界</strong>,则会发生错误</p>
<p><img src="/../assets/img/9-10.jpg" alt="图9-10" title="9-10"></p>
<p>c.truncat<br>删除字符串中<strong>从指定位置开始到结尾的全部字符</strong><br>方法是按照字节来处理字符串的,如果参数所给的位置不是<strong>合法的字符边界</strong>,则会发生错误<br>该方法是直接操作原来的字符串</p>
<p><img src="/../assets/img/9-11.jpg" alt="图9-11" title="9-11"></p>
<p>d.clear<br>清空字符串<br>该方法是直接操作原来的字符串</p>
<p><img src="/../assets/img/9-12.jpg" alt="图9-12" title="9-12"></p>
<p>5.连接</p>
<p>a.使用+或者+&#x3D;连接字符串<br>这里add()方法的第二个参数必须为字符串的<strong>切片引用类型</strong><br>是返回一个新的字符串,所以变量声明可以<strong>不需要mut关键字修饰</strong></p>
<p><img src="/../assets/img/9-13.jpg" alt="图9-13" title="9-13"></p>
<p>b.使用format!连接字符串<br>format!的用法与 print!的用法类似</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/13/rust9/" data-id="cm10u4a4g0000e4uy9nle6pel" data-title="rust 学习笔记九 Rust 中的字符串" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust8" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/12/rust8/" class="article-date">
  <time class="dt-published" datetime="2024-09-11T16:29:39.235Z" itemprop="datePublished">2024-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/12/rust8/">rust 学习笔记八 Rust 中的数组与切片</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>类型[T;N]表示N个值的数组,每个值的类型为T。数组的大小是<strong>在编译期就已确定的常量</strong>,并且是类型的一部分,不能追加新元素或缩小数组。类型&amp;[T]和&amp;mut[T]可称为T的<strong>共享切片</strong>和T的<strong>可变切片</strong>,它们是对一系列元素的引用,这些元素是某个其他值(比如数组或向量)的一部分。可以将切片视为<strong>指向其第一个元素的指针</strong>,以及从该点开始允许访问的元素数量的计数。可变切片&amp;mut[T]<strong>允许读取元素和修改元素,但不能共享</strong>;共享切片&amp;[T]允许<strong>在多个读取者之间共享访问权限,但不允许修改元素</strong>。</p>
<p>rust会检查类型中任意一种类型的值v,表达式v.len()都会给出v中的元素数,而v[i]引用的是V的第 i 个元素， 第一个元素是v[0],最后一个元素是v[v.len()-1]。Rust总是会检查i是否在这个范围内,如果没在,则此表达式会出现panic（），长度可能为0,在这种情况下,任何对其进行索引的尝试都会出现panic。i的类型必须是<strong>usize</strong>,不能使用任何其他整型作为索引。</p>
<h3 id="（一）数组"><a href="#（一）数组" class="headerlink" title="（一）	数组"></a>（一）	数组</h3><p>数组有以下特征：</p>
<p>1.数组的定义其实就是为分配一段<strong>连续的相同数据类型的内存块</strong></p>
<p>2.数组是<strong>静态</strong>的。这意味着一旦定义和初始化,则永远不可更改它的长度</p>
<p>3.数组的元素有着<strong>相同</strong>的数据类型,每一个元素都独占者数据类型大小的内存块。也就是说。数组的内存大小等于数组的长度乘以数组的数据类型</p>
<p>4.数组中的每一个元素都按照顺序依次存储,这个顺序号既代表着元素的存储位置,也是数组元素的唯一标识。我们把这个标识称之为数组下标</p>
<p>5.填充数组中的每一个元素的过程称为数组初始化。也就是说数组初始化就是为数组中的每一个元素赋值</p>
<p>6.可以更新或修改数组元素的值,但<strong>不能删除数组元素</strong>。如果要删除功能,你可以将它的值赋值为0或其它表示删除的值</p>
<p>介绍几种初始化数组的方法：</p>
<p>1.首先是最标准的格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr:[i32;4] = [10,11,12,13];</span><br></pre></td></tr></table></figure>
<p>在数组名称后面添加<code>[类型；个数]</code>的声明</p>
<p>2.或者也可以不声明，rust会自行推导</p>
<p>3.如果数组中每个元素的类型和值都一样的话，可以不用挨个列出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr= [10;4];</span><br></pre></td></tr></table></figure>

<p>如果需要获取数组的长度，通常通过调用函数len():<code>arr.len();</code></p>
<p>数组的遍历：</p>
<p>1.可通过之前说过的for循环结合序列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> 0..4&#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,arr[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2:可通过rust的迭代器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> arr.<span class="function"><span class="title">iter</span></span>()&#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  也可以这样写，更精简：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.iter().for_each(|value| println!(<span class="string">&quot;&#123;&#125;&quot;</span>,value));</span><br></pre></td></tr></table></figure>

<p>如果需要修改一个数组中的元素，直接像下面这样：<code>arr[0] = 1;</code>是会报错的，因为这是个<strong>不可变数组</strong>需要修改的话需要将数组声明为mut</p>
<p>在看下面这个例子：</p>
<p><img src="/../assets/img/8-1.jpg" alt="图8-1" title="8-1"></p>
<p>可以发现在函数内打印的数组已经被修改了，但是并没有在函数作用域外起作用，这样的操作叫<strong>值传递</strong>,如果需要在函数中修改数组中的值，需要使用<strong>引用传递</strong>：</p>
<p><img src="/../assets/img/8-2.jpg" alt="图8-2" title="8-2"></p>
<h3 id="（二）切片"><a href="#（二）切片" class="headerlink" title="（二）	切片"></a>（二）	切片</h3><p>Slice类型通常翻译为切片,它表示从某个包含多个元素的容器中取得局部数据,这个过程称为切片操作。不同语言对切片的支持有所不同,比如有些语言只允许取得连续的局部元素,而有些语言可以取得离散元素,甚至有些语言可以对hash结构进行切片操作</p>
<p>Rust也支持Slice操作,Rust中的切片操作只允许获取一段连续的局部数据,切片操作获取到的数据称为切片数据</p>
<p>Rust常见的数据类型中,有三种类型已支持Slice操作:String类型、Array类型和Vec类型</p>
<p>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = [10,20,30,40,50,60];</span><br><span class="line"><span class="built_in">let</span> slice = &amp;a[1..3];</span><br><span class="line">println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,slice);</span><br></pre></td></tr></table></figure>

<p>切片常用函数如下:</p>
<p><img src="/../assets/img/8-3.jpg" alt="图8-3" title="8-3"></p>
<p>此处不挨个举例，简单举例几个比较特殊的函数</p>
<p>1.windows</p>
<p><img src="/../assets/img/8-4.jpg" alt="图8-4" title="8-4"></p>
<p>2 start_with</p>
<p><img src="/../assets/img/8-5.jpg" alt="图8-5" title="8-5"></p>
<hr>
<p>思考：给定一个整数数组nums,返回一个数组answer,使得answer[i]等于nums除之外nums[i]的所有元素的乘积:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> a = [1,-1,1,1];</span><br><span class="line">    <span class="built_in">let</span> b:Vec&lt;i32&gt; = complete(&amp;a);</span><br><span class="line">    println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn complete(arr: &amp;[i32]) -&gt; Vec&lt;i32&gt;&#123;</span><br><span class="line">    <span class="built_in">let</span> length = arr.len();</span><br><span class="line">    <span class="built_in">let</span> mut result = vec![1; length];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">let</span> mut left_product = 1;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> 0..length &#123;</span><br><span class="line">        result[i] *= left_product;</span><br><span class="line">        left_product *= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">let</span> mut right_product = 1;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (0..length).<span class="function"><span class="title">rev</span></span>() &#123;</span><br><span class="line">        result[i] *= right_product;</span><br><span class="line">        right_product *= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/12/rust8/" data-id="cm0y2xqu70000eguy8ziae905" data-title="rust 学习笔记八 Rust 中的数组与切片" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust7" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/10/rust7/" class="article-date">
  <time class="dt-published" datetime="2024-09-09T17:51:03.438Z" itemprop="datePublished">2024-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/10/rust7/">rust 学习笔记七 Rust 中的引用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="（一）在rust中，引用分为可变引用和不可变引用"><a href="#（一）在rust中，引用分为可变引用和不可变引用" class="headerlink" title="（一）在rust中，引用分为可变引用和不可变引用"></a>（一）在rust中，引用分为可变引用和不可变引用</h3><p>·不可变引用(Immutable Reference):通过不可变引用,可以读取数据,但不能修改数据。一个变量可以有多个不可变引用,但不能与可变引用共存</p>
<p>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> s1 = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">let</span> s2 = &amp;s1;</span><br><span class="line"><span class="built_in">let</span> s3 = &amp;s1;</span><br></pre></td></tr></table></figure>

<p>可变引用(Mutable Reference):通过可变引用,可以读取和修改数据。一个变量在某一时刻只能有一个可变引用,且不能与不可变引用共存</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> mut s1 = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">let</span> s2 = &amp;mut s1;</span><br></pre></td></tr></table></figure>

<p>综上，同一时间内一个变量只能<strong>有一个可变引用或者多个不可变引用，且必须总是有效</strong></p>
<p>但是在以下情况下，是可以正常执行的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> mut s1 = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">let</span> s2 = &amp;s1;</span><br><span class="line"><span class="built_in">let</span> s3 = &amp;s1;</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>,s2, s3);</span><br><span class="line"><span class="built_in">let</span> s4 = &amp; mut s1;</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s4);</span><br></pre></td></tr></table></figure>

<p>但是在这种情况下，是可以正常执行的，因为可以把2~4行中对于s1的引用视作一个单独的作用域，而在打印结束之后不会有关于引用的使用，所以可以视作对s1的不可变引用已经结束了，所以不会影响后面继续对s1创建可变引用</p>
<h3 id="（二）关于引用的一些概念"><a href="#（二）关于引用的一些概念" class="headerlink" title="（二）关于引用的一些概念"></a>（二）关于引用的一些概念</h3><ol>
<li><p>Move</p>
<p> 主要描述堆数据所有权的转移</p>
</li>
<li><p>borrowing</p>
<p> 在向函数传入参的时候，函数对于变量所有权的借用</p>
</li>
<li><p>referenceing</p>
<p> 包含了borrowing 以及 字符串和数组的切片（对堆上某一段数据的引用）</p>
</li>
</ol>
<h3 id="（三）生命周期"><a href="#（三）生命周期" class="headerlink" title="（三）生命周期"></a>（三）生命周期</h3><p>生命周期是Rust用来保证引用有效性的机制。生命周期注解允许编译器推断引用的有效范围,确保在引用仍然有效时使用它们</p>
<p>先看下面的示例：</p>
<p><img src="/../assets/img/7-1.jpg" alt="图7-1" title="7-1"></p>
<p>直接这样写会报错，提示是不能返回一个对于函数中临时值的引用，前文所有权中见过，作用域结束时会自动调用drop，在其他地方调用会导致<strong>悬垂指针</strong>的问题</p>
<p>在rust中，解决办法是：</p>
<p><img src="/../assets/img/7-2.jpg" alt="图7-2" title="7-2"></p>
<p>在外面创建一个空变量，将其可变引用传入函数进行修改，然后返回</p>
<p>或者：</p>
<p><img src="/../assets/img/7-3.jpg" alt="图7-3" title="7-3"></p>
<p>但如果向下面这样传入引用修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = getLongest(&amp;<span class="string">&quot;a&quot;</span>.to_owned(), &amp;<span class="string">&quot;b&quot;</span>.to_owned());</span><br><span class="line">fn getLongest(a: &amp;String,b :&amp;String) -&gt; &amp;String&#123;</span><br><span class="line">    <span class="keyword">if</span> a.len() &gt; b.<span class="function"><span class="title">len</span></span>()&#123;</span><br><span class="line">        a</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>!(<span class="string">&quot;&#123;&#125;&quot;</span>,a);</span><br></pre></td></tr></table></figure>

<p>会报错：<strong>缺少生命周期</strong></p>
<p>此时我们需要根据提示标记一下声明周期’a，（具体原因后面描述），像下面这样，即可通过编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> s1 = <span class="string">&quot;a&quot;</span>.to_owned();</span><br><span class="line"><span class="built_in">let</span> s2 = <span class="string">&quot;b&quot;</span>.to_owned();</span><br><span class="line"><span class="built_in">let</span> a = getLongest(&amp;s1, &amp;s2);</span><br><span class="line">fn getLongest&lt;<span class="string">&#x27;a&gt;(a: &amp;&#x27;</span>a String,b :&amp;<span class="string">&#x27;a String) -&gt; &amp;&#x27;</span>a String&#123;</span><br><span class="line">    <span class="keyword">if</span> a.len() &gt; b.<span class="function"><span class="title">len</span></span>()&#123;</span><br><span class="line">        a</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>!(<span class="string">&quot;&#123;&#125;&quot;</span>,a);</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/10/rust7/" data-id="cm0vaxrzs0000pkuyc2837ljl" data-title="rust 学习笔记七 Rust 中的引用" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust6" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/08/rust6/" class="article-date">
  <time class="dt-published" datetime="2024-09-08T10:20:29.774Z" itemprop="datePublished">2024-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/08/rust6/">rust 学习笔记六 Rust中的所有权</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Rust是一种系统编程语言,其设计目的是确保内存安全并限防止数据竞争,而不依赖垃圾回收器。这种内存安全性主要通过<strong>所有权系统</strong>来实现</p>
<p>先看看主流编程语言的内存回收机制对比 :</p>
<p><img src="/../assets/img/6-1.png" alt="图6-1" title="6-1"></p>
<p>而在rust中，内存管理是通过<strong>所有权系统</strong>完成的</p>
<h3 id="一-有以下特点："><a href="#一-有以下特点：" class="headerlink" title="(一)有以下特点："></a>(一)有以下特点：</h3><p>1.Rust使用所有权系统进行内存管理,编译器在编译时通过静态态分析来确保内存安全</p>
<p>2.每个值<strong>都有一个所有者,在任何时候只能有一个有效的所有者</strong></p>
<p>3.通过 <strong>借用(引用)</strong> 机制来共享数据,同时保证数据竞争和悬垂指针的安全</p>
<p>4.当所有者离开作用域(scope),值会被丢弃(drop)</p>
<h3 id="二-为什么要有所有权："><a href="#二-为什么要有所有权：" class="headerlink" title="(二)为什么要有所有权："></a>(二)为什么要有所有权：</h3><p>举例说明：</p>
<p>对于分布在栈上的数据，如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> x = 5;</span><br><span class="line"><span class="built_in">let</span> y = x;</span><br></pre></td></tr></table></figure>

<p>这种情况下，是将原来的值进行了一个拷贝，而没有改变原来数据的所有权</p>
<p>而对于分布在堆上的数据，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> s1 = String::from(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="built_in">let</span> s2 = s1;</span><br></pre></td></tr></table></figure>

<p>实则是改变了数据的所有权到s2上，此时直接使用s1，会报错</p>
<p>故所有权可以<strong>确保程序在运行时不会访问无效的内存，避免了数据竞争和内存泄漏</strong></p>
<p>对于以下情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">let</span> s1 = String::from(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="built_in">let</span> s2 = s1;</span><br><span class="line">&#125;</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s2);</span><br></pre></td></tr></table></figure>

<p>也是不能正常访问的，因为在编译过程中，在scope结束时，会自动添加类似drop(s2)的代码，作用域一结束，s2就失效了</p>
<h3 id="三-实践一下"><a href="#三-实践一下" class="headerlink" title="(三)实践一下"></a>(三)实践一下</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> s1 = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">let</span> s2 = take_ownership(s1) ;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s1);</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s2);</span><br><span class="line">&#125;</span><br><span class="line">fn take_ownership(s:String) -&gt; String&#123;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接执行这段代码会报错。因为<code>ake_ownership</code> 函数获取了 s1 的所有权，因此 s1 不再有效，</p>
<p>如果需要保持s1所有权不变的前提下，将其值传入函数可以将s1进行<strong>克隆</strong>，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> s1 = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">let</span> s2 = take_ownership(s1.clone()) ;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s1);</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s2);</span><br><span class="line">&#125;</span><br><span class="line">fn take_ownership(s:String) -&gt; String&#123;</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者传入s1的<strong>不可变引用</strong>到函数中，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> s1 = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">let</span> s2 = take_ownership(&amp;s1) ;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s1);</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,s2);</span><br><span class="line">&#125;</span><br><span class="line">fn take_ownership(s:&amp;String) -&gt; String&#123;</span><br><span class="line">    <span class="built_in">return</span>  s.to_string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述两种方法中，更推荐使用第二种方法，因为第一种方法在参数体积比较大的时候，对参数进行clone，可能会导致对内存的占用和对性能的消耗</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/08/rust6/" data-id="cm0tfotgz00007cuyaj06gdu9" data-title="rust 学习笔记六 Rust中的所有权" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust5" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/08/rust5/" class="article-date">
  <time class="dt-published" datetime="2024-09-07T17:19:56.729Z" itemprop="datePublished">2024-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/08/rust5/">rust 学习笔记五 Rust中的数据类型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本篇主要讲解一下rust中的数据类型，主要从以下几个方面进行讲解：<strong>基础数据类型，整形，浮点，字符，序列，类型强制转换</strong></p>
<h3 id="（一）rust类型概览"><a href="#（一）rust类型概览" class="headerlink" title="（一）rust类型概览"></a>（一）rust类型概览</h3><p>rust中的主要类型如下图所示：</p>
<p><img src="/../assets/img/5-1.png" alt="图5-1" title="5-1"></p>
<p><img src="/../assets/img/5-2.png" alt="图5-2" title="5-2"></p>
<p><img src="/../assets/img/5-3.png" alt="图5-3" title="5-3"></p>
<h3 id="（二）整型"><a href="#（二）整型" class="headerlink" title="（二）整型"></a>（二）整型</h3><p>根据数据的大小，我们可以将有符号和无符号整数类型进—步分类为不同的类别:其中固定的有8, 16, 32, 64, 128位，在前面加i或者u表示是否有符号，不固定的有isize 和 usize, <strong>在不同架构上不一样</strong>，<br>在rust中定义整形默认是32位，此外，在rust中如果数字或者字符太长时，可以用_进行分隔使其更易读，表达的意思是一样的，比如：</p>
<p><img src="/../assets/img/5-4.jpg" alt="图5-4" title="5-4"></p>
<h3 id="（三）浮点型"><a href="#（三）浮点型" class="headerlink" title="（三）浮点型"></a>（三）浮点型</h3><p>浮点类型数字是带有小数点的数字,在Rust中浮点类型也有两种基本类型:f32和f64,分别为32位和64位大小。默认浮点类型是f64,在现代的CPU中它的速度与f32几乎相同,但精度更高。<br>由于二进制和十进制之间的转换不是完全精确的，很多十进制小数在转换为二进制时会变成无限循环小数，这导致它们不能被精确地表示，比如在rust 中直接判断 0.1 + 0.2 是否等于0.3，<strong>二者并不会直接相等</strong>，当你执行 0.1 + 0.2 时，你实际上是在计算两个不精确的值的和，结果也是一个不精确的值。这个结果可能非常接近 0.3，但由于精度限制，它可能不完全等于 0.3.最准确的表达方式是<strong>在误差范围内二者相等</strong><br>如下所示：</p>
<p><img src="/../assets/img/5-5.jpg" alt="图5-5" title="5-5"></p>
<h3 id="（四）NAN"><a href="#（四）NAN" class="headerlink" title="（四）NAN"></a>（四）NAN</h3><p>对于数学上未定义的结果,如负数开平方根,Rust的浮点数类型会使用NaN(Not a Number)来处理这些情况。任何与NaN进行交互的操作都会返回NaN,并且NaN不能用于比较(如断言),这会导致程序崩溃。<br>在rust中，可以通过<code>is_nan</code>方法来判断一个元素是否有效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> v = (-1.1_f64).sqrt();</span><br><span class="line"><span class="keyword">if</span> v.<span class="function"><span class="title">is_nan</span></span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>!(<span class="string">&quot;v is nan&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（五）布尔类型"><a href="#（五）布尔类型" class="headerlink" title="（五）布尔类型"></a>（五）布尔类型</h3><p>Rust中的布尔类型有两个可能的值:true和false,布尔值占用内存的大小为1个字节</p>
<h3 id="（六）序列"><a href="#（六）序列" class="headerlink" title="（六）序列"></a>（六）序列</h3><p>Rust提供了一个非常简洁的方式,用来生成连续的数值,例如1..5,生成从1到4的连续数字,不包含5;1.&#x3D;5,生成从1到5的连续数字,包含5,它的用途很简单,常常用于循环中<br>除了在之前文章中提到的用于数字的循环外，也可以用于字符的循环，比如：</p>
<p><img src="/../assets/img/5-6.jpg" alt="图5-6" title="5-6"></p>
<h3 id="七-类型强制转换"><a href="#七-类型强制转换" class="headerlink" title="(七)类型强制转换"></a>(七)类型强制转换</h3><p>在Rust中,<strong>as关键字</strong>用于在原始类型(如i64、f64、u64、char等)之间进行类型转换。然而,需要注意的是,as关健字并<strong>不适用于复合类型</strong>,比如String或其他用户定义的类型。对于复合类型的转换,通常需要使用其他方法或函数。<br>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = 5;</span><br><span class="line"><span class="built_in">let</span> f = a as f32;</span><br></pre></td></tr></table></figure>











      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/08/rust5/" data-id="cm0sf9tq40004sguy12ez38ys" data-title="rust 学习笔记五 Rust中的数据类型" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust4" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/06/rust4/" class="article-date">
  <time class="dt-published" datetime="2024-09-06T15:26:21.339Z" itemprop="datePublished">2024-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/06/rust4/">rust 学习笔记四 Rust中的流程控制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天主要从以下两个方面讲解以下Rust中的流程控制: <strong>条件控制，循环语句</strong>.</p>
<h2 id="（一）条件控制"><a href="#（一）条件控制" class="headerlink" title="（一）条件控制"></a>（一）条件控制</h2><p>示例如下：.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">let</span> number = 3;</span><br><span class="line">    <span class="keyword">if</span> number % 4 == 0 &#123;</span><br><span class="line">        println!(<span class="string">&quot;number is divisible by 4&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % 3 == 0 &#123;</span><br><span class="line">        println!(<span class="string">&quot;number is divisible by 3&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> number % 2 == 0&#123;</span><br><span class="line">        println!(<span class="string">&quot;number is divisible by 2&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键字后直接加结果为bool值的表达式即可.</p>
<p>除此之外，有一个rust的特性，可将条件语句直接绑定在变量上，示例如下：.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = <span class="keyword">if</span> condition  &#123;</span><br><span class="line">    6</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    5 + 2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>直接在条件语句中返回了不同情况下a的初始值，由于这本质上是个赋值语句，所以需要在条件语句后面<strong>加上一个分号</strong>，条件语句中的返回值可以是数值也可以是算式</p>
<h2 id="（二）循环语句"><a href="#（二）循环语句" class="headerlink" title="（二）循环语句"></a>（二）循环语句</h2><p>Rust中的循环语句分为以下几种</p>
<h3 id="1：loop循环"><a href="#1：loop循环" class="headerlink" title="1：loop循环."></a>1：loop循环.</h3><p>示例一如下：.</p>
<p><img src="/../assets/img/4-1.jpg" alt="图4-1" title="4-1"></p>
<p>这是一个最简单的loop循环，直接通过loop包裹即可.</p>
<p>示例二如下：.</p>
<p><img src="/../assets/img/4-2.jpg" alt="图4-2" title="4-2"></p>
<p>可以看出loop循环中 continue 关键字和 break 关键字的作用，其中 continue 关键字可以<strong>跳过当前循环</strong>，break关键字可以<strong>终止当前循环</strong>.</p>
<p>除此之外，loop循环也可以用来给变量初始化值：.</p>
<p><img src="/../assets/img/4-3.jpg" alt="图4-3" title="4-3"></p>
<p>可以看出来在break处的计算结果最后被赋值给了result.</p>
<p>示例三如下：.</p>
<p><img src="/../assets/img/4-4.jpg" alt="图4-4" title="4-4"></p>
<p>这是一个loop的嵌套循环，里面的loop在执行到目标值后就会退出，但是<strong>不影响外层循环一直执行</strong>,如果想在内层循环结束时结束外层循环，可以按如下所示操作：.</p>
<p><img src="/../assets/img/4-5.jpg" alt="图4-5" title="4-5"></p>
<p>在最外层循环处注册一个 <strong>’名字</strong>, 然后在内层循环<strong>break时候加上该名字</strong>即可</p>
<h3 id="2：while循环"><a href="#2：while循环" class="headerlink" title="2：while循环"></a>2：while循环</h3><p>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> a != 10 &#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,a);</span><br><span class="line">    a += 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>While 循环和loop 循环有很多相似之处,但是while更适用于有明确目标的循环（更简洁）.</p>
<h3 id="3：for循环"><a href="#3：for循环" class="headerlink" title="3：for循环"></a>3：for循环</h3><p>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = [10, 20, 30, 40];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a &#123;</span><br><span class="line">   println!(<span class="string">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以快速创建一个类似range的循环：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> e <span class="keyword">in</span> (1..4) &#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,e);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>这样可以得到一个从1到3的循环，如果在这种情况下想要包括4，则需要将 **(1..4)改为(1..&#x3D;4)**，则得到一个1到4的循环，此外，可以继续修改，得到另外的循环，比如将(1..4)改为(1..4).iter().rev()，就能得到一个在原基础上逆序的循环.</p>
<h3 id="4-所有权转移"><a href="#4-所有权转移" class="headerlink" title="4: 所有权转移"></a>4: 所有权转移</h3><p>先看下面例子：.</p>
<p><img src="/../assets/img/4-6.jpg" alt="图4-6" title="4-6"></p>
<p>在循环执行完之后，直接访问vec的元素，发现报错，此vec的<strong>所有权已经在执行循环时发生了转移</strong>，所以为了避免这种情况，我们在执行循环时，应该写成.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时通过地址引用，只是在<strong>借用vec的所有权</strong>，所以在循环执行完之后依然能访问vec的元素.</p>
<p>此外，如果想要在访问的过程中修改vec的元素则需要向如下这样.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> &amp;mut v &#123;</span><br><span class="line">    <span class="keyword">if</span> *e == 1&#123;</span><br><span class="line">        *e = 2;</span><br><span class="line">    &#125;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将v改为mut，然后访问具体元素时在e前面加上 *号 ，表示直接访问元素而不是地址，最后得到修改后的vec.</p>
<p>但是如果此时遍历的不是一个vec而是一个数组：.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> mut  v = [1,2,3];</span><br><span class="line"><span class="keyword">for</span>  e <span class="keyword">in</span>  v &#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>,e);</span><br><span class="line">&#125;</span><br><span class="line">println!(<span class="string">&quot;&#123;&#125;&quot;</span>,v[0]); </span><br></pre></td></tr></table></figure>
<p>却可以正常访问，因为<strong>数组是实现了copy属性的类型</strong>，在遍历的过程中并<strong>不会发生所有权的转移</strong>，而是直接进行了<strong>数据的拷贝</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/06/rust4/" data-id="cm0sf9tq30003sguye66dfmj7" data-title="rust 学习笔记四 Rust中的流程控制" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/05/rust3/" class="article-date">
  <time class="dt-published" datetime="2024-09-05T14:06:06.672Z" itemprop="datePublished">2024-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/05/rust3/">rust 学习笔记三 Rust中的函数</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>总结一下rust中常见的函数使用方式</p>
<p>首先标准示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn fn_name(i:<span class="built_in">type</span>, j:<span class="built_in">type</span>) -&gt; return_type&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有以下注意事项:.</p>
<p>需要在每个参数后面<strong>声明参数类型</strong>，并在函数体前面加上<strong>返回值类型</strong>.</p>
<p>函数的定义和调用位置没有固定顺序.</p>
<p>且函数名<strong>不能用数字开头</strong>.</p>
<p>对于函数体中的返回值，有以下两种写法：</p>
<p>常规写法：.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn immutable(i:i32, j:i32) -&gt; i32&#123;</span><br><span class="line">    <span class="built_in">return</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及不带return 和 分号，直接写返回值:.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn immutable(i:i32, j:i32) -&gt; i32&#123;</span><br><span class="line">   i + j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个函数没有返回值，则可以<strong>在返回类型处用（）</strong>表示:.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn immutable(i:i32, j:i32)-&gt;()&#123;</span><br><span class="line">   println!(<span class="string">&quot;i + j == &#123;&#125;&quot;</span>,i + j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者直接<strong>去掉返回值部分</strong>:.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn immutable(i:i32, j:i32)&#123;</span><br><span class="line">   println!(<span class="string">&quot;i + j == &#123;&#125;&quot;</span>,i + j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，对于预期会死循环和抛出错误的函数，可以在返回类型处用感叹号表示:.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn immutable()-&gt;!&#123;</span><br><span class="line">   loop &#123;</span><br><span class="line">       //...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/05/rust3/" data-id="cm0sf9tq10001sguy5yajdczp" data-title="rust 学习笔记三 Rust中的函数" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/04/rust2/" class="article-date">
  <time class="dt-published" datetime="2024-09-04T13:38:52.377Z" itemprop="datePublished">2024-09-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/04/rust2/">rust 学习笔记二 变量与可变性</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Rust 是一门安全性非常强的系统级语言，故了解不同种类变量的特性以及使用场景十分重要，本文主要从以下几个步骤来讲解rust中的变量与可变性:<br><strong>可变变量和不可变变量，常量，静态变量，变量遮蔽</strong>.</p>
<h3 id="（一）可变变量和不可变变量"><a href="#（一）可变变量和不可变变量" class="headerlink" title="（一）	可变变量和不可变变量"></a>（一）	可变变量和不可变变量</h3><p>先举出示例如下：<br>直接通过    </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> a = 32;</span><br><span class="line">println!(<span class="string">&quot;value of a is &#123;&#125;&quot;</span>, a);</span><br></pre></td></tr></table></figure>
<p>为变量a赋值为正整数32，并打印，控制台执行<code>cargo run</code>得到输出如下：.</p>
<p><img src="/../assets/img/2-1.jpg" alt="图2-1" title="2-1"></p>
<p>此时如果直接尝试修改a的值，会得到错误提示如下：.</p>
<p><img src="/../assets/img/2-2.jpg" alt="图2-2" title="2-2"></p>
<p>此时的a就是一个不可变变量，根据提示，我们可以通过在变量名前通过<strong>mut修饰</strong>将其变为一个可变变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> mut a = 32;</span><br></pre></td></tr></table></figure>
<p>此时再执行<code>cargo run</code>,发现值被成功修改（会有警告，这个后文再谈），说明此时的a是一个可变变量.</p>
<h3 id="（二）常量"><a href="#（二）常量" class="headerlink" title="（二）	常量"></a>（二）	常量</h3><p>先举出一个正确示例：.</p>
<p><img src="/../assets/img/2-3.jpg" alt="图2-3" title="2-3"></p>
<p>使用<code>const name:type = value</code>的解构定义即可<br>常量定义需注意以下几点：<br>定义时<strong>指定数据类型</strong>，否则报错：.</p>
<p><img src="/../assets/img/2-4.jpg" alt="图2-4" title="2-4"></p>
<p>变量名使用<strong>大写字母</strong>, 否则警告：.</p>
<p><img src="/../assets/img/2-5.jpg" alt="图2-5" title="2-5"></p>
<p>定义时必须<strong>赋初始值</strong>，否则报错：.</p>
<p><img src="/../assets/img/2-6.jpg" alt="图2-1" title="2-6"></p>
<p><strong>不支持重定义或者修改初始值</strong>，否则报错：.</p>
<p><img src="/../assets/img/2-7.jpg" alt="图2-7" title="2-7"></p>
<p>以上这些特性与js 中的常量定义有很大相似之处</p>
<p>此外，常量与上文中的不可变变量有以下区别：</p>
<p>常量使用<strong>const</strong>进行声明,不可变变量使用<strong>let</strong>进行声明.</p>
<p>常量在编译时就确定了值,<strong>不能在运行时改变</strong>。不可变变量直到运行时才能确定下来.</p>
<p>常量不可以修改,不可变变量可以通过<strong>变量遮蔽来二次定义</strong>.</p>
<p>常量必须声明类型,不可变变量不需要声明类型.</p>
<p>常量必须使用<strong>大写字母</strong>,不可变变量不需要.</p>
<h3 id="（三）静态变量"><a href="#（三）静态变量" class="headerlink" title="（三）	静态变量"></a>（三）	静态变量</h3><p>先正确示例如下：.</p>
<p><img src="/../assets/img/2-8.jpg" alt="图2-8" title="2-8"></p>
<p>静态变量有以下特性：</p>
<p>使用<strong>static</strong>声明，在编译时分配内存，运行时一直存在.</p>
<p>可以在多个线程之间共享（全局变量）.</p>
<p>一经定义之后<strong>不可更改</strong>，且也需要大写和指明类型.</p>
<p>与上文中的常量有很多相似之处.</p>
<p>但不同之处在于，<strong>静态变量可通过mut修饰进行修改</strong>，但是修改的代码必须放在<strong>unsafe block</strong>内，如下所示：.</p>
<p><img src="/../assets/img/2-9.jpg" alt="图2-9" title="2-9"></p>
<p>常量在编译时被内联,但静态变量不会。在整个程序中静态变量只有一个实例,也就是说所有引用都指向同一个地址.</p>
<h3 id="（四）-变量遮蔽"><a href="#（四）-变量遮蔽" class="headerlink" title="（四）	 变量遮蔽"></a>（四）	 变量遮蔽</h3><p>示例如下：.</p>
<p><img src="/../assets/img/2-10.jpg" alt="图2-10" title="2-10"><br><img src="/../assets/img/2-11.jpg" alt="图2-11" title="2-11"><br>对于变量，可以直接通过let重复定义将之前的值覆盖掉.</p>
<p>此外，还有如下示例：.</p>
<p><img src="/../assets/img/2-12.jpg" alt="图2-12" title="2-12"></p>
<p>可以看出来，变量遮蔽只会在修改代码的小范围作用域内生效，并不能对外层生效.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/04/rust2/" data-id="cm0sf9tq30002sguy0gr82kin" data-title="rust 学习笔记二 变量与可变性" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-rust1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/02/rust1/" class="article-date">
  <time class="dt-published" datetime="2024-09-02T15:25:27.138Z" itemprop="datePublished">2024-09-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/02/rust1/">rust 学习笔记一 环境搭建</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>rust有内存安全、静态类型和并发安全几大特性，同时在命令行工具  、wasm、 网络服务以及嵌入式设备方面有较广泛的应用， 本篇是rust学习的第一篇笔记</p>
<p>接下来主要介绍rust开发的第一步，环境搭建，主要分为以下几个步骤:</p>
<h3 id="（一）-安装rust"><a href="#（一）-安装rust" class="headerlink" title="（一） 安装rust"></a>（一） 安装rust</h3><p>这里通过rustup下载Rust，这是一个管理Rust版本和相关工具的命令行工具，终端执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https: / /sh.rustup.rs | sh</span><br></pre></td></tr></table></figure>

<p>接下来在命令行输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rustc --version</span><br></pre></td></tr></table></figure>
<p>如果显示如图1-1所示的版本号，时间等信息，表示安装成功.</p>
<p><img src="/../assets/img/version.jpg" alt="图1-1" title="图1-1"></p>
<p>同时 rustup 可以通过<code>rustup update</code>进行对rust版本以及相关依赖的升级，通过<code>rustup self uninstall</code> 进行卸载，通过<code>rustup doc</code>在离线模式下查看rust文档</p>
<h3 id="（二）-在vscode中安装-rust-相关插件"><a href="#（二）-在vscode中安装-rust-相关插件" class="headerlink" title="（二） 在vscode中安装 rust 相关插件"></a>（二） 在vscode中安装 rust 相关插件</h3><p><strong>rust-analyzer</strong></p>
<p><strong>Even Better TOML</strong>(支持toml文件)  </p>
<p><strong>crates</strong>(rust包管理，目前已经失效，根据官方推荐使用<strong>Dependi</strong>代替)</p>
<h3 id="（三）-第一个应用程序"><a href="#（三）-第一个应用程序" class="headerlink" title="（三） 第一个应用程序"></a>（三） 第一个应用程序</h3><p>创建新的空目录，创建程序文件main.rs ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    println!(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在命令行输入<code>rustc main.rs</code>进行编译，然后在同级目录下可以得到名为main.exe的执行文件， 继续输入<code>./main.exe</code>可以执行它得到输出“hello world!”</p>
<h3 id="（四）-cargo（推荐使用）"><a href="#（四）-cargo（推荐使用）" class="headerlink" title="（四） cargo（推荐使用）"></a>（四） cargo（推荐使用）</h3><p>可直接使用cargo进行创建新项目：在控制台输入<code>cargo new projectName</code>可得到一个如图1-2所示的完整的初始化项目目录.</p>
<p><img src="/../assets/img/menu1.jpg" alt="图1-2" title="menu1"></p>
<p>进入src目录下，已经有一个main.rs文件</p>
<p>在终端输入<code>cargo build</code> ，可在target目录下创建一个和上文一样的可执行文件，输入<code>./target/main.exe</code>可以执行它得到输出“hello world!”</p>
<p>另外， 上述两个指令可用一个代替：<code>cargo run</code>(推荐)</p>
<p>当准备发布项目时，终端输入<code>cargo build --release</code>，会在target 目录下生成一个如下所示的release目录.</p>
<p><img src="/../assets/img/menu2.jpg" alt="图1-3" title="图1-3"></p>
<p>此外，根目录中的cargo.toml包含了项目一些基础信息（package以及相关依赖），可在dependencies中添加需要的外部crates以及版本，添加之后重新执行cargo build 安装新的依赖，相关依赖的版本可以在Cargo.lock文件中看到</p>
<p>如果发现拉取依赖时速度慢，可以更换镜像源，在根目录下添加.cargo文件夹，新建config.toml文件，并在其中添加以下内容并重新执行<code>cargo build</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[registries]</span><br><span class="line">ustc=&#123; index = <span class="string">&quot;sparse+https://mirrors.ustc.edu.cn/crates.io-index/&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">[source.crates-io]</span><br><span class="line">replace-with = <span class="string">&#x27;ustc&#x27;</span></span><br><span class="line"></span><br><span class="line">[source.ustc]</span><br><span class="line">registry=<span class="string">&quot;sparse+https://mirrors.ustc.edu.cn/crates.io-index/&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此，环境搭建完成</p>
<p>附：相关书籍<br><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/title-page.html">rust官方程序设计</a><br><a target="_blank" rel="noopener" href="https://course.rs/about-book.html">rust圣经</a><br><a target="_blank" rel="noopener" href="https://practice-zh.course.rs/why-exercise.html">圣经配套练习</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liucanzhu.github.io/2024/09/02/rust1/" data-id="cm0sf9tpw0000sguygulggh5l" data-title="rust 学习笔记一 环境搭建" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/09/15/rust10/">rust 学习笔记十 Rust 中的ENUM</a>
          </li>
        
          <li>
            <a href="/2024/09/13/rust9/">rust 学习笔记九 Rust 中的字符串</a>
          </li>
        
          <li>
            <a href="/2024/09/12/rust8/">rust 学习笔记八 Rust 中的数组与切片</a>
          </li>
        
          <li>
            <a href="/2024/09/10/rust7/">rust 学习笔记七 Rust 中的引用</a>
          </li>
        
          <li>
            <a href="/2024/09/08/rust6/">rust 学习笔记六 Rust中的所有权</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Liu Canzhu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>